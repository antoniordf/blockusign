/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/readable-stream";
exports.ids = ["vendor-chunks/readable-stream"];
exports.modules = {

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/add-abort-signal.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/add-abort-signal.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst { AbortError, codes } = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\")\nconst { isNodeStream, isWebStream, kControllerErrorFunction } = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nconst { ERR_INVALID_ARG_TYPE } = codes\nlet addAbortListener\n\n// This method is inlined here for readable-stream\n// It also does not allow for signal to not exist on the stream\n// https://github.com/nodejs/node/pull/36061#discussion_r533718029\nconst validateAbortSignal = (signal, name) => {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n}\nmodule.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n  validateAbortSignal(signal, 'signal')\n  if (!isNodeStream(stream) && !isWebStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  return module.exports.addAbortSignalNoValidate(signal, stream)\n}\nmodule.exports.addAbortSignalNoValidate = function (signal, stream) {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    return stream\n  }\n  const onAbort = isNodeStream(stream)\n    ? () => {\n        stream.destroy(\n          new AbortError(undefined, {\n            cause: signal.reason\n          })\n        )\n      }\n    : () => {\n        stream[kControllerErrorFunction](\n          new AbortError(undefined, {\n            cause: signal.reason\n          })\n        )\n      }\n  if (signal.aborted) {\n    onAbort()\n  } else {\n    addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\").addAbortListener)\n    const disposable = addAbortListener(signal, onAbort)\n    eos(stream, disposable[SymbolDispose])\n  }\n  return stream\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FkZC1hYm9ydC1zaWduYWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLDRGQUF3QjtBQUMxRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsa0ZBQW1CO0FBQ3pELFFBQVEsc0RBQXNELEVBQUUsbUJBQU8sQ0FBQyxtRkFBUztBQUNqRixZQUFZLG1CQUFPLENBQUMsbUdBQWlCO0FBQ3JDLFFBQVEsdUJBQXVCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDJDQUEyQyxzSEFBMkM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V0aC1sb25kb24tMjAyNC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYWRkLWFib3J0LXNpZ25hbC5qcz9mN2JiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFN5bWJvbERpc3Bvc2UgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgeyBBYm9ydEVycm9yLCBjb2RlcyB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKVxuY29uc3QgeyBpc05vZGVTdHJlYW0sIGlzV2ViU3RyZWFtLCBrQ29udHJvbGxlckVycm9yRnVuY3Rpb24gfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJylcbmNvbnN0IHsgRVJSX0lOVkFMSURfQVJHX1RZUEUgfSA9IGNvZGVzXG5sZXQgYWRkQWJvcnRMaXN0ZW5lclxuXG4vLyBUaGlzIG1ldGhvZCBpcyBpbmxpbmVkIGhlcmUgZm9yIHJlYWRhYmxlLXN0cmVhbVxuLy8gSXQgYWxzbyBkb2VzIG5vdCBhbGxvdyBmb3Igc2lnbmFsIHRvIG5vdCBleGlzdCBvbiB0aGUgc3RyZWFtXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zNjA2MSNkaXNjdXNzaW9uX3I1MzM3MTgwMjlcbmNvbnN0IHZhbGlkYXRlQWJvcnRTaWduYWwgPSAoc2lnbmFsLCBuYW1lKSA9PiB7XG4gIGlmICh0eXBlb2Ygc2lnbmFsICE9PSAnb2JqZWN0JyB8fCAhKCdhYm9ydGVkJyBpbiBzaWduYWwpKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdBYm9ydFNpZ25hbCcsIHNpZ25hbClcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMuYWRkQWJvcnRTaWduYWwgPSBmdW5jdGlvbiBhZGRBYm9ydFNpZ25hbChzaWduYWwsIHN0cmVhbSkge1xuICB2YWxpZGF0ZUFib3J0U2lnbmFsKHNpZ25hbCwgJ3NpZ25hbCcpXG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkgJiYgIWlzV2ViU3RyZWFtKHN0cmVhbSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3N0cmVhbScsIFsnUmVhZGFibGVTdHJlYW0nLCAnV3JpdGFibGVTdHJlYW0nLCAnU3RyZWFtJ10sIHN0cmVhbSlcbiAgfVxuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMuYWRkQWJvcnRTaWduYWxOb1ZhbGlkYXRlKHNpZ25hbCwgc3RyZWFtKVxufVxubW9kdWxlLmV4cG9ydHMuYWRkQWJvcnRTaWduYWxOb1ZhbGlkYXRlID0gZnVuY3Rpb24gKHNpZ25hbCwgc3RyZWFtKSB7XG4gIGlmICh0eXBlb2Ygc2lnbmFsICE9PSAnb2JqZWN0JyB8fCAhKCdhYm9ydGVkJyBpbiBzaWduYWwpKSB7XG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG4gIGNvbnN0IG9uQWJvcnQgPSBpc05vZGVTdHJlYW0oc3RyZWFtKVxuICAgID8gKCkgPT4ge1xuICAgICAgICBzdHJlYW0uZGVzdHJveShcbiAgICAgICAgICBuZXcgQWJvcnRFcnJvcih1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIGNhdXNlOiBzaWduYWwucmVhc29uXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfVxuICAgIDogKCkgPT4ge1xuICAgICAgICBzdHJlYW1ba0NvbnRyb2xsZXJFcnJvckZ1bmN0aW9uXShcbiAgICAgICAgICBuZXcgQWJvcnRFcnJvcih1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIGNhdXNlOiBzaWduYWwucmVhc29uXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfVxuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICBvbkFib3J0KClcbiAgfSBlbHNlIHtcbiAgICBhZGRBYm9ydExpc3RlbmVyID0gYWRkQWJvcnRMaXN0ZW5lciB8fCByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKS5hZGRBYm9ydExpc3RlbmVyXG4gICAgY29uc3QgZGlzcG9zYWJsZSA9IGFkZEFib3J0TGlzdGVuZXIoc2lnbmFsLCBvbkFib3J0KVxuICAgIGVvcyhzdHJlYW0sIGRpc3Bvc2FibGVbU3ltYm9sRGlzcG9zZV0pXG4gIH1cbiAgcmV0dXJuIHN0cmVhbVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!**************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { inspect } = __webpack_require__(/*! ../../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\")\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n  push(v) {\n    const entry = {\n      data: v,\n      next: null\n    }\n    if (this.length > 0) this.tail.next = entry\n    else this.head = entry\n    this.tail = entry\n    ++this.length\n  }\n  unshift(v) {\n    const entry = {\n      data: v,\n      next: this.head\n    }\n    if (this.length === 0) this.tail = entry\n    this.head = entry\n    ++this.length\n  }\n  shift() {\n    if (this.length === 0) return\n    const ret = this.head.data\n    if (this.length === 1) this.head = this.tail = null\n    else this.head = this.head.next\n    --this.length\n    return ret\n  }\n  clear() {\n    this.head = this.tail = null\n    this.length = 0\n  }\n  join(s) {\n    if (this.length === 0) return ''\n    let p = this.head\n    let ret = '' + p.data\n    while ((p = p.next) !== null) ret += s + p.data\n    return ret\n  }\n  concat(n) {\n    if (this.length === 0) return Buffer.alloc(0)\n    const ret = Buffer.allocUnsafe(n >>> 0)\n    let p = this.head\n    let i = 0\n    while (p) {\n      TypedArrayPrototypeSet(ret, p.data, i)\n      i += p.data.length\n      p = p.next\n    }\n    return ret\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n, hasStrings) {\n    const data = this.head.data\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0, n)\n      this.head.data = data.slice(n)\n      return slice\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift()\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n)\n  }\n  first() {\n    return this.head.data\n  }\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = ''\n    let p = this.head\n    let c = 0\n    do {\n      const str = p.data\n      if (n > str.length) {\n        ret += str\n        n -= str.length\n      } else {\n        if (n === str.length) {\n          ret += str\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          ret += StringPrototypeSlice(str, 0, n)\n          this.head = p\n          p.data = StringPrototypeSlice(str, n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n)\n    const retLen = n\n    let p = this.head\n    let c = 0\n    do {\n      const buf = p.data\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret, buf, retLen - n)\n        n -= buf.length\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret, buf, retLen - n)\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n)\n          this.head = p\n          p.data = buf.slice(n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [Symbol.for('nodejs.util.inspect.custom')](_, options) {\n    return inspect(this, {\n      ...options,\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    })\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsMkVBQTJFLEVBQUUsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDckgsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDhFQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsR0FBRztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldGgtbG9uZG9uLTIwMjQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzPzU4NTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgU3RyaW5nUHJvdG90eXBlU2xpY2UsIFN5bWJvbEl0ZXJhdG9yLCBUeXBlZEFycmF5UHJvdG90eXBlU2V0LCBVaW50OEFycmF5IH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyBpbnNwZWN0IH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKVxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBCdWZmZXJMaXN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oZWFkID0gbnVsbFxuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgfVxuICBwdXNoKHYpIHtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGRhdGE6IHYsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnlcbiAgICBlbHNlIHRoaXMuaGVhZCA9IGVudHJ5XG4gICAgdGhpcy50YWlsID0gZW50cnlcbiAgICArK3RoaXMubGVuZ3RoXG4gIH1cbiAgdW5zaGlmdCh2KSB7XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICBkYXRhOiB2LFxuICAgICAgbmV4dDogdGhpcy5oZWFkXG4gICAgfVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnlcbiAgICB0aGlzLmhlYWQgPSBlbnRyeVxuICAgICsrdGhpcy5sZW5ndGhcbiAgfVxuICBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuICAgIGNvbnN0IHJldCA9IHRoaXMuaGVhZC5kYXRhXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsXG4gICAgZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICAgIC0tdGhpcy5sZW5ndGhcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbFxuICAgIHRoaXMubGVuZ3RoID0gMFxuICB9XG4gIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gICAgbGV0IHAgPSB0aGlzLmhlYWRcbiAgICBsZXQgcmV0ID0gJycgKyBwLmRhdGFcbiAgICB3aGlsZSAoKHAgPSBwLm5leHQpICE9PSBudWxsKSByZXQgKz0gcyArIHAuZGF0YVxuICAgIHJldHVybiByZXRcbiAgfVxuICBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICAgIGNvbnN0IHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKVxuICAgIGxldCBwID0gdGhpcy5oZWFkXG4gICAgbGV0IGkgPSAwXG4gICAgd2hpbGUgKHApIHtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVTZXQocmV0LCBwLmRhdGEsIGkpXG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGhcbiAgICAgIHAgPSBwLm5leHRcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIG9yIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgY29uc3VtZShuLCBoYXNTdHJpbmdzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuaGVhZC5kYXRhXG4gICAgaWYgKG4gPCBkYXRhLmxlbmd0aCkge1xuICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIGNvbnN0IHNsaWNlID0gZGF0YS5zbGljZSgwLCBuKVxuICAgICAgdGhpcy5oZWFkLmRhdGEgPSBkYXRhLnNsaWNlKG4pXG4gICAgICByZXR1cm4gc2xpY2VcbiAgICB9XG4gICAgaWYgKG4gPT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyBGaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2guXG4gICAgICByZXR1cm4gdGhpcy5zaGlmdCgpXG4gICAgfVxuICAgIC8vIFJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlci5cbiAgICByZXR1cm4gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKVxuICB9XG4gIGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLmhlYWQuZGF0YVxuICB9XG4gICpbU3ltYm9sSXRlcmF0b3JdKCkge1xuICAgIGZvciAobGV0IHAgPSB0aGlzLmhlYWQ7IHA7IHAgPSBwLm5leHQpIHtcbiAgICAgIHlpZWxkIHAuZGF0YVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gIF9nZXRTdHJpbmcobikge1xuICAgIGxldCByZXQgPSAnJ1xuICAgIGxldCBwID0gdGhpcy5oZWFkXG4gICAgbGV0IGMgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3Qgc3RyID0gcC5kYXRhXG4gICAgICBpZiAobiA+IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0ICs9IHN0clxuICAgICAgICBuIC09IHN0ci5sZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0ICs9IHN0clxuICAgICAgICAgICsrY1xuICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dFxuICAgICAgICAgIGVsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCArPSBTdHJpbmdQcm90b3R5cGVTbGljZShzdHIsIDAsIG4pXG4gICAgICAgICAgdGhpcy5oZWFkID0gcFxuICAgICAgICAgIHAuZGF0YSA9IFN0cmluZ1Byb3RvdHlwZVNsaWNlKHN0ciwgbilcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgKytjXG4gICAgfSB3aGlsZSAoKHAgPSBwLm5leHQpICE9PSBudWxsKVxuICAgIHRoaXMubGVuZ3RoIC09IGNcbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgX2dldEJ1ZmZlcihuKSB7XG4gICAgY29uc3QgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pXG4gICAgY29uc3QgcmV0TGVuID0gblxuICAgIGxldCBwID0gdGhpcy5oZWFkXG4gICAgbGV0IGMgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYnVmID0gcC5kYXRhXG4gICAgICBpZiAobiA+IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZVNldChyZXQsIGJ1ZiwgcmV0TGVuIC0gbilcbiAgICAgICAgbiAtPSBidWYubGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVTZXQocmV0LCBidWYsIHJldExlbiAtIG4pXG4gICAgICAgICAgKytjXG4gICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0XG4gICAgICAgICAgZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZVNldChyZXQsIG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKSwgcmV0TGVuIC0gbilcbiAgICAgICAgICB0aGlzLmhlYWQgPSBwXG4gICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG4pXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgICsrY1xuICAgIH0gd2hpbGUgKChwID0gcC5uZXh0KSAhPT0gbnVsbClcbiAgICB0aGlzLmxlbmd0aCAtPSBjXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSBsaW5rZWQgbGlzdCBvbmx5IHNob3dzIHRoZSBtaW5pbWFsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbi5cbiAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKF8sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgLy8gT25seSBpbnNwZWN0IG9uZSBsZXZlbC5cbiAgICAgIGRlcHRoOiAwLFxuICAgICAgLy8gSXQgc2hvdWxkIG5vdCByZWN1cnNlLlxuICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgICB9KVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/buffer_list.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/compose.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/compose.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { pipeline } = __webpack_require__(/*! ./pipeline */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/pipeline.js\")\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/duplex.js\")\nconst { destroyer } = __webpack_require__(/*! ./destroy */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst {\n  isNodeStream,\n  isReadable,\n  isWritable,\n  isWebStream,\n  isTransformStream,\n  isWritableStream,\n  isReadableStream\n} = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }\n} = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\")\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nmodule.exports = function compose(...streams) {\n  if (streams.length === 0) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  if (streams.length === 1) {\n    return Duplex.from(streams[0])\n  }\n  const orgStreams = [...streams]\n  if (typeof streams[0] === 'function') {\n    streams[0] = Duplex.from(streams[0])\n  }\n  if (typeof streams[streams.length - 1] === 'function') {\n    const idx = streams.length - 1\n    streams[idx] = Duplex.from(streams[idx])\n  }\n  for (let n = 0; n < streams.length; ++n) {\n    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {\n      // TODO(ronag): Add checks for non streams.\n      continue\n    }\n    if (\n      n < streams.length - 1 &&\n      !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))\n    ) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable')\n    }\n    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable')\n    }\n  }\n  let ondrain\n  let onfinish\n  let onreadable\n  let onclose\n  let d\n  function onfinished(err) {\n    const cb = onclose\n    onclose = null\n    if (cb) {\n      cb(err)\n    } else if (err) {\n      d.destroy(err)\n    } else if (!readable && !writable) {\n      d.destroy()\n    }\n  }\n  const head = streams[0]\n  const tail = pipeline(streams, onfinished)\n  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head))\n  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail))\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplex({\n    // TODO (ronag): highWaterMark?\n    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),\n    readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),\n    writable,\n    readable\n  })\n  if (writable) {\n    if (isNodeStream(head)) {\n      d._write = function (chunk, encoding, callback) {\n        if (head.write(chunk, encoding)) {\n          callback()\n        } else {\n          ondrain = callback\n        }\n      }\n      d._final = function (callback) {\n        head.end()\n        onfinish = callback\n      }\n      head.on('drain', function () {\n        if (ondrain) {\n          const cb = ondrain\n          ondrain = null\n          cb()\n        }\n      })\n    } else if (isWebStream(head)) {\n      const writable = isTransformStream(head) ? head.writable : head\n      const writer = writable.getWriter()\n      d._write = async function (chunk, encoding, callback) {\n        try {\n          await writer.ready\n          writer.write(chunk).catch(() => {})\n          callback()\n        } catch (err) {\n          callback(err)\n        }\n      }\n      d._final = async function (callback) {\n        try {\n          await writer.ready\n          writer.close().catch(() => {})\n          onfinish = callback\n        } catch (err) {\n          callback(err)\n        }\n      }\n    }\n    const toRead = isTransformStream(tail) ? tail.readable : tail\n    eos(toRead, () => {\n      if (onfinish) {\n        const cb = onfinish\n        onfinish = null\n        cb()\n      }\n    })\n  }\n  if (readable) {\n    if (isNodeStream(tail)) {\n      tail.on('readable', function () {\n        if (onreadable) {\n          const cb = onreadable\n          onreadable = null\n          cb()\n        }\n      })\n      tail.on('end', function () {\n        d.push(null)\n      })\n      d._read = function () {\n        while (true) {\n          const buf = tail.read()\n          if (buf === null) {\n            onreadable = d._read\n            return\n          }\n          if (!d.push(buf)) {\n            return\n          }\n        }\n      }\n    } else if (isWebStream(tail)) {\n      const readable = isTransformStream(tail) ? tail.readable : tail\n      const reader = readable.getReader()\n      d._read = async function () {\n        while (true) {\n          try {\n            const { value, done } = await reader.read()\n            if (!d.push(value)) {\n              return\n            }\n            if (done) {\n              d.push(null)\n              return\n            }\n          } catch {\n            return\n          }\n        }\n      }\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError()\n    }\n    onreadable = null\n    ondrain = null\n    onfinish = null\n    if (onclose === null) {\n      callback(err)\n    } else {\n      onclose = callback\n      if (isNodeStream(tail)) {\n        destroyer(tail, err)\n      }\n    }\n  }\n  return d\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2NvbXBvc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyx5RkFBWTtBQUN6QyxlQUFlLG1CQUFPLENBQUMscUZBQVU7QUFDakMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyx1RkFBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsbUZBQVM7QUFDckI7QUFDQTtBQUNBLFdBQVc7QUFDWCxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLG1HQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldGgtbG9uZG9uLTIwMjQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2NvbXBvc2UuanM/YTFkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwaXBlbGluZSB9ID0gcmVxdWlyZSgnLi9waXBlbGluZScpXG5jb25zdCBEdXBsZXggPSByZXF1aXJlKCcuL2R1cGxleCcpXG5jb25zdCB7IGRlc3Ryb3llciB9ID0gcmVxdWlyZSgnLi9kZXN0cm95JylcbmNvbnN0IHtcbiAgaXNOb2RlU3RyZWFtLFxuICBpc1JlYWRhYmxlLFxuICBpc1dyaXRhYmxlLFxuICBpc1dlYlN0cmVhbSxcbiAgaXNUcmFuc2Zvcm1TdHJlYW0sXG4gIGlzV3JpdGFibGVTdHJlYW0sXG4gIGlzUmVhZGFibGVTdHJlYW1cbn0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IHtcbiAgQWJvcnRFcnJvcixcbiAgY29kZXM6IHsgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCBFUlJfTUlTU0lOR19BUkdTIH1cbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21wb3NlKC4uLnN0cmVhbXMpIHtcbiAgaWYgKHN0cmVhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKVxuICB9XG4gIGlmIChzdHJlYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBEdXBsZXguZnJvbShzdHJlYW1zWzBdKVxuICB9XG4gIGNvbnN0IG9yZ1N0cmVhbXMgPSBbLi4uc3RyZWFtc11cbiAgaWYgKHR5cGVvZiBzdHJlYW1zWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyZWFtc1swXSA9IER1cGxleC5mcm9tKHN0cmVhbXNbMF0pXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBpZHggPSBzdHJlYW1zLmxlbmd0aCAtIDFcbiAgICBzdHJlYW1zW2lkeF0gPSBEdXBsZXguZnJvbShzdHJlYW1zW2lkeF0pXG4gIH1cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBzdHJlYW1zLmxlbmd0aDsgKytuKSB7XG4gICAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtc1tuXSkgJiYgIWlzV2ViU3RyZWFtKHN0cmVhbXNbbl0pKSB7XG4gICAgICAvLyBUT0RPKHJvbmFnKTogQWRkIGNoZWNrcyBmb3Igbm9uIHN0cmVhbXMuXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoXG4gICAgICBuIDwgc3RyZWFtcy5sZW5ndGggLSAxICYmXG4gICAgICAhKGlzUmVhZGFibGUoc3RyZWFtc1tuXSkgfHwgaXNSZWFkYWJsZVN0cmVhbShzdHJlYW1zW25dKSB8fCBpc1RyYW5zZm9ybVN0cmVhbShzdHJlYW1zW25dKSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoYHN0cmVhbXNbJHtufV1gLCBvcmdTdHJlYW1zW25dLCAnbXVzdCBiZSByZWFkYWJsZScpXG4gICAgfVxuICAgIGlmIChuID4gMCAmJiAhKGlzV3JpdGFibGUoc3RyZWFtc1tuXSkgfHwgaXNXcml0YWJsZVN0cmVhbShzdHJlYW1zW25dKSB8fCBpc1RyYW5zZm9ybVN0cmVhbShzdHJlYW1zW25dKSkpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoYHN0cmVhbXNbJHtufV1gLCBvcmdTdHJlYW1zW25dLCAnbXVzdCBiZSB3cml0YWJsZScpXG4gICAgfVxuICB9XG4gIGxldCBvbmRyYWluXG4gIGxldCBvbmZpbmlzaFxuICBsZXQgb25yZWFkYWJsZVxuICBsZXQgb25jbG9zZVxuICBsZXQgZFxuICBmdW5jdGlvbiBvbmZpbmlzaGVkKGVycikge1xuICAgIGNvbnN0IGNiID0gb25jbG9zZVxuICAgIG9uY2xvc2UgPSBudWxsXG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpXG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGQuZGVzdHJveShlcnIpXG4gICAgfSBlbHNlIGlmICghcmVhZGFibGUgJiYgIXdyaXRhYmxlKSB7XG4gICAgICBkLmRlc3Ryb3koKVxuICAgIH1cbiAgfVxuICBjb25zdCBoZWFkID0gc3RyZWFtc1swXVxuICBjb25zdCB0YWlsID0gcGlwZWxpbmUoc3RyZWFtcywgb25maW5pc2hlZClcbiAgY29uc3Qgd3JpdGFibGUgPSAhIShpc1dyaXRhYmxlKGhlYWQpIHx8IGlzV3JpdGFibGVTdHJlYW0oaGVhZCkgfHwgaXNUcmFuc2Zvcm1TdHJlYW0oaGVhZCkpXG4gIGNvbnN0IHJlYWRhYmxlID0gISEoaXNSZWFkYWJsZSh0YWlsKSB8fCBpc1JlYWRhYmxlU3RyZWFtKHRhaWwpIHx8IGlzVHJhbnNmb3JtU3RyZWFtKHRhaWwpKVxuXG4gIC8vIFRPRE8ocm9uYWcpOiBBdm9pZCBkb3VibGUgYnVmZmVyaW5nLlxuICAvLyBJbXBsZW1lbnQgV3JpdGFibGUvUmVhZGFibGUvRHVwbGV4IHRyYWl0cy5cbiAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMzUxNS5cbiAgZCA9IG5ldyBEdXBsZXgoe1xuICAgIC8vIFRPRE8gKHJvbmFnKTogaGlnaFdhdGVyTWFyaz9cbiAgICB3cml0YWJsZU9iamVjdE1vZGU6ICEhKGhlYWQgIT09IG51bGwgJiYgaGVhZCAhPT0gdW5kZWZpbmVkICYmIGhlYWQud3JpdGFibGVPYmplY3RNb2RlKSxcbiAgICByZWFkYWJsZU9iamVjdE1vZGU6ICEhKHRhaWwgIT09IG51bGwgJiYgdGFpbCAhPT0gdW5kZWZpbmVkICYmIHRhaWwucmVhZGFibGVPYmplY3RNb2RlKSxcbiAgICB3cml0YWJsZSxcbiAgICByZWFkYWJsZVxuICB9KVxuICBpZiAod3JpdGFibGUpIHtcbiAgICBpZiAoaXNOb2RlU3RyZWFtKGhlYWQpKSB7XG4gICAgICBkLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChoZWFkLndyaXRlKGNodW5rLCBlbmNvZGluZykpIHtcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25kcmFpbiA9IGNhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGQuX2ZpbmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGhlYWQuZW5kKClcbiAgICAgICAgb25maW5pc2ggPSBjYWxsYmFja1xuICAgICAgfVxuICAgICAgaGVhZC5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvbmRyYWluKSB7XG4gICAgICAgICAgY29uc3QgY2IgPSBvbmRyYWluXG4gICAgICAgICAgb25kcmFpbiA9IG51bGxcbiAgICAgICAgICBjYigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChpc1dlYlN0cmVhbShoZWFkKSkge1xuICAgICAgY29uc3Qgd3JpdGFibGUgPSBpc1RyYW5zZm9ybVN0cmVhbShoZWFkKSA/IGhlYWQud3JpdGFibGUgOiBoZWFkXG4gICAgICBjb25zdCB3cml0ZXIgPSB3cml0YWJsZS5nZXRXcml0ZXIoKVxuICAgICAgZC5fd3JpdGUgPSBhc3luYyBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHdyaXRlci5yZWFkeVxuICAgICAgICAgIHdyaXRlci53cml0ZShjaHVuaykuY2F0Y2goKCkgPT4ge30pXG4gICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGQuX2ZpbmFsID0gYXN5bmMgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5XG4gICAgICAgICAgd3JpdGVyLmNsb3NlKCkuY2F0Y2goKCkgPT4ge30pXG4gICAgICAgICAgb25maW5pc2ggPSBjYWxsYmFja1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdG9SZWFkID0gaXNUcmFuc2Zvcm1TdHJlYW0odGFpbCkgPyB0YWlsLnJlYWRhYmxlIDogdGFpbFxuICAgIGVvcyh0b1JlYWQsICgpID0+IHtcbiAgICAgIGlmIChvbmZpbmlzaCkge1xuICAgICAgICBjb25zdCBjYiA9IG9uZmluaXNoXG4gICAgICAgIG9uZmluaXNoID0gbnVsbFxuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBpZiAocmVhZGFibGUpIHtcbiAgICBpZiAoaXNOb2RlU3RyZWFtKHRhaWwpKSB7XG4gICAgICB0YWlsLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9ucmVhZGFibGUpIHtcbiAgICAgICAgICBjb25zdCBjYiA9IG9ucmVhZGFibGVcbiAgICAgICAgICBvbnJlYWRhYmxlID0gbnVsbFxuICAgICAgICAgIGNiKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRhaWwub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZC5wdXNoKG51bGwpXG4gICAgICB9KVxuICAgICAgZC5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBidWYgPSB0YWlsLnJlYWQoKVxuICAgICAgICAgIGlmIChidWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9ucmVhZGFibGUgPSBkLl9yZWFkXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkLnB1c2goYnVmKSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1dlYlN0cmVhbSh0YWlsKSkge1xuICAgICAgY29uc3QgcmVhZGFibGUgPSBpc1RyYW5zZm9ybVN0cmVhbSh0YWlsKSA/IHRhaWwucmVhZGFibGUgOiB0YWlsXG4gICAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZS5nZXRSZWFkZXIoKVxuICAgICAgZC5fcmVhZCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuICAgICAgICAgICAgaWYgKCFkLnB1c2godmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgZC5wdXNoKG51bGwpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICghZXJyICYmIG9uY2xvc2UgIT09IG51bGwpIHtcbiAgICAgIGVyciA9IG5ldyBBYm9ydEVycm9yKClcbiAgICB9XG4gICAgb25yZWFkYWJsZSA9IG51bGxcbiAgICBvbmRyYWluID0gbnVsbFxuICAgIG9uZmluaXNoID0gbnVsbFxuICAgIGlmIChvbmNsb3NlID09PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9uY2xvc2UgPSBjYWxsYmFja1xuICAgICAgaWYgKGlzTm9kZVN0cmVhbSh0YWlsKSkge1xuICAgICAgICBkZXN0cm95ZXIodGFpbCwgZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/compose.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(ssr)/./node_modules/process/index.js\")\n\n/* replacement end */\n\nconst {\n  aggregateTwoErrors,\n  codes: { ERR_MULTIPLE_CALLBACK },\n  AbortError\n} = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\")\nconst { Symbol } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst kDestroy = Symbol('kDestroy')\nconst kConstruct = Symbol('kConstruct')\nfunction checkError(err, w, r) {\n  if (err) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err\n    }\n    if (r && !r.errored) {\n      r.errored = err\n    }\n  }\n}\n\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err, cb) {\n  const r = this._readableState\n  const w = this._writableState\n  // With duplex streams we use the writable side for state.\n  const s = w || r\n  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {\n    if (typeof cb === 'function') {\n      cb()\n    }\n    return this\n  }\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n  checkError(err, w, r)\n  if (w) {\n    w.destroyed = true\n  }\n  if (r) {\n    r.destroyed = true\n  }\n\n  // If still constructing then defer calling _destroy.\n  if (!s.constructed) {\n    this.once(kDestroy, function (er) {\n      _destroy(this, aggregateTwoErrors(er, err), cb)\n    })\n  } else {\n    _destroy(this, err, cb)\n  }\n  return this\n}\nfunction _destroy(self, err, cb) {\n  let called = false\n  function onDestroy(err) {\n    if (called) {\n      return\n    }\n    called = true\n    const r = self._readableState\n    const w = self._writableState\n    checkError(err, w, r)\n    if (w) {\n      w.closed = true\n    }\n    if (r) {\n      r.closed = true\n    }\n    if (typeof cb === 'function') {\n      cb(err)\n    }\n    if (err) {\n      process.nextTick(emitErrorCloseNT, self, err)\n    } else {\n      process.nextTick(emitCloseNT, self)\n    }\n  }\n  try {\n    self._destroy(err || null, onDestroy)\n  } catch (err) {\n    onDestroy(err)\n  }\n}\nfunction emitErrorCloseNT(self, err) {\n  emitErrorNT(self, err)\n  emitCloseNT(self)\n}\nfunction emitCloseNT(self) {\n  const r = self._readableState\n  const w = self._writableState\n  if (w) {\n    w.closeEmitted = true\n  }\n  if (r) {\n    r.closeEmitted = true\n  }\n  if ((w !== null && w !== undefined && w.emitClose) || (r !== null && r !== undefined && r.emitClose)) {\n    self.emit('close')\n  }\n}\nfunction emitErrorNT(self, err) {\n  const r = self._readableState\n  const w = self._writableState\n  if ((w !== null && w !== undefined && w.errorEmitted) || (r !== null && r !== undefined && r.errorEmitted)) {\n    return\n  }\n  if (w) {\n    w.errorEmitted = true\n  }\n  if (r) {\n    r.errorEmitted = true\n  }\n  self.emit('error', err)\n}\nfunction undestroy() {\n  const r = this._readableState\n  const w = this._writableState\n  if (r) {\n    r.constructed = true\n    r.closed = false\n    r.closeEmitted = false\n    r.destroyed = false\n    r.errored = null\n    r.errorEmitted = false\n    r.reading = false\n    r.ended = r.readable === false\n    r.endEmitted = r.readable === false\n  }\n  if (w) {\n    w.constructed = true\n    w.destroyed = false\n    w.closed = false\n    w.closeEmitted = false\n    w.errored = null\n    w.errorEmitted = false\n    w.finalCalled = false\n    w.prefinished = false\n    w.ended = w.writable === false\n    w.ending = w.writable === false\n    w.finished = w.writable === false\n  }\n}\nfunction errorOrDestroy(stream, err, sync) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const r = stream._readableState\n  const w = stream._writableState\n  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {\n    return this\n  }\n  if ((r !== null && r !== undefined && r.autoDestroy) || (w !== null && w !== undefined && w.autoDestroy))\n    stream.destroy(err)\n  else if (err) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err\n    }\n    if (r && !r.errored) {\n      r.errored = err\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT, stream, err)\n    } else {\n      emitErrorNT(stream, err)\n    }\n  }\n}\nfunction construct(stream, cb) {\n  if (typeof stream._construct !== 'function') {\n    return\n  }\n  const r = stream._readableState\n  const w = stream._writableState\n  if (r) {\n    r.constructed = false\n  }\n  if (w) {\n    w.constructed = false\n  }\n  stream.once(kConstruct, cb)\n  if (stream.listenerCount(kConstruct) > 1) {\n    // Duplex\n    return\n  }\n  process.nextTick(constructNT, stream)\n}\nfunction constructNT(stream) {\n  let called = false\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK())\n      return\n    }\n    called = true\n    const r = stream._readableState\n    const w = stream._writableState\n    const s = w || r\n    if (r) {\n      r.constructed = true\n    }\n    if (w) {\n      w.constructed = true\n    }\n    if (s.destroyed) {\n      stream.emit(kDestroy, err)\n    } else if (err) {\n      errorOrDestroy(stream, err, true)\n    } else {\n      process.nextTick(emitConstructNT, stream)\n    }\n  }\n  try {\n    stream._construct((err) => {\n      process.nextTick(onConstruct, err)\n    })\n  } catch (err) {\n    process.nextTick(onConstruct, err)\n  }\n}\nfunction emitConstructNT(stream) {\n  stream.emit(kConstruct)\n}\nfunction isRequest(stream) {\n  return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === 'function'\n}\nfunction emitCloseLegacy(stream) {\n  stream.emit('close')\n}\nfunction emitErrorCloseLegacy(stream, err) {\n  stream.emit('error', err)\n  process.nextTick(emitCloseLegacy, stream)\n}\n\n// Normalize destroy for legacy.\nfunction destroyer(stream, err) {\n  if (!stream || isDestroyed(stream)) {\n    return\n  }\n  if (!err && !isFinished(stream)) {\n    err = new AbortError()\n  }\n\n  // TODO: Remove isRequest branches.\n  if (isServerRequest(stream)) {\n    stream.socket = null\n    stream.destroy(err)\n  } else if (isRequest(stream)) {\n    stream.abort()\n  } else if (isRequest(stream.req)) {\n    stream.req.abort()\n  } else if (typeof stream.destroy === 'function') {\n    stream.destroy(err)\n  } else if (typeof stream.close === 'function') {\n    // TODO: Don't lose err?\n    stream.close()\n  } else if (err) {\n    process.nextTick(emitErrorCloseLegacy, stream, err)\n  } else {\n    process.nextTick(emitCloseLegacy, stream)\n  }\n  if (!stream.destroyed) {\n    stream[kIsDestroyed] = true\n  }\n}\nmodule.exports = {\n  construct,\n  destroyer,\n  destroy,\n  undestroy,\n  errorOrDestroy\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsdURBQVU7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGtGQUFtQjtBQUMvQixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDRGQUF3QjtBQUNuRCxRQUFRLHlEQUF5RCxFQUFFLG1CQUFPLENBQUMsbUZBQVM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldGgtbG9uZG9uLTIwMjQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanM/MTE2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyogcmVwbGFjZW1lbnQgc3RhcnQgKi9cblxuY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoJ3Byb2Nlc3MvJylcblxuLyogcmVwbGFjZW1lbnQgZW5kICovXG5cbmNvbnN0IHtcbiAgYWdncmVnYXRlVHdvRXJyb3JzLFxuICBjb2RlczogeyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgfSxcbiAgQWJvcnRFcnJvclxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJylcbmNvbnN0IHsgU3ltYm9sIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHsga0lzRGVzdHJveWVkLCBpc0Rlc3Ryb3llZCwgaXNGaW5pc2hlZCwgaXNTZXJ2ZXJSZXF1ZXN0IH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IGtEZXN0cm95ID0gU3ltYm9sKCdrRGVzdHJveScpXG5jb25zdCBrQ29uc3RydWN0ID0gU3ltYm9sKCdrQ29uc3RydWN0JylcbmZ1bmN0aW9uIGNoZWNrRXJyb3IoZXJyLCB3LCByKSB7XG4gIGlmIChlcnIpIHtcbiAgICAvLyBBdm9pZCBWOCBsZWFrLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zNDEwMyNpc3N1ZWNvbW1lbnQtNjUyMDAyMzY0XG4gICAgZXJyLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgICBpZiAodyAmJiAhdy5lcnJvcmVkKSB7XG4gICAgICB3LmVycm9yZWQgPSBlcnJcbiAgICB9XG4gICAgaWYgKHIgJiYgIXIuZXJyb3JlZCkge1xuICAgICAgci5lcnJvcmVkID0gZXJyXG4gICAgfVxuICB9XG59XG5cbi8vIEJhY2t3YXJkcyBjb21wYXQuIGNiKCkgaXMgdW5kb2N1bWVudGVkIGFuZCB1bnVzZWQgaW4gY29yZSBidXRcbi8vIHVuZm9ydHVuYXRlbHkgbWlnaHQgYmUgdXNlZCBieSBtb2R1bGVzLlxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIGNvbnN0IHIgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHcgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gIC8vIFdpdGggZHVwbGV4IHN0cmVhbXMgd2UgdXNlIHRoZSB3cml0YWJsZSBzaWRlIGZvciBzdGF0ZS5cbiAgY29uc3QgcyA9IHcgfHwgclxuICBpZiAoKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcuZGVzdHJveWVkKSB8fCAociAhPT0gbnVsbCAmJiByICE9PSB1bmRlZmluZWQgJiYgci5kZXN0cm95ZWQpKSB7XG4gICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gV2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuICBjaGVja0Vycm9yKGVyciwgdywgcilcbiAgaWYgKHcpIHtcbiAgICB3LmRlc3Ryb3llZCA9IHRydWVcbiAgfVxuICBpZiAocikge1xuICAgIHIuZGVzdHJveWVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gSWYgc3RpbGwgY29uc3RydWN0aW5nIHRoZW4gZGVmZXIgY2FsbGluZyBfZGVzdHJveS5cbiAgaWYgKCFzLmNvbnN0cnVjdGVkKSB7XG4gICAgdGhpcy5vbmNlKGtEZXN0cm95LCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIF9kZXN0cm95KHRoaXMsIGFnZ3JlZ2F0ZVR3b0Vycm9ycyhlciwgZXJyKSwgY2IpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBfZGVzdHJveSh0aGlzLCBlcnIsIGNiKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5mdW5jdGlvbiBfZGVzdHJveShzZWxmLCBlcnIsIGNiKSB7XG4gIGxldCBjYWxsZWQgPSBmYWxzZVxuICBmdW5jdGlvbiBvbkRlc3Ryb3koZXJyKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWVcbiAgICBjb25zdCByID0gc2VsZi5fcmVhZGFibGVTdGF0ZVxuICAgIGNvbnN0IHcgPSBzZWxmLl93cml0YWJsZVN0YXRlXG4gICAgY2hlY2tFcnJvcihlcnIsIHcsIHIpXG4gICAgaWYgKHcpIHtcbiAgICAgIHcuY2xvc2VkID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAocikge1xuICAgICAgci5jbG9zZWQgPSB0cnVlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiKGVycilcbiAgICB9XG4gICAgaWYgKGVycikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JDbG9zZU5ULCBzZWxmLCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIHNlbGYpXG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgc2VsZi5fZGVzdHJveShlcnIgfHwgbnVsbCwgb25EZXN0cm95KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBvbkRlc3Ryb3koZXJyKVxuICB9XG59XG5mdW5jdGlvbiBlbWl0RXJyb3JDbG9zZU5UKHNlbGYsIGVycikge1xuICBlbWl0RXJyb3JOVChzZWxmLCBlcnIpXG4gIGVtaXRDbG9zZU5UKHNlbGYpXG59XG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGNvbnN0IHIgPSBzZWxmLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHcgPSBzZWxmLl93cml0YWJsZVN0YXRlXG4gIGlmICh3KSB7XG4gICAgdy5jbG9zZUVtaXR0ZWQgPSB0cnVlXG4gIH1cbiAgaWYgKHIpIHtcbiAgICByLmNsb3NlRW1pdHRlZCA9IHRydWVcbiAgfVxuICBpZiAoKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcuZW1pdENsb3NlKSB8fCAociAhPT0gbnVsbCAmJiByICE9PSB1bmRlZmluZWQgJiYgci5lbWl0Q2xvc2UpKSB7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScpXG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBjb25zdCByID0gc2VsZi5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB3ID0gc2VsZi5fd3JpdGFibGVTdGF0ZVxuICBpZiAoKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcuZXJyb3JFbWl0dGVkKSB8fCAociAhPT0gbnVsbCAmJiByICE9PSB1bmRlZmluZWQgJiYgci5lcnJvckVtaXR0ZWQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHcpIHtcbiAgICB3LmVycm9yRW1pdHRlZCA9IHRydWVcbiAgfVxuICBpZiAocikge1xuICAgIHIuZXJyb3JFbWl0dGVkID0gdHJ1ZVxuICB9XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG59XG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGNvbnN0IHIgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHcgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gIGlmIChyKSB7XG4gICAgci5jb25zdHJ1Y3RlZCA9IHRydWVcbiAgICByLmNsb3NlZCA9IGZhbHNlXG4gICAgci5jbG9zZUVtaXR0ZWQgPSBmYWxzZVxuICAgIHIuZGVzdHJveWVkID0gZmFsc2VcbiAgICByLmVycm9yZWQgPSBudWxsXG4gICAgci5lcnJvckVtaXR0ZWQgPSBmYWxzZVxuICAgIHIucmVhZGluZyA9IGZhbHNlXG4gICAgci5lbmRlZCA9IHIucmVhZGFibGUgPT09IGZhbHNlXG4gICAgci5lbmRFbWl0dGVkID0gci5yZWFkYWJsZSA9PT0gZmFsc2VcbiAgfVxuICBpZiAodykge1xuICAgIHcuY29uc3RydWN0ZWQgPSB0cnVlXG4gICAgdy5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIHcuY2xvc2VkID0gZmFsc2VcbiAgICB3LmNsb3NlRW1pdHRlZCA9IGZhbHNlXG4gICAgdy5lcnJvcmVkID0gbnVsbFxuICAgIHcuZXJyb3JFbWl0dGVkID0gZmFsc2VcbiAgICB3LmZpbmFsQ2FsbGVkID0gZmFsc2VcbiAgICB3LnByZWZpbmlzaGVkID0gZmFsc2VcbiAgICB3LmVuZGVkID0gdy53cml0YWJsZSA9PT0gZmFsc2VcbiAgICB3LmVuZGluZyA9IHcud3JpdGFibGUgPT09IGZhbHNlXG4gICAgdy5maW5pc2hlZCA9IHcud3JpdGFibGUgPT09IGZhbHNlXG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyLCBzeW5jKSB7XG4gIC8vIFdlIGhhdmUgdGVzdHMgdGhhdCByZWx5IG9uIGVycm9ycyBiZWluZyBlbWl0dGVkXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxuICAvLyBGb3Igbm93IHdoZW4geW91IG9wdC1pbiB0byBhdXRvRGVzdHJveSB3ZSBhbGxvd1xuICAvLyB0aGUgZXJyb3IgdG8gYmUgZW1pdHRlZCBuZXh0VGljay4gSW4gYSBmdXR1cmVcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXG5cbiAgY29uc3QgciA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB3ID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGlmICgodyAhPT0gbnVsbCAmJiB3ICE9PSB1bmRlZmluZWQgJiYgdy5kZXN0cm95ZWQpIHx8IChyICE9PSBudWxsICYmIHIgIT09IHVuZGVmaW5lZCAmJiByLmRlc3Ryb3llZCkpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIGlmICgociAhPT0gbnVsbCAmJiByICE9PSB1bmRlZmluZWQgJiYgci5hdXRvRGVzdHJveSkgfHwgKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcuYXV0b0Rlc3Ryb3kpKVxuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgZWxzZSBpZiAoZXJyKSB7XG4gICAgLy8gQXZvaWQgVjggbGVhaywgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzQxMDMjaXNzdWVjb21tZW50LTY1MjAwMjM2NFxuICAgIGVyci5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXG4gICAgaWYgKHcgJiYgIXcuZXJyb3JlZCkge1xuICAgICAgdy5lcnJvcmVkID0gZXJyXG4gICAgfVxuICAgIGlmIChyICYmICFyLmVycm9yZWQpIHtcbiAgICAgIHIuZXJyb3JlZCA9IGVyclxuICAgIH1cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgc3RyZWFtLCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXRFcnJvck5UKHN0cmVhbSwgZXJyKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29uc3RydWN0KHN0cmVhbSwgY2IpIHtcbiAgaWYgKHR5cGVvZiBzdHJlYW0uX2NvbnN0cnVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHIgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgY29uc3QgdyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBpZiAocikge1xuICAgIHIuY29uc3RydWN0ZWQgPSBmYWxzZVxuICB9XG4gIGlmICh3KSB7XG4gICAgdy5jb25zdHJ1Y3RlZCA9IGZhbHNlXG4gIH1cbiAgc3RyZWFtLm9uY2Uoa0NvbnN0cnVjdCwgY2IpXG4gIGlmIChzdHJlYW0ubGlzdGVuZXJDb3VudChrQ29uc3RydWN0KSA+IDEpIHtcbiAgICAvLyBEdXBsZXhcbiAgICByZXR1cm5cbiAgfVxuICBwcm9jZXNzLm5leHRUaWNrKGNvbnN0cnVjdE5ULCBzdHJlYW0pXG59XG5mdW5jdGlvbiBjb25zdHJ1Y3ROVChzdHJlYW0pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlXG4gIGZ1bmN0aW9uIG9uQ29uc3RydWN0KGVycikge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyICE9PSBudWxsICYmIGVyciAhPT0gdW5kZWZpbmVkID8gZXJyIDogbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWVcbiAgICBjb25zdCByID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gICAgY29uc3QgdyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICAgIGNvbnN0IHMgPSB3IHx8IHJcbiAgICBpZiAocikge1xuICAgICAgci5jb25zdHJ1Y3RlZCA9IHRydWVcbiAgICB9XG4gICAgaWYgKHcpIHtcbiAgICAgIHcuY29uc3RydWN0ZWQgPSB0cnVlXG4gICAgfVxuICAgIGlmIChzLmRlc3Ryb3llZCkge1xuICAgICAgc3RyZWFtLmVtaXQoa0Rlc3Ryb3ksIGVycilcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENvbnN0cnVjdE5ULCBzdHJlYW0pXG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgc3RyZWFtLl9jb25zdHJ1Y3QoKGVycikgPT4ge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhvbkNvbnN0cnVjdCwgZXJyKVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHByb2Nlc3MubmV4dFRpY2sob25Db25zdHJ1Y3QsIGVycilcbiAgfVxufVxuZnVuY3Rpb24gZW1pdENvbnN0cnVjdE5UKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdChrQ29uc3RydWN0KVxufVxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gKHN0cmVhbSA9PT0gbnVsbCB8fCBzdHJlYW0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHN0cmVhbS5zZXRIZWFkZXIpICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbidcbn1cbmZ1bmN0aW9uIGVtaXRDbG9zZUxlZ2FjeShzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcbn1cbmZ1bmN0aW9uIGVtaXRFcnJvckNsb3NlTGVnYWN5KHN0cmVhbSwgZXJyKSB7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycilcbiAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VMZWdhY3ksIHN0cmVhbSlcbn1cblxuLy8gTm9ybWFsaXplIGRlc3Ryb3kgZm9yIGxlZ2FjeS5cbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIGVycikge1xuICBpZiAoIXN0cmVhbSB8fCBpc0Rlc3Ryb3llZChzdHJlYW0pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFlcnIgJiYgIWlzRmluaXNoZWQoc3RyZWFtKSkge1xuICAgIGVyciA9IG5ldyBBYm9ydEVycm9yKClcbiAgfVxuXG4gIC8vIFRPRE86IFJlbW92ZSBpc1JlcXVlc3QgYnJhbmNoZXMuXG4gIGlmIChpc1NlcnZlclJlcXVlc3Qoc3RyZWFtKSkge1xuICAgIHN0cmVhbS5zb2NrZXQgPSBudWxsXG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9IGVsc2UgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLmFib3J0KClcbiAgfSBlbHNlIGlmIChpc1JlcXVlc3Qoc3RyZWFtLnJlcSkpIHtcbiAgICBzdHJlYW0ucmVxLmFib3J0KClcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0cmVhbS5jbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRPRE86IERvbid0IGxvc2UgZXJyP1xuICAgIHN0cmVhbS5jbG9zZSgpXG4gIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JDbG9zZUxlZ2FjeSwgc3RyZWFtLCBlcnIpXG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VMZWdhY3ksIHN0cmVhbSlcbiAgfVxuICBpZiAoIXN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICBzdHJlYW1ba0lzRGVzdHJveWVkXSA9IHRydWVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnN0cnVjdCxcbiAgZGVzdHJveWVyLFxuICBkZXN0cm95LFxuICB1bmRlc3Ryb3ksXG4gIGVycm9yT3JEZXN0cm95XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/destroy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/duplex.js":
/*!*********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/duplex.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance, this class\n// prototypically inherits from Readable, and then parasitically from\n// Writable.\n\n\n\nconst {\n  ObjectDefineProperties,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectKeys,\n  ObjectSetPrototypeOf\n} = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nmodule.exports = Duplex\nconst Readable = __webpack_require__(/*! ./readable */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/readable.js\")\nconst Writable = __webpack_require__(/*! ./writable */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/writable.js\")\nObjectSetPrototypeOf(Duplex.prototype, Readable.prototype)\nObjectSetPrototypeOf(Duplex, Readable)\n{\n  const keys = ObjectKeys(Writable.prototype)\n  // Allow the keys array to be GC'ed.\n  for (let i = 0; i < keys.length; i++) {\n    const method = keys[i]\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options)\n  Readable.call(this, options)\n  Writable.call(this, options)\n  if (options) {\n    this.allowHalfOpen = options.allowHalfOpen !== false\n    if (options.readable === false) {\n      this._readableState.readable = false\n      this._readableState.ended = true\n      this._readableState.endEmitted = true\n    }\n    if (options.writable === false) {\n      this._writableState.writable = false\n      this._writableState.ending = true\n      this._writableState.ended = true\n      this._writableState.finished = true\n    }\n  } else {\n    this.allowHalfOpen = true\n  }\n}\nObjectDefineProperties(Duplex.prototype, {\n  writable: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writable')\n  },\n  writableHighWaterMark: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableHighWaterMark')\n  },\n  writableObjectMode: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableObjectMode')\n  },\n  writableBuffer: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableBuffer')\n  },\n  writableLength: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableLength')\n  },\n  writableFinished: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableFinished')\n  },\n  writableCorked: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableCorked')\n  },\n  writableEnded: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableEnded')\n  },\n  writableNeedDrain: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableNeedDrain')\n  },\n  destroyed: {\n    __proto__: null,\n    get() {\n      if (this._readableState === undefined || this._writableState === undefined) {\n        return false\n      }\n      return this._readableState.destroyed && this._writableState.destroyed\n    },\n    set(value) {\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value\n        this._writableState.destroyed = value\n      }\n    }\n  }\n})\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nDuplex.fromWeb = function (pair, options) {\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options)\n}\nDuplex.toWeb = function (duplex) {\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex)\n}\nlet duplexify\nDuplex.from = function (body) {\n  if (!duplexify) {\n    duplexify = __webpack_require__(/*! ./duplexify */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/duplexify.js\")\n  }\n  return duplexify(body, 'body')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2R1cGxleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDcEM7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDJGQUFhO0FBQ3JDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V0aC1sb25kb24tMjAyNC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZHVwbGV4LmpzPzEzODgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBlIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGljYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBPYmplY3REZWZpbmVQcm9wZXJ0aWVzLFxuICBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIE9iamVjdEtleXMsXG4gIE9iamVjdFNldFByb3RvdHlwZU9mXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleFxuY29uc3QgUmVhZGFibGUgPSByZXF1aXJlKCcuL3JlYWRhYmxlJylcbmNvbnN0IFdyaXRhYmxlID0gcmVxdWlyZSgnLi93cml0YWJsZScpXG5PYmplY3RTZXRQcm90b3R5cGVPZihEdXBsZXgucHJvdG90eXBlLCBSZWFkYWJsZS5wcm90b3R5cGUpXG5PYmplY3RTZXRQcm90b3R5cGVPZihEdXBsZXgsIFJlYWRhYmxlKVxue1xuICBjb25zdCBrZXlzID0gT2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpXG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZXRob2QgPSBrZXlzW2ldXG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdXG4gIH1cbn1cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKVxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpXG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucylcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBvcHRpb25zLmFsbG93SGFsZk9wZW4gIT09IGZhbHNlXG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRhYmxlID0gZmFsc2VcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSB0cnVlXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlXG4gICAgfVxuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS53cml0YWJsZSA9IGZhbHNlXG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IHRydWVcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSB0cnVlXG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gdHJ1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlXG4gIH1cbn1cbk9iamVjdERlZmluZVByb3BlcnRpZXMoRHVwbGV4LnByb3RvdHlwZSwge1xuICB3cml0YWJsZToge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAuLi5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGUnKVxuICB9LFxuICB3cml0YWJsZUhpZ2hXYXRlck1hcms6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycpXG4gIH0sXG4gIHdyaXRhYmxlT2JqZWN0TW9kZToge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAuLi5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVPYmplY3RNb2RlJylcbiAgfSxcbiAgd3JpdGFibGVCdWZmZXI6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJylcbiAgfSxcbiAgd3JpdGFibGVMZW5ndGg6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJylcbiAgfSxcbiAgd3JpdGFibGVGaW5pc2hlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAuLi5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVGaW5pc2hlZCcpXG4gIH0sXG4gIHdyaXRhYmxlQ29ya2VkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUNvcmtlZCcpXG4gIH0sXG4gIHdyaXRhYmxlRW5kZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlRW5kZWQnKVxuICB9LFxuICB3cml0YWJsZU5lZWREcmFpbjoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAuLi5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVOZWVkRHJhaW4nKVxuICB9LFxuICBkZXN0cm95ZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWRcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkLlxuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlXG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXG5sZXQgd2ViU3RyZWFtc0FkYXB0ZXJzXG5cbi8vIExhenkgdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlc1xuZnVuY3Rpb24gbGF6eVdlYlN0cmVhbXMoKSB7XG4gIGlmICh3ZWJTdHJlYW1zQWRhcHRlcnMgPT09IHVuZGVmaW5lZCkgd2ViU3RyZWFtc0FkYXB0ZXJzID0ge31cbiAgcmV0dXJuIHdlYlN0cmVhbXNBZGFwdGVyc1xufVxuRHVwbGV4LmZyb21XZWIgPSBmdW5jdGlvbiAocGFpciwgb3B0aW9ucykge1xuICByZXR1cm4gbGF6eVdlYlN0cmVhbXMoKS5uZXdTdHJlYW1EdXBsZXhGcm9tUmVhZGFibGVXcml0YWJsZVBhaXIocGFpciwgb3B0aW9ucylcbn1cbkR1cGxleC50b1dlYiA9IGZ1bmN0aW9uIChkdXBsZXgpIHtcbiAgcmV0dXJuIGxhenlXZWJTdHJlYW1zKCkubmV3UmVhZGFibGVXcml0YWJsZVBhaXJGcm9tRHVwbGV4KGR1cGxleClcbn1cbmxldCBkdXBsZXhpZnlcbkR1cGxleC5mcm9tID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgaWYgKCFkdXBsZXhpZnkpIHtcbiAgICBkdXBsZXhpZnkgPSByZXF1aXJlKCcuL2R1cGxleGlmeScpXG4gIH1cbiAgcmV0dXJuIGR1cGxleGlmeShib2R5LCAnYm9keScpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/duplex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/duplexify.js":
/*!************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/duplexify.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(ssr)/./node_modules/process/index.js\")\n\n/* replacement end */\n\n;('use strict')\nconst bufferModule = __webpack_require__(/*! buffer */ \"buffer\")\nconst {\n  isReadable,\n  isWritable,\n  isIterable,\n  isNodeStream,\n  isReadableNodeStream,\n  isWritableNodeStream,\n  isDuplexNodeStream,\n  isReadableStream,\n  isWritableStream\n} = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }\n} = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\")\nconst { destroyer } = __webpack_require__(/*! ./destroy */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/duplex.js\")\nconst Readable = __webpack_require__(/*! ./readable */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/readable.js\")\nconst Writable = __webpack_require__(/*! ./writable */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/writable.js\")\nconst { createDeferredPromise } = __webpack_require__(/*! ../../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\")\nconst from = __webpack_require__(/*! ./from */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/from.js\")\nconst Blob = globalThis.Blob || bufferModule.Blob\nconst isBlob =\n  typeof Blob !== 'undefined'\n    ? function isBlob(b) {\n        return b instanceof Blob\n      }\n    : function isBlob(b) {\n        return false\n      }\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(ssr)/./node_modules/abort-controller/dist/abort-controller.js\").AbortController)\nconst { FunctionPrototypeCall } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\n\n// This is needed for pre node 17.\nclass Duplexify extends Duplex {\n  constructor(options) {\n    super(options)\n\n    // https://github.com/nodejs/node/pull/34385\n\n    if ((options === null || options === undefined ? undefined : options.readable) === false) {\n      this._readableState.readable = false\n      this._readableState.ended = true\n      this._readableState.endEmitted = true\n    }\n    if ((options === null || options === undefined ? undefined : options.writable) === false) {\n      this._writableState.writable = false\n      this._writableState.ending = true\n      this._writableState.ended = true\n      this._writableState.finished = true\n    }\n  }\n}\nmodule.exports = function duplexify(body, name) {\n  if (isDuplexNodeStream(body)) {\n    return body\n  }\n  if (isReadableNodeStream(body)) {\n    return _duplexify({\n      readable: body\n    })\n  }\n  if (isWritableNodeStream(body)) {\n    return _duplexify({\n      writable: body\n    })\n  }\n  if (isNodeStream(body)) {\n    return _duplexify({\n      writable: false,\n      readable: false\n    })\n  }\n  if (isReadableStream(body)) {\n    return _duplexify({\n      readable: Readable.fromWeb(body)\n    })\n  }\n  if (isWritableStream(body)) {\n    return _duplexify({\n      writable: Writable.fromWeb(body)\n    })\n  }\n  if (typeof body === 'function') {\n    const { value, write, final, destroy } = fromAsyncGen(body)\n    if (isIterable(value)) {\n      return from(Duplexify, value, {\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        write,\n        final,\n        destroy\n      })\n    }\n    const then = value === null || value === undefined ? undefined : value.then\n    if (typeof then === 'function') {\n      let d\n      const promise = FunctionPrototypeCall(\n        then,\n        value,\n        (val) => {\n          if (val != null) {\n            throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val)\n          }\n        },\n        (err) => {\n          destroyer(d, err)\n        }\n      )\n      return (d = new Duplexify({\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        readable: false,\n        write,\n        final(cb) {\n          final(async () => {\n            try {\n              await promise\n              process.nextTick(cb, null)\n            } catch (err) {\n              process.nextTick(cb, err)\n            }\n          })\n        },\n        destroy\n      }))\n    }\n    throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value)\n  }\n  if (isBlob(body)) {\n    return duplexify(body.arrayBuffer())\n  }\n  if (isIterable(body)) {\n    return from(Duplexify, body, {\n      // TODO (ronag): highWaterMark?\n      objectMode: true,\n      writable: false\n    })\n  }\n  if (\n    isReadableStream(body === null || body === undefined ? undefined : body.readable) &&\n    isWritableStream(body === null || body === undefined ? undefined : body.writable)\n  ) {\n    return Duplexify.fromWeb(body)\n  }\n  if (\n    typeof (body === null || body === undefined ? undefined : body.writable) === 'object' ||\n    typeof (body === null || body === undefined ? undefined : body.readable) === 'object'\n  ) {\n    const readable =\n      body !== null && body !== undefined && body.readable\n        ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable)\n          ? body === null || body === undefined\n            ? undefined\n            : body.readable\n          : duplexify(body.readable)\n        : undefined\n    const writable =\n      body !== null && body !== undefined && body.writable\n        ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable)\n          ? body === null || body === undefined\n            ? undefined\n            : body.writable\n          : duplexify(body.writable)\n        : undefined\n    return _duplexify({\n      readable,\n      writable\n    })\n  }\n  const then = body === null || body === undefined ? undefined : body.then\n  if (typeof then === 'function') {\n    let d\n    FunctionPrototypeCall(\n      then,\n      body,\n      (val) => {\n        if (val != null) {\n          d.push(val)\n        }\n        d.push(null)\n      },\n      (err) => {\n        destroyer(d, err)\n      }\n    )\n    return (d = new Duplexify({\n      objectMode: true,\n      writable: false,\n      read() {}\n    }))\n  }\n  throw new ERR_INVALID_ARG_TYPE(\n    name,\n    [\n      'Blob',\n      'ReadableStream',\n      'WritableStream',\n      'Stream',\n      'Iterable',\n      'AsyncIterable',\n      'Function',\n      '{ readable, writable } pair',\n      'Promise'\n    ],\n    body\n  )\n}\nfunction fromAsyncGen(fn) {\n  let { promise, resolve } = createDeferredPromise()\n  const ac = new AbortController()\n  const signal = ac.signal\n  const value = fn(\n    (async function* () {\n      while (true) {\n        const _promise = promise\n        promise = null\n        const { chunk, done, cb } = await _promise\n        process.nextTick(cb)\n        if (done) return\n        if (signal.aborted)\n          throw new AbortError(undefined, {\n            cause: signal.reason\n          })\n        ;({ promise, resolve } = createDeferredPromise())\n        yield chunk\n      }\n    })(),\n    {\n      signal\n    }\n  )\n  return {\n    value,\n    write(chunk, encoding, cb) {\n      const _resolve = resolve\n      resolve = null\n      _resolve({\n        chunk,\n        done: false,\n        cb\n      })\n    },\n    final(cb) {\n      const _resolve = resolve\n      resolve = null\n      _resolve({\n        done: true,\n        cb\n      })\n    },\n    destroy(err, cb) {\n      ac.abort()\n      cb(err)\n    }\n  }\n}\nfunction _duplexify(pair) {\n  const r = pair.readable && typeof pair.readable.read !== 'function' ? Readable.wrap(pair.readable) : pair.readable\n  const w = pair.writable\n  let readable = !!isReadable(r)\n  let writable = !!isWritable(w)\n  let ondrain\n  let onfinish\n  let onreadable\n  let onclose\n  let d\n  function onfinished(err) {\n    const cb = onclose\n    onclose = null\n    if (cb) {\n      cb(err)\n    } else if (err) {\n      d.destroy(err)\n    }\n  }\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplexify({\n    // TODO (ronag): highWaterMark?\n    readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),\n    writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),\n    readable,\n    writable\n  })\n  if (writable) {\n    eos(w, (err) => {\n      writable = false\n      if (err) {\n        destroyer(r, err)\n      }\n      onfinished(err)\n    })\n    d._write = function (chunk, encoding, callback) {\n      if (w.write(chunk, encoding)) {\n        callback()\n      } else {\n        ondrain = callback\n      }\n    }\n    d._final = function (callback) {\n      w.end()\n      onfinish = callback\n    }\n    w.on('drain', function () {\n      if (ondrain) {\n        const cb = ondrain\n        ondrain = null\n        cb()\n      }\n    })\n    w.on('finish', function () {\n      if (onfinish) {\n        const cb = onfinish\n        onfinish = null\n        cb()\n      }\n    })\n  }\n  if (readable) {\n    eos(r, (err) => {\n      readable = false\n      if (err) {\n        destroyer(r, err)\n      }\n      onfinished(err)\n    })\n    r.on('readable', function () {\n      if (onreadable) {\n        const cb = onreadable\n        onreadable = null\n        cb()\n      }\n    })\n    r.on('end', function () {\n      d.push(null)\n    })\n    d._read = function () {\n      while (true) {\n        const buf = r.read()\n        if (buf === null) {\n          onreadable = d._read\n          return\n        }\n        if (!d.push(buf)) {\n          return\n        }\n      }\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError()\n    }\n    onreadable = null\n    ondrain = null\n    onfinish = null\n    if (onclose === null) {\n      callback(err)\n    } else {\n      onclose = callback\n      destroyer(w, err)\n      destroyer(r, err)\n    }\n  }\n  return d\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2R1cGxleGlmeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBVTs7QUFFbEM7O0FBRUEsQ0FBQztBQUNELHFCQUFxQixtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsbUZBQVM7QUFDckIsWUFBWSxtQkFBTyxDQUFDLG1HQUFpQjtBQUNyQztBQUNBO0FBQ0EsV0FBVztBQUNYLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGtGQUFtQjtBQUMvQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHVGQUFXO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxxRkFBVTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUNyQyxRQUFRLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsOEVBQWlCO0FBQzNELGFBQWEsbUJBQU8sQ0FBQyxpRkFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0hBQTJDO0FBQ2pHLFFBQVEsd0JBQXdCLEVBQUUsbUJBQU8sQ0FBQyw0RkFBd0I7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTLEdBQUcsbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXRoLWxvbmRvbi0yMDI0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kdXBsZXhpZnkuanM/OTFhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cblxuOygndXNlIHN0cmljdCcpXG5jb25zdCBidWZmZXJNb2R1bGUgPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3Qge1xuICBpc1JlYWRhYmxlLFxuICBpc1dyaXRhYmxlLFxuICBpc0l0ZXJhYmxlLFxuICBpc05vZGVTdHJlYW0sXG4gIGlzUmVhZGFibGVOb2RlU3RyZWFtLFxuICBpc1dyaXRhYmxlTm9kZVN0cmVhbSxcbiAgaXNEdXBsZXhOb2RlU3RyZWFtLFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc1dyaXRhYmxlU3RyZWFtXG59ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKVxuY29uc3Qge1xuICBBYm9ydEVycm9yLFxuICBjb2RlczogeyBFUlJfSU5WQUxJRF9BUkdfVFlQRSwgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFIH1cbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCB7IGRlc3Ryb3llciB9ID0gcmVxdWlyZSgnLi9kZXN0cm95JylcbmNvbnN0IER1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4JylcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpXG5jb25zdCBXcml0YWJsZSA9IHJlcXVpcmUoJy4vd3JpdGFibGUnKVxuY29uc3QgeyBjcmVhdGVEZWZlcnJlZFByb21pc2UgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpXG5jb25zdCBmcm9tID0gcmVxdWlyZSgnLi9mcm9tJylcbmNvbnN0IEJsb2IgPSBnbG9iYWxUaGlzLkJsb2IgfHwgYnVmZmVyTW9kdWxlLkJsb2JcbmNvbnN0IGlzQmxvYiA9XG4gIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJ1xuICAgID8gZnVuY3Rpb24gaXNCbG9iKGIpIHtcbiAgICAgICAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCbG9iXG4gICAgICB9XG4gICAgOiBmdW5jdGlvbiBpc0Jsb2IoYikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbmNvbnN0IEFib3J0Q29udHJvbGxlciA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyIHx8IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKS5BYm9ydENvbnRyb2xsZXJcbmNvbnN0IHsgRnVuY3Rpb25Qcm90b3R5cGVDYWxsIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcblxuLy8gVGhpcyBpcyBuZWVkZWQgZm9yIHByZSBub2RlIDE3LlxuY2xhc3MgRHVwbGV4aWZ5IGV4dGVuZHMgRHVwbGV4IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpXG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zNDM4NVxuXG4gICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucmVhZGFibGUpID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy53cml0YWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLndyaXRhYmxlID0gZmFsc2VcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gdHJ1ZVxuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IHRydWVcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSB0cnVlXG4gICAgfVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGR1cGxleGlmeShib2R5LCBuYW1lKSB7XG4gIGlmIChpc0R1cGxleE5vZGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gYm9keVxuICB9XG4gIGlmIChpc1JlYWRhYmxlTm9kZVN0cmVhbShib2R5KSkge1xuICAgIHJldHVybiBfZHVwbGV4aWZ5KHtcbiAgICAgIHJlYWRhYmxlOiBib2R5XG4gICAgfSlcbiAgfVxuICBpZiAoaXNXcml0YWJsZU5vZGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICB3cml0YWJsZTogYm9keVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzTm9kZVN0cmVhbShib2R5KSkge1xuICAgIHJldHVybiBfZHVwbGV4aWZ5KHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHJlYWRhYmxlOiBmYWxzZVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzUmVhZGFibGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICByZWFkYWJsZTogUmVhZGFibGUuZnJvbVdlYihib2R5KVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzV3JpdGFibGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICB3cml0YWJsZTogV3JpdGFibGUuZnJvbVdlYihib2R5KVxuICAgIH0pXG4gIH1cbiAgaWYgKHR5cGVvZiBib2R5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgd3JpdGUsIGZpbmFsLCBkZXN0cm95IH0gPSBmcm9tQXN5bmNHZW4oYm9keSlcbiAgICBpZiAoaXNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmcm9tKER1cGxleGlmeSwgdmFsdWUsIHtcbiAgICAgICAgLy8gVE9ETyAocm9uYWcpOiBoaWdoV2F0ZXJNYXJrP1xuICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB3cml0ZSxcbiAgICAgICAgZmluYWwsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH0pXG4gICAgfVxuICAgIGNvbnN0IHRoZW4gPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdmFsdWUudGhlblxuICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGV0IGRcbiAgICAgIGNvbnN0IHByb21pc2UgPSBGdW5jdGlvblByb3RvdHlwZUNhbGwoXG4gICAgICAgIHRoZW4sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICAodmFsKSA9PiB7XG4gICAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdudWxseScsICdib2R5JywgdmFsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIGRlc3Ryb3llcihkLCBlcnIpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIHJldHVybiAoZCA9IG5ldyBEdXBsZXhpZnkoe1xuICAgICAgICAvLyBUT0RPIChyb25hZyk6IGhpZ2hXYXRlck1hcms/XG4gICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIHJlYWRhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGUsXG4gICAgICAgIGZpbmFsKGNiKSB7XG4gICAgICAgICAgZmluYWwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZVxuICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVycilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95XG4gICAgICB9KSlcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnSXRlcmFibGUsIEFzeW5jSXRlcmFibGUgb3IgQXN5bmNGdW5jdGlvbicsIG5hbWUsIHZhbHVlKVxuICB9XG4gIGlmIChpc0Jsb2IoYm9keSkpIHtcbiAgICByZXR1cm4gZHVwbGV4aWZ5KGJvZHkuYXJyYXlCdWZmZXIoKSlcbiAgfVxuICBpZiAoaXNJdGVyYWJsZShib2R5KSkge1xuICAgIHJldHVybiBmcm9tKER1cGxleGlmeSwgYm9keSwge1xuICAgICAgLy8gVE9ETyAocm9uYWcpOiBoaWdoV2F0ZXJNYXJrP1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pXG4gIH1cbiAgaWYgKFxuICAgIGlzUmVhZGFibGVTdHJlYW0oYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LnJlYWRhYmxlKSAmJlxuICAgIGlzV3JpdGFibGVTdHJlYW0oYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LndyaXRhYmxlKVxuICApIHtcbiAgICByZXR1cm4gRHVwbGV4aWZ5LmZyb21XZWIoYm9keSlcbiAgfVxuICBpZiAoXG4gICAgdHlwZW9mIChib2R5ID09PSBudWxsIHx8IGJvZHkgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGJvZHkud3JpdGFibGUpID09PSAnb2JqZWN0JyB8fFxuICAgIHR5cGVvZiAoYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LnJlYWRhYmxlKSA9PT0gJ29iamVjdCdcbiAgKSB7XG4gICAgY29uc3QgcmVhZGFibGUgPVxuICAgICAgYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB1bmRlZmluZWQgJiYgYm9keS5yZWFkYWJsZVxuICAgICAgICA/IGlzUmVhZGFibGVOb2RlU3RyZWFtKGJvZHkgPT09IG51bGwgfHwgYm9keSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYm9keS5yZWFkYWJsZSlcbiAgICAgICAgICA/IGJvZHkgPT09IG51bGwgfHwgYm9keSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBib2R5LnJlYWRhYmxlXG4gICAgICAgICAgOiBkdXBsZXhpZnkoYm9keS5yZWFkYWJsZSlcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgICBjb25zdCB3cml0YWJsZSA9XG4gICAgICBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHVuZGVmaW5lZCAmJiBib2R5LndyaXRhYmxlXG4gICAgICAgID8gaXNXcml0YWJsZU5vZGVTdHJlYW0oYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LndyaXRhYmxlKVxuICAgICAgICAgID8gYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IGJvZHkud3JpdGFibGVcbiAgICAgICAgICA6IGR1cGxleGlmeShib2R5LndyaXRhYmxlKVxuICAgICAgICA6IHVuZGVmaW5lZFxuICAgIHJldHVybiBfZHVwbGV4aWZ5KHtcbiAgICAgIHJlYWRhYmxlLFxuICAgICAgd3JpdGFibGVcbiAgICB9KVxuICB9XG4gIGNvbnN0IHRoZW4gPSBib2R5ID09PSBudWxsIHx8IGJvZHkgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGJvZHkudGhlblxuICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICBsZXQgZFxuICAgIEZ1bmN0aW9uUHJvdG90eXBlQ2FsbChcbiAgICAgIHRoZW4sXG4gICAgICBib2R5LFxuICAgICAgKHZhbCkgPT4ge1xuICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICBkLnB1c2godmFsKVxuICAgICAgICB9XG4gICAgICAgIGQucHVzaChudWxsKVxuICAgICAgfSxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgZGVzdHJveWVyKGQsIGVycilcbiAgICAgIH1cbiAgICApXG4gICAgcmV0dXJuIChkID0gbmV3IER1cGxleGlmeSh7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgcmVhZCgpIHt9XG4gICAgfSkpXG4gIH1cbiAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFxuICAgIG5hbWUsXG4gICAgW1xuICAgICAgJ0Jsb2InLFxuICAgICAgJ1JlYWRhYmxlU3RyZWFtJyxcbiAgICAgICdXcml0YWJsZVN0cmVhbScsXG4gICAgICAnU3RyZWFtJyxcbiAgICAgICdJdGVyYWJsZScsXG4gICAgICAnQXN5bmNJdGVyYWJsZScsXG4gICAgICAnRnVuY3Rpb24nLFxuICAgICAgJ3sgcmVhZGFibGUsIHdyaXRhYmxlIH0gcGFpcicsXG4gICAgICAnUHJvbWlzZSdcbiAgICBdLFxuICAgIGJvZHlcbiAgKVxufVxuZnVuY3Rpb24gZnJvbUFzeW5jR2VuKGZuKSB7XG4gIGxldCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG4gIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gIGNvbnN0IHNpZ25hbCA9IGFjLnNpZ25hbFxuICBjb25zdCB2YWx1ZSA9IGZuKFxuICAgIChhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgX3Byb21pc2UgPSBwcm9taXNlXG4gICAgICAgIHByb21pc2UgPSBudWxsXG4gICAgICAgIGNvbnN0IHsgY2h1bmssIGRvbmUsIGNiIH0gPSBhd2FpdCBfcHJvbWlzZVxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcih1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIGNhdXNlOiBzaWduYWwucmVhc29uXG4gICAgICAgICAgfSlcbiAgICAgICAgOyh7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpKVxuICAgICAgICB5aWVsZCBjaHVua1xuICAgICAgfVxuICAgIH0pKCksXG4gICAge1xuICAgICAgc2lnbmFsXG4gICAgfVxuICApXG4gIHJldHVybiB7XG4gICAgdmFsdWUsXG4gICAgd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgY29uc3QgX3Jlc29sdmUgPSByZXNvbHZlXG4gICAgICByZXNvbHZlID0gbnVsbFxuICAgICAgX3Jlc29sdmUoe1xuICAgICAgICBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIGNiXG4gICAgICB9KVxuICAgIH0sXG4gICAgZmluYWwoY2IpIHtcbiAgICAgIGNvbnN0IF9yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgcmVzb2x2ZSA9IG51bGxcbiAgICAgIF9yZXNvbHZlKHtcbiAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgY2JcbiAgICAgIH0pXG4gICAgfSxcbiAgICBkZXN0cm95KGVyciwgY2IpIHtcbiAgICAgIGFjLmFib3J0KClcbiAgICAgIGNiKGVycilcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9kdXBsZXhpZnkocGFpcikge1xuICBjb25zdCByID0gcGFpci5yZWFkYWJsZSAmJiB0eXBlb2YgcGFpci5yZWFkYWJsZS5yZWFkICE9PSAnZnVuY3Rpb24nID8gUmVhZGFibGUud3JhcChwYWlyLnJlYWRhYmxlKSA6IHBhaXIucmVhZGFibGVcbiAgY29uc3QgdyA9IHBhaXIud3JpdGFibGVcbiAgbGV0IHJlYWRhYmxlID0gISFpc1JlYWRhYmxlKHIpXG4gIGxldCB3cml0YWJsZSA9ICEhaXNXcml0YWJsZSh3KVxuICBsZXQgb25kcmFpblxuICBsZXQgb25maW5pc2hcbiAgbGV0IG9ucmVhZGFibGVcbiAgbGV0IG9uY2xvc2VcbiAgbGV0IGRcbiAgZnVuY3Rpb24gb25maW5pc2hlZChlcnIpIHtcbiAgICBjb25zdCBjYiA9IG9uY2xvc2VcbiAgICBvbmNsb3NlID0gbnVsbFxuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKVxuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBkLmRlc3Ryb3koZXJyKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE8ocm9uYWcpOiBBdm9pZCBkb3VibGUgYnVmZmVyaW5nLlxuICAvLyBJbXBsZW1lbnQgV3JpdGFibGUvUmVhZGFibGUvRHVwbGV4IHRyYWl0cy5cbiAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMzUxNS5cbiAgZCA9IG5ldyBEdXBsZXhpZnkoe1xuICAgIC8vIFRPRE8gKHJvbmFnKTogaGlnaFdhdGVyTWFyaz9cbiAgICByZWFkYWJsZU9iamVjdE1vZGU6ICEhKHIgIT09IG51bGwgJiYgciAhPT0gdW5kZWZpbmVkICYmIHIucmVhZGFibGVPYmplY3RNb2RlKSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6ICEhKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcud3JpdGFibGVPYmplY3RNb2RlKSxcbiAgICByZWFkYWJsZSxcbiAgICB3cml0YWJsZVxuICB9KVxuICBpZiAod3JpdGFibGUpIHtcbiAgICBlb3ModywgKGVycikgPT4ge1xuICAgICAgd3JpdGFibGUgPSBmYWxzZVxuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZXN0cm95ZXIociwgZXJyKVxuICAgICAgfVxuICAgICAgb25maW5pc2hlZChlcnIpXG4gICAgfSlcbiAgICBkLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAody53cml0ZShjaHVuaywgZW5jb2RpbmcpKSB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uZHJhaW4gPSBjYWxsYmFja1xuICAgICAgfVxuICAgIH1cbiAgICBkLl9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdy5lbmQoKVxuICAgICAgb25maW5pc2ggPSBjYWxsYmFja1xuICAgIH1cbiAgICB3Lm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbmRyYWluKSB7XG4gICAgICAgIGNvbnN0IGNiID0gb25kcmFpblxuICAgICAgICBvbmRyYWluID0gbnVsbFxuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfSlcbiAgICB3Lm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob25maW5pc2gpIHtcbiAgICAgICAgY29uc3QgY2IgPSBvbmZpbmlzaFxuICAgICAgICBvbmZpbmlzaCA9IG51bGxcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgaWYgKHJlYWRhYmxlKSB7XG4gICAgZW9zKHIsIChlcnIpID0+IHtcbiAgICAgIHJlYWRhYmxlID0gZmFsc2VcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZGVzdHJveWVyKHIsIGVycilcbiAgICAgIH1cbiAgICAgIG9uZmluaXNoZWQoZXJyKVxuICAgIH0pXG4gICAgci5vbigncmVhZGFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob25yZWFkYWJsZSkge1xuICAgICAgICBjb25zdCBjYiA9IG9ucmVhZGFibGVcbiAgICAgICAgb25yZWFkYWJsZSA9IG51bGxcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gICAgci5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgZC5wdXNoKG51bGwpXG4gICAgfSlcbiAgICBkLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgYnVmID0gci5yZWFkKClcbiAgICAgICAgaWYgKGJ1ZiA9PT0gbnVsbCkge1xuICAgICAgICAgIG9ucmVhZGFibGUgPSBkLl9yZWFkXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkLnB1c2goYnVmKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICghZXJyICYmIG9uY2xvc2UgIT09IG51bGwpIHtcbiAgICAgIGVyciA9IG5ldyBBYm9ydEVycm9yKClcbiAgICB9XG4gICAgb25yZWFkYWJsZSA9IG51bGxcbiAgICBvbmRyYWluID0gbnVsbFxuICAgIG9uZmluaXNoID0gbnVsbFxuICAgIGlmIChvbmNsb3NlID09PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9uY2xvc2UgPSBjYWxsYmFja1xuICAgICAgZGVzdHJveWVyKHcsIGVycilcbiAgICAgIGRlc3Ryb3llcihyLCBlcnIpXG4gICAgfVxuICB9XG4gIHJldHVybiBkXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/duplexify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(ssr)/./node_modules/process/index.js\")\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { AbortError, codes } = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\")\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes\nconst { kEmptyObject, once } = __webpack_require__(/*! ../../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\")\nconst { validateAbortSignal, validateFunction, validateObject, validateBoolean } = __webpack_require__(/*! ../validators */ \"(ssr)/./node_modules/readable-stream/lib/internal/validators.js\")\nconst { Promise, PromisePrototypeThen, SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose,\n  kIsClosedPromise\n} = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/utils.js\")\nlet addAbortListener\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function'\n}\nconst nop = () => {}\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable\n  if (arguments.length === 2) {\n    callback = options\n    options = kEmptyObject\n  } else if (options == null) {\n    options = kEmptyObject\n  } else {\n    validateObject(options, 'options')\n  }\n  validateFunction(callback, 'callback')\n  validateAbortSignal(options.signal, 'options.signal')\n  callback = once(callback)\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream, options, callback)\n  }\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  const readable =\n    (_options$readable = options.readable) !== null && _options$readable !== undefined\n      ? _options$readable\n      : isReadableNodeStream(stream)\n  const writable =\n    (_options$writable = options.writable) !== null && _options$writable !== undefined\n      ? _options$writable\n      : isWritableNodeStream(stream)\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish()\n    }\n  }\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose =\n    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable\n  let writableFinished = isWritableFinished(stream, false)\n  const onfinish = () => {\n    writableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream)\n    }\n  }\n  let readableFinished = isReadableFinished(stream, false)\n  const onend = () => {\n    readableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream)\n    }\n  }\n  const onerror = (err) => {\n    callback.call(stream, err)\n  }\n  let closed = isClosed(stream)\n  const onclose = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    callback.call(stream)\n  }\n  const onclosed = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    callback.call(stream)\n  }\n  const onrequest = () => {\n    stream.req.on('finish', onfinish)\n  }\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish)\n    if (!willEmitClose) {\n      stream.on('abort', onclose)\n    }\n    if (stream.req) {\n      onrequest()\n    } else {\n      stream.on('request', onrequest)\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish)\n    stream.on('close', onlegacyfinish)\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose)\n  }\n  stream.on('end', onend)\n  stream.on('finish', onfinish)\n  if (options.error !== false) {\n    stream.on('error', onerror)\n  }\n  stream.on('close', onclose)\n  if (closed) {\n    process.nextTick(onclose)\n  } else if (\n    (wState !== null && wState !== undefined && wState.errorEmitted) ||\n    (rState !== null && rState !== undefined && rState.errorEmitted)\n  ) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed)\n    }\n  } else if (\n    !readable &&\n    (!willEmitClose || isReadable(stream)) &&\n    (writableFinished || isWritable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (\n    !writable &&\n    (!willEmitClose || isWritable(stream)) &&\n    (readableFinished || isReadable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclosed)\n  }\n  const cleanup = () => {\n    callback = nop\n    stream.removeListener('aborted', onclose)\n    stream.removeListener('complete', onfinish)\n    stream.removeListener('abort', onclose)\n    stream.removeListener('request', onrequest)\n    if (stream.req) stream.req.removeListener('finish', onfinish)\n    stream.removeListener('end', onlegacyfinish)\n    stream.removeListener('close', onlegacyfinish)\n    stream.removeListener('finish', onfinish)\n    stream.removeListener('end', onend)\n    stream.removeListener('error', onerror)\n    stream.removeListener('close', onclose)\n  }\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback\n      cleanup()\n      endCallback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\").addAbortListener)\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  return cleanup\n}\nfunction eosWeb(stream, options, callback) {\n  let isAborted = false\n  let abort = nop\n  if (options.signal) {\n    abort = () => {\n      isAborted = true\n      callback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\").addAbortListener)\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  const resolverFn = (...args) => {\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream, args))\n    }\n  }\n  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn)\n  return nop\n}\nfunction finished(stream, opts) {\n  var _opts\n  let autoCleanup = false\n  if (opts === null) {\n    opts = kEmptyObject\n  }\n  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n    validateBoolean(opts.cleanup, 'cleanup')\n    autoCleanup = opts.cleanup\n  }\n  return new Promise((resolve, reject) => {\n    const cleanup = eos(stream, opts, (err) => {\n      if (autoCleanup) {\n        cleanup()\n      }\n      if (err) {\n        reject(err)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\nmodule.exports = eos\nmodule.exports.finished = finished\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsdURBQVU7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLGtGQUFtQjtBQUN6RCxRQUFRLG1EQUFtRDtBQUMzRCxRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsOEVBQWlCO0FBQ3hELFFBQVEseUVBQXlFLEVBQUUsbUJBQU8sQ0FBQyxzRkFBZTtBQUMxRyxRQUFRLCtDQUErQyxFQUFFLG1CQUFPLENBQUMsNEZBQXdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLG1GQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2Q0FBNkMsc0hBQTJDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2Q0FBNkMsc0hBQTJDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldGgtbG9uZG9uLTIwMjQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanM/MDdlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cbi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvZW5kLW9mLXN0cmVhbSB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cblxuOygndXNlIHN0cmljdCcpXG5jb25zdCB7IEFib3J0RXJyb3IsIGNvZGVzIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCB7IEVSUl9JTlZBTElEX0FSR19UWVBFLCBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSB9ID0gY29kZXNcbmNvbnN0IHsga0VtcHR5T2JqZWN0LCBvbmNlIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKVxuY29uc3QgeyB2YWxpZGF0ZUFib3J0U2lnbmFsLCB2YWxpZGF0ZUZ1bmN0aW9uLCB2YWxpZGF0ZU9iamVjdCwgdmFsaWRhdGVCb29sZWFuIH0gPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJylcbmNvbnN0IHsgUHJvbWlzZSwgUHJvbWlzZVByb3RvdHlwZVRoZW4sIFN5bWJvbERpc3Bvc2UgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3Qge1xuICBpc0Nsb3NlZCxcbiAgaXNSZWFkYWJsZSxcbiAgaXNSZWFkYWJsZU5vZGVTdHJlYW0sXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzUmVhZGFibGVGaW5pc2hlZCxcbiAgaXNSZWFkYWJsZUVycm9yZWQsXG4gIGlzV3JpdGFibGUsXG4gIGlzV3JpdGFibGVOb2RlU3RyZWFtLFxuICBpc1dyaXRhYmxlU3RyZWFtLFxuICBpc1dyaXRhYmxlRmluaXNoZWQsXG4gIGlzV3JpdGFibGVFcnJvcmVkLFxuICBpc05vZGVTdHJlYW0sXG4gIHdpbGxFbWl0Q2xvc2U6IF93aWxsRW1pdENsb3NlLFxuICBrSXNDbG9zZWRQcm9taXNlXG59ID0gcmVxdWlyZSgnLi91dGlscycpXG5sZXQgYWRkQWJvcnRMaXN0ZW5lclxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nXG59XG5jb25zdCBub3AgPSAoKSA9PiB7fVxuZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIF9vcHRpb25zJHJlYWRhYmxlLCBfb3B0aW9ucyR3cml0YWJsZVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBrRW1wdHlPYmplY3RcbiAgfSBlbHNlIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0ga0VtcHR5T2JqZWN0XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIHZhbGlkYXRlRnVuY3Rpb24oY2FsbGJhY2ssICdjYWxsYmFjaycpXG4gIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcbiAgaWYgKGlzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB8fCBpc1dyaXRhYmxlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gZW9zV2ViKHN0cmVhbSwgb3B0aW9ucywgY2FsbGJhY2spXG4gIH1cbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnc3RyZWFtJywgWydSZWFkYWJsZVN0cmVhbScsICdXcml0YWJsZVN0cmVhbScsICdTdHJlYW0nXSwgc3RyZWFtKVxuICB9XG4gIGNvbnN0IHJlYWRhYmxlID1cbiAgICAoX29wdGlvbnMkcmVhZGFibGUgPSBvcHRpb25zLnJlYWRhYmxlKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRyZWFkYWJsZSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IF9vcHRpb25zJHJlYWRhYmxlXG4gICAgICA6IGlzUmVhZGFibGVOb2RlU3RyZWFtKHN0cmVhbSlcbiAgY29uc3Qgd3JpdGFibGUgPVxuICAgIChfb3B0aW9ucyR3cml0YWJsZSA9IG9wdGlvbnMud3JpdGFibGUpICE9PSBudWxsICYmIF9vcHRpb25zJHdyaXRhYmxlICE9PSB1bmRlZmluZWRcbiAgICAgID8gX29wdGlvbnMkd3JpdGFibGVcbiAgICAgIDogaXNXcml0YWJsZU5vZGVTdHJlYW0oc3RyZWFtKVxuICBjb25zdCB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgY29uc3QgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IG9ubGVnYWN5ZmluaXNoID0gKCkgPT4ge1xuICAgIGlmICghc3RyZWFtLndyaXRhYmxlKSB7XG4gICAgICBvbmZpbmlzaCgpXG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETyAocm9uYWcpOiBJbXByb3ZlIHNvZnQgZGV0ZWN0aW9uIHRvIGluY2x1ZGUgY29yZSBtb2R1bGVzIGFuZFxuICAvLyBjb21tb24gZWNvc3lzdGVtIG1vZHVsZXMgdGhhdCBkbyBwcm9wZXJseSBlbWl0ICdjbG9zZScgYnV0IGZhaWxcbiAgLy8gdGhpcyBnZW5lcmljIGNoZWNrLlxuICBsZXQgd2lsbEVtaXRDbG9zZSA9XG4gICAgX3dpbGxFbWl0Q2xvc2Uoc3RyZWFtKSAmJiBpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0pID09PSByZWFkYWJsZSAmJiBpc1dyaXRhYmxlTm9kZVN0cmVhbShzdHJlYW0pID09PSB3cml0YWJsZVxuICBsZXQgd3JpdGFibGVGaW5pc2hlZCA9IGlzV3JpdGFibGVGaW5pc2hlZChzdHJlYW0sIGZhbHNlKVxuICBjb25zdCBvbmZpbmlzaCA9ICgpID0+IHtcbiAgICB3cml0YWJsZUZpbmlzaGVkID0gdHJ1ZVxuICAgIC8vIFN0cmVhbSBzaG91bGQgbm90IGJlIGRlc3Ryb3llZCBoZXJlLiBJZiBpdCBpcyB0aGF0XG4gICAgLy8gbWVhbnMgdGhhdCB1c2VyIHNwYWNlIGlzIGRvaW5nIHNvbWV0aGluZyBkaWZmZXJlbnRseSBhbmRcbiAgICAvLyB3ZSBjYW5ub3QgdHJ1c3Qgd2lsbEVtaXRDbG9zZS5cbiAgICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgICAgd2lsbEVtaXRDbG9zZSA9IGZhbHNlXG4gICAgfVxuICAgIGlmICh3aWxsRW1pdENsb3NlICYmICghc3RyZWFtLnJlYWRhYmxlIHx8IHJlYWRhYmxlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghcmVhZGFibGUgfHwgcmVhZGFibGVGaW5pc2hlZCkge1xuICAgICAgY2FsbGJhY2suY2FsbChzdHJlYW0pXG4gICAgfVxuICB9XG4gIGxldCByZWFkYWJsZUZpbmlzaGVkID0gaXNSZWFkYWJsZUZpbmlzaGVkKHN0cmVhbSwgZmFsc2UpXG4gIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgIHJlYWRhYmxlRmluaXNoZWQgPSB0cnVlXG4gICAgLy8gU3RyZWFtIHNob3VsZCBub3QgYmUgZGVzdHJveWVkIGhlcmUuIElmIGl0IGlzIHRoYXRcbiAgICAvLyBtZWFucyB0aGF0IHVzZXIgc3BhY2UgaXMgZG9pbmcgc29tZXRoaW5nIGRpZmZlcmVudGx5IGFuZFxuICAgIC8vIHdlIGNhbm5vdCB0cnVzdCB3aWxsRW1pdENsb3NlLlxuICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICB3aWxsRW1pdENsb3NlID0gZmFsc2VcbiAgICB9XG4gICAgaWYgKHdpbGxFbWl0Q2xvc2UgJiYgKCFzdHJlYW0ud3JpdGFibGUgfHwgd3JpdGFibGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCF3cml0YWJsZSB8fCB3cml0YWJsZUZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSlcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25lcnJvciA9IChlcnIpID0+IHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKVxuICB9XG4gIGxldCBjbG9zZWQgPSBpc0Nsb3NlZChzdHJlYW0pXG4gIGNvbnN0IG9uY2xvc2UgPSAoKSA9PiB7XG4gICAgY2xvc2VkID0gdHJ1ZVxuICAgIGNvbnN0IGVycm9yZWQgPSBpc1dyaXRhYmxlRXJyb3JlZChzdHJlYW0pIHx8IGlzUmVhZGFibGVFcnJvcmVkKHN0cmVhbSlcbiAgICBpZiAoZXJyb3JlZCAmJiB0eXBlb2YgZXJyb3JlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycm9yZWQpXG4gICAgfVxuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVGaW5pc2hlZCAmJiBpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0sIHRydWUpKSB7XG4gICAgICBpZiAoIWlzUmVhZGFibGVGaW5pc2hlZChzdHJlYW0sIGZhbHNlKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKSlcbiAgICB9XG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUZpbmlzaGVkKSB7XG4gICAgICBpZiAoIWlzV3JpdGFibGVGaW5pc2hlZChzdHJlYW0sIGZhbHNlKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKSlcbiAgICB9XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0pXG4gIH1cbiAgY29uc3Qgb25jbG9zZWQgPSAoKSA9PiB7XG4gICAgY2xvc2VkID0gdHJ1ZVxuICAgIGNvbnN0IGVycm9yZWQgPSBpc1dyaXRhYmxlRXJyb3JlZChzdHJlYW0pIHx8IGlzUmVhZGFibGVFcnJvcmVkKHN0cmVhbSlcbiAgICBpZiAoZXJyb3JlZCAmJiB0eXBlb2YgZXJyb3JlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycm9yZWQpXG4gICAgfVxuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtKVxuICB9XG4gIGNvbnN0IG9ucmVxdWVzdCA9ICgpID0+IHtcbiAgICBzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgfVxuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpXG4gICAgaWYgKCF3aWxsRW1pdENsb3NlKSB7XG4gICAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSlcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5yZXEpIHtcbiAgICAgIG9ucmVxdWVzdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdClcbiAgICB9XG4gIH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXdTdGF0ZSkge1xuICAgIC8vIGxlZ2FjeSBzdHJlYW1zXG4gICAgc3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaClcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpXG4gIH1cblxuICAvLyBOb3QgYWxsIHN0cmVhbXMgd2lsbCBlbWl0ICdjbG9zZScgYWZ0ZXIgJ2Fib3J0ZWQnLlxuICBpZiAoIXdpbGxFbWl0Q2xvc2UgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICBzdHJlYW0ub24oJ2Fib3J0ZWQnLCBvbmNsb3NlKVxuICB9XG4gIHN0cmVhbS5vbignZW5kJywgb25lbmQpXG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpXG4gIGlmIChvcHRpb25zLmVycm9yICE9PSBmYWxzZSkge1xuICAgIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKVxuICB9XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKVxuICBpZiAoY2xvc2VkKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhvbmNsb3NlKVxuICB9IGVsc2UgaWYgKFxuICAgICh3U3RhdGUgIT09IG51bGwgJiYgd1N0YXRlICE9PSB1bmRlZmluZWQgJiYgd1N0YXRlLmVycm9yRW1pdHRlZCkgfHxcbiAgICAoclN0YXRlICE9PSBudWxsICYmIHJTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHJTdGF0ZS5lcnJvckVtaXR0ZWQpXG4gICkge1xuICAgIGlmICghd2lsbEVtaXRDbG9zZSkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhvbmNsb3NlZClcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgIXJlYWRhYmxlICYmXG4gICAgKCF3aWxsRW1pdENsb3NlIHx8IGlzUmVhZGFibGUoc3RyZWFtKSkgJiZcbiAgICAod3JpdGFibGVGaW5pc2hlZCB8fCBpc1dyaXRhYmxlKHN0cmVhbSkgPT09IGZhbHNlKVxuICApIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG9uY2xvc2VkKVxuICB9IGVsc2UgaWYgKFxuICAgICF3cml0YWJsZSAmJlxuICAgICghd2lsbEVtaXRDbG9zZSB8fCBpc1dyaXRhYmxlKHN0cmVhbSkpICYmXG4gICAgKHJlYWRhYmxlRmluaXNoZWQgfHwgaXNSZWFkYWJsZShzdHJlYW0pID09PSBmYWxzZSlcbiAgKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhvbmNsb3NlZClcbiAgfSBlbHNlIGlmIChyU3RhdGUgJiYgc3RyZWFtLnJlcSAmJiBzdHJlYW0uYWJvcnRlZCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2sob25jbG9zZWQpXG4gIH1cbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICBjYWxsYmFjayA9IG5vcFxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnRlZCcsIG9uY2xvc2UpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdClcbiAgICBpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaClcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKVxuICB9XG4gIGlmIChvcHRpb25zLnNpZ25hbCAmJiAhY2xvc2VkKSB7XG4gICAgY29uc3QgYWJvcnQgPSAoKSA9PiB7XG4gICAgICAvLyBLZWVwIGl0IGJlY2F1c2UgY2xlYW51cCByZW1vdmVzIGl0LlxuICAgICAgY29uc3QgZW5kQ2FsbGJhY2sgPSBjYWxsYmFja1xuICAgICAgY2xlYW51cCgpXG4gICAgICBlbmRDYWxsYmFjay5jYWxsKFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIG5ldyBBYm9ydEVycm9yKHVuZGVmaW5lZCwge1xuICAgICAgICAgIGNhdXNlOiBvcHRpb25zLnNpZ25hbC5yZWFzb25cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWJvcnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZEFib3J0TGlzdGVuZXIgPSBhZGRBYm9ydExpc3RlbmVyIHx8IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpLmFkZEFib3J0TGlzdGVuZXJcbiAgICAgIGNvbnN0IGRpc3Bvc2FibGUgPSBhZGRBYm9ydExpc3RlbmVyKG9wdGlvbnMuc2lnbmFsLCBhYm9ydClcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFja1xuICAgICAgY2FsbGJhY2sgPSBvbmNlKCguLi5hcmdzKSA9PiB7XG4gICAgICAgIGRpc3Bvc2FibGVbU3ltYm9sRGlzcG9zZV0oKVxuICAgICAgICBvcmlnaW5hbENhbGxiYWNrLmFwcGx5KHN0cmVhbSwgYXJncylcbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIHJldHVybiBjbGVhbnVwXG59XG5mdW5jdGlvbiBlb3NXZWIoc3RyZWFtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBsZXQgaXNBYm9ydGVkID0gZmFsc2VcbiAgbGV0IGFib3J0ID0gbm9wXG4gIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgIGFib3J0ID0gKCkgPT4ge1xuICAgICAgaXNBYm9ydGVkID0gdHJ1ZVxuICAgICAgY2FsbGJhY2suY2FsbChcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBuZXcgQWJvcnRFcnJvcih1bmRlZmluZWQsIHtcbiAgICAgICAgICBjYXVzZTogb3B0aW9ucy5zaWduYWwucmVhc29uXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFib3J0KVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRBYm9ydExpc3RlbmVyID0gYWRkQWJvcnRMaXN0ZW5lciB8fCByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKS5hZGRBYm9ydExpc3RlbmVyXG4gICAgICBjb25zdCBkaXNwb3NhYmxlID0gYWRkQWJvcnRMaXN0ZW5lcihvcHRpb25zLnNpZ25hbCwgYWJvcnQpXG4gICAgICBjb25zdCBvcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gb25jZSgoLi4uYXJncykgPT4ge1xuICAgICAgICBkaXNwb3NhYmxlW1N5bWJvbERpc3Bvc2VdKClcbiAgICAgICAgb3JpZ2luYWxDYWxsYmFjay5hcHBseShzdHJlYW0sIGFyZ3MpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBjb25zdCByZXNvbHZlckZuID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoIWlzQWJvcnRlZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiBjYWxsYmFjay5hcHBseShzdHJlYW0sIGFyZ3MpKVxuICAgIH1cbiAgfVxuICBQcm9taXNlUHJvdG90eXBlVGhlbihzdHJlYW1ba0lzQ2xvc2VkUHJvbWlzZV0ucHJvbWlzZSwgcmVzb2x2ZXJGbiwgcmVzb2x2ZXJGbilcbiAgcmV0dXJuIG5vcFxufVxuZnVuY3Rpb24gZmluaXNoZWQoc3RyZWFtLCBvcHRzKSB7XG4gIHZhciBfb3B0c1xuICBsZXQgYXV0b0NsZWFudXAgPSBmYWxzZVxuICBpZiAob3B0cyA9PT0gbnVsbCkge1xuICAgIG9wdHMgPSBrRW1wdHlPYmplY3RcbiAgfVxuICBpZiAoKF9vcHRzID0gb3B0cykgIT09IG51bGwgJiYgX29wdHMgIT09IHVuZGVmaW5lZCAmJiBfb3B0cy5jbGVhbnVwKSB7XG4gICAgdmFsaWRhdGVCb29sZWFuKG9wdHMuY2xlYW51cCwgJ2NsZWFudXAnKVxuICAgIGF1dG9DbGVhbnVwID0gb3B0cy5jbGVhbnVwXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwID0gZW9zKHN0cmVhbSwgb3B0cywgKGVycikgPT4ge1xuICAgICAgaWYgKGF1dG9DbGVhbnVwKSB7XG4gICAgICAgIGNsZWFudXAoKVxuICAgICAgfVxuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cbm1vZHVsZS5leHBvcnRzID0gZW9zXG5tb2R1bGUuZXhwb3J0cy5maW5pc2hlZCA9IGZpbmlzaGVkXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/from.js":
/*!*******************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/from.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(ssr)/./node_modules/process/index.js\")\n\n/* replacement end */\n\nconst { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = (__webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\").codes)\nfunction from(Readable, iterable, opts) {\n  let iterator\n  if (typeof iterable === 'string' || iterable instanceof Buffer) {\n    return new Readable({\n      objectMode: true,\n      ...opts,\n      read() {\n        this.push(iterable)\n        this.push(null)\n      }\n    })\n  }\n  let isAsync\n  if (iterable && iterable[SymbolAsyncIterator]) {\n    isAsync = true\n    iterator = iterable[SymbolAsyncIterator]()\n  } else if (iterable && iterable[SymbolIterator]) {\n    isAsync = false\n    iterator = iterable[SymbolIterator]()\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable)\n  }\n  const readable = new Readable({\n    objectMode: true,\n    highWaterMark: 1,\n    // TODO(ronag): What options should be allowed?\n    ...opts\n  })\n\n  // Flag to protect against _read\n  // being called before last iteration completion.\n  let reading = false\n  readable._read = function () {\n    if (!reading) {\n      reading = true\n      next()\n    }\n  }\n  readable._destroy = function (error, cb) {\n    PromisePrototypeThen(\n      close(error),\n      () => process.nextTick(cb, error),\n      // nextTick is here in case cb throws\n      (e) => process.nextTick(cb, e || error)\n    )\n  }\n  async function close(error) {\n    const hadError = error !== undefined && error !== null\n    const hasThrow = typeof iterator.throw === 'function'\n    if (hadError && hasThrow) {\n      const { value, done } = await iterator.throw(error)\n      await value\n      if (done) {\n        return\n      }\n    }\n    if (typeof iterator.return === 'function') {\n      const { value } = await iterator.return()\n      await value\n    }\n  }\n  async function next() {\n    for (;;) {\n      try {\n        const { value, done } = isAsync ? await iterator.next() : iterator.next()\n        if (done) {\n          readable.push(null)\n        } else {\n          const res = value && typeof value.then === 'function' ? await value : value\n          if (res === null) {\n            reading = false\n            throw new ERR_STREAM_NULL_VALUES()\n          } else if (readable.push(res)) {\n            continue\n          } else {\n            reading = false\n          }\n        }\n      } catch (err) {\n        readable.destroy(err)\n      }\n      break\n    }\n  }\n  return readable\n}\nmodule.exports = from\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsdURBQVU7O0FBRWxDOztBQUVBLFFBQVEsNERBQTRELEVBQUUsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDdEcsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxRQUFRLCtDQUErQyxFQUFFLCtHQUFrQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXRoLWxvbmRvbi0yMDI0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLmpzP2QwZTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qIHJlcGxhY2VtZW50IHN0YXJ0ICovXG5cbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzLycpXG5cbi8qIHJlcGxhY2VtZW50IGVuZCAqL1xuXG5jb25zdCB7IFByb21pc2VQcm90b3R5cGVUaGVuLCBTeW1ib2xBc3luY0l0ZXJhdG9yLCBTeW1ib2xJdGVyYXRvciB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgRVJSX0lOVkFMSURfQVJHX1RZUEUsIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJykuY29kZXNcbmZ1bmN0aW9uIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKSB7XG4gIGxldCBpdGVyYXRvclxuICBpZiAodHlwZW9mIGl0ZXJhYmxlID09PSAnc3RyaW5nJyB8fCBpdGVyYWJsZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgUmVhZGFibGUoe1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgIC4uLm9wdHMsXG4gICAgICByZWFkKCkge1xuICAgICAgICB0aGlzLnB1c2goaXRlcmFibGUpXG4gICAgICAgIHRoaXMucHVzaChudWxsKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgbGV0IGlzQXN5bmNcbiAgaWYgKGl0ZXJhYmxlICYmIGl0ZXJhYmxlW1N5bWJvbEFzeW5jSXRlcmF0b3JdKSB7XG4gICAgaXNBc3luYyA9IHRydWVcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbEFzeW5jSXRlcmF0b3JdKClcbiAgfSBlbHNlIGlmIChpdGVyYWJsZSAmJiBpdGVyYWJsZVtTeW1ib2xJdGVyYXRvcl0pIHtcbiAgICBpc0FzeW5jID0gZmFsc2VcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbEl0ZXJhdG9yXSgpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdpdGVyYWJsZScsIFsnSXRlcmFibGUnXSwgaXRlcmFibGUpXG4gIH1cbiAgY29uc3QgcmVhZGFibGUgPSBuZXcgUmVhZGFibGUoe1xuICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgaGlnaFdhdGVyTWFyazogMSxcbiAgICAvLyBUT0RPKHJvbmFnKTogV2hhdCBvcHRpb25zIHNob3VsZCBiZSBhbGxvd2VkP1xuICAgIC4uLm9wdHNcbiAgfSlcblxuICAvLyBGbGFnIHRvIHByb3RlY3QgYWdhaW5zdCBfcmVhZFxuICAvLyBiZWluZyBjYWxsZWQgYmVmb3JlIGxhc3QgaXRlcmF0aW9uIGNvbXBsZXRpb24uXG4gIGxldCByZWFkaW5nID0gZmFsc2VcbiAgcmVhZGFibGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFyZWFkaW5nKSB7XG4gICAgICByZWFkaW5nID0gdHJ1ZVxuICAgICAgbmV4dCgpXG4gICAgfVxuICB9XG4gIHJlYWRhYmxlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVycm9yLCBjYikge1xuICAgIFByb21pc2VQcm90b3R5cGVUaGVuKFxuICAgICAgY2xvc2UoZXJyb3IpLFxuICAgICAgKCkgPT4gcHJvY2Vzcy5uZXh0VGljayhjYiwgZXJyb3IpLFxuICAgICAgLy8gbmV4dFRpY2sgaXMgaGVyZSBpbiBjYXNlIGNiIHRocm93c1xuICAgICAgKGUpID0+IHByb2Nlc3MubmV4dFRpY2soY2IsIGUgfHwgZXJyb3IpXG4gICAgKVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNsb3NlKGVycm9yKSB7XG4gICAgY29uc3QgaGFkRXJyb3IgPSBlcnJvciAhPT0gdW5kZWZpbmVkICYmIGVycm9yICE9PSBudWxsXG4gICAgY29uc3QgaGFzVGhyb3cgPSB0eXBlb2YgaXRlcmF0b3IudGhyb3cgPT09ICdmdW5jdGlvbidcbiAgICBpZiAoaGFkRXJyb3IgJiYgaGFzVGhyb3cpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ZXJhdG9yLnRocm93KGVycm9yKVxuICAgICAgYXdhaXQgdmFsdWVcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgaXRlcmF0b3IucmV0dXJuKClcbiAgICAgIGF3YWl0IHZhbHVlXG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaXNBc3luYyA/IGF3YWl0IGl0ZXJhdG9yLm5leHQoKSA6IGl0ZXJhdG9yLm5leHQoKVxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHJlYWRhYmxlLnB1c2gobnVsbClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByZXMgPSB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/IGF3YWl0IHZhbHVlIDogdmFsdWVcbiAgICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkaW5nID0gZmFsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKClcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlYWRhYmxlLnB1c2gocmVzKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVhZGFibGUuZGVzdHJveShlcnIpXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVhZGFibGVcbn1cbm1vZHVsZS5leHBvcnRzID0gZnJvbVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/from.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/legacy.js":
/*!*********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/legacy.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { ArrayIsArray, ObjectSetPrototypeOf } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst { EventEmitter: EE } = __webpack_require__(/*! events */ \"events\")\nfunction Stream(opts) {\n  EE.call(this, opts)\n}\nObjectSetPrototypeOf(Stream.prototype, EE.prototype)\nObjectSetPrototypeOf(Stream, EE)\nStream.prototype.pipe = function (dest, options) {\n  const source = this\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause()\n    }\n  }\n  source.on('data', ondata)\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume()\n    }\n  }\n  dest.on('drain', ondrain)\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend)\n    source.on('close', onclose)\n  }\n  let didOnEnd = false\n  function onend() {\n    if (didOnEnd) return\n    didOnEnd = true\n    dest.end()\n  }\n  function onclose() {\n    if (didOnEnd) return\n    didOnEnd = true\n    if (typeof dest.destroy === 'function') dest.destroy()\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup()\n    if (EE.listenerCount(this, 'error') === 0) {\n      this.emit('error', er)\n    }\n  }\n  prependListener(source, 'error', onerror)\n  prependListener(dest, 'error', onerror)\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata)\n    dest.removeListener('drain', ondrain)\n    source.removeListener('end', onend)\n    source.removeListener('close', onclose)\n    source.removeListener('error', onerror)\n    dest.removeListener('error', onerror)\n    source.removeListener('end', cleanup)\n    source.removeListener('close', cleanup)\n    dest.removeListener('close', cleanup)\n  }\n  source.on('end', cleanup)\n  source.on('close', cleanup)\n  dest.on('close', cleanup)\n  dest.emit('pipe', source)\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest\n}\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn)\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn)\n  else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn)\n  else emitter._events[event] = [fn, emitter._events[event]]\n}\nmodule.exports = {\n  Stream,\n  prependListener\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2xlZ2FjeS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHFDQUFxQyxFQUFFLG1CQUFPLENBQUMsNEZBQXdCO0FBQy9FLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldGgtbG9uZG9uLTIwMjQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2xlZ2FjeS5qcz9kMmI3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEFycmF5SXNBcnJheSwgT2JqZWN0U2V0UHJvdG90eXBlT2YgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgeyBFdmVudEVtaXR0ZXI6IEVFIH0gPSByZXF1aXJlKCdldmVudHMnKVxuZnVuY3Rpb24gU3RyZWFtKG9wdHMpIHtcbiAgRUUuY2FsbCh0aGlzLCBvcHRzKVxufVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoU3RyZWFtLnByb3RvdHlwZSwgRUUucHJvdG90eXBlKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoU3RyZWFtLCBFRSlcblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHRoaXNcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUgJiYgZGVzdC53cml0ZShjaHVuaykgPT09IGZhbHNlICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgc291cmNlLnBhdXNlKClcbiAgICB9XG4gIH1cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKVxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpXG4gICAgfVxuICB9XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbilcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKVxuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKVxuICB9XG4gIGxldCBkaWRPbkVuZCA9IGZhbHNlXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuXG4gICAgZGlkT25FbmQgPSB0cnVlXG4gICAgZGVzdC5lbmQoKVxuICB9XG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm5cbiAgICBkaWRPbkVuZCA9IHRydWVcbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KClcbiAgfVxuXG4gIC8vIERvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKVxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgfVxuICB9XG4gIHByZXBlbmRMaXN0ZW5lcihzb3VyY2UsICdlcnJvcicsIG9uZXJyb3IpXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKVxuXG4gIC8vIFJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKVxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbilcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKVxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKVxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcilcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKVxuICB9XG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cClcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cClcbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKVxuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0XG59XG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKVxuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pXG4gIGVsc2UgaWYgKEFycmF5SXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKVxuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dXG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU3RyZWFtLFxuICBwcmVwZW5kTGlzdGVuZXJcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/legacy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/operators.js":
/*!************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/operators.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(ssr)/./node_modules/abort-controller/dist/abort-controller.js\").AbortController)\nconst {\n  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n  AbortError\n} = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\")\nconst { validateAbortSignal, validateInteger, validateObject } = __webpack_require__(/*! ../validators */ \"(ssr)/./node_modules/readable-stream/lib/internal/validators.js\")\nconst kWeakHandler = (__webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\").Symbol)('kWeak')\nconst kResistStopPropagation = (__webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\").Symbol)('kResistStopPropagation')\nconst { finished } = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nconst staticCompose = __webpack_require__(/*! ./compose */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/compose.js\")\nconst { addAbortSignalNoValidate } = __webpack_require__(/*! ./add-abort-signal */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\")\nconst { isWritable, isNodeStream } = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst { deprecate } = __webpack_require__(/*! ../../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\")\nconst {\n  ArrayPrototypePush,\n  Boolean,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  PromisePrototypeThen,\n  Symbol\n} = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst kEmpty = Symbol('kEmpty')\nconst kEof = Symbol('kEof')\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')\n  }\n  const composedStream = staticCompose(this, stream)\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream)\n  }\n  return composedStream\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let concurrency = 1\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency)\n  }\n  let highWaterMark = concurrency - 1\n  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {\n    highWaterMark = MathFloor(options.highWaterMark)\n  }\n  validateInteger(concurrency, 'options.concurrency', 1)\n  validateInteger(highWaterMark, 'options.highWaterMark', 0)\n  highWaterMark += concurrency\n  return async function* map() {\n    const signal = (__webpack_require__(/*! ../../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\").AbortSignalAny)(\n      [options === null || options === undefined ? undefined : options.signal].filter(Boolean)\n    )\n    const stream = this\n    const queue = []\n    const signalOpt = {\n      signal\n    }\n    let next\n    let resume\n    let done = false\n    let cnt = 0\n    function onCatch() {\n      done = true\n      afterItemProcessed()\n    }\n    function afterItemProcessed() {\n      cnt -= 1\n      maybeResume()\n    }\n    function maybeResume() {\n      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n        resume()\n        resume = null\n      }\n    }\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          if (done) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          try {\n            val = fn(val, signalOpt)\n            if (val === kEmpty) {\n              continue\n            }\n            val = PromiseResolve(val)\n          } catch (err) {\n            val = PromiseReject(err)\n          }\n          cnt += 1\n          PromisePrototypeThen(val, afterItemProcessed, onCatch)\n          queue.push(val)\n          if (next) {\n            next()\n            next = null\n          }\n          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n            await new Promise((resolve) => {\n              resume = resolve\n            })\n          }\n        }\n        queue.push(kEof)\n      } catch (err) {\n        const val = PromiseReject(err)\n        PromisePrototypeThen(val, afterItemProcessed, onCatch)\n        queue.push(val)\n      } finally {\n        done = true\n        if (next) {\n          next()\n          next = null\n        }\n      }\n    }\n    pump()\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0]\n          if (val === kEof) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          if (val !== kEmpty) {\n            yield val\n          }\n          queue.shift()\n          maybeResume()\n        }\n        await new Promise((resolve) => {\n          next = resolve\n        })\n      }\n    } finally {\n      done = true\n      if (resume) {\n        resume()\n        resume = null\n      }\n    }\n  }.call(this)\n}\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  return async function* asIndexedPairs() {\n    let index = 0\n    for await (const val of this) {\n      var _options$signal\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal = options.signal) !== null &&\n        _options$signal !== undefined &&\n        _options$signal.aborted\n      ) {\n        throw new AbortError({\n          cause: options.signal.reason\n        })\n      }\n      yield [index++, val]\n    }\n  }.call(this)\n}\nasync function some(fn, options = undefined) {\n  for await (const unused of filter.call(this, fn, options)) {\n    return true\n  }\n  return false\n}\nasync function every(fn, options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(\n    this,\n    async (...args) => {\n      return !(await fn(...args))\n    },\n    options\n  ))\n}\nasync function find(fn, options) {\n  for await (const result of filter.call(this, fn, options)) {\n    return result\n  }\n  return undefined\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options)\n    return kEmpty\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value\n    }\n    return kEmpty\n  }\n  return map.call(this, filterFn, options)\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce')\n    this.message = 'Reduce of an empty stream requires an initial value'\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal2\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let hasInitialValue = arguments.length > 1\n  if (\n    options !== null &&\n    options !== undefined &&\n    (_options$signal2 = options.signal) !== null &&\n    _options$signal2 !== undefined &&\n    _options$signal2.aborted\n  ) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    })\n    this.once('error', () => {}) // The error is already propagated\n    await finished(this.destroy(err))\n    throw err\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this,\n      [kResistStopPropagation]: true\n    }\n    options.signal.addEventListener('abort', () => ac.abort(), opts)\n  }\n  let gotAnyItemFromStream = false\n  try {\n    for await (const value of this) {\n      var _options$signal3\n      gotAnyItemFromStream = true\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal3 = options.signal) !== null &&\n        _options$signal3 !== undefined &&\n        _options$signal3.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (!hasInitialValue) {\n        initialValue = value\n        hasInitialValue = true\n      } else {\n        initialValue = await reducer(initialValue, value, {\n          signal\n        })\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs()\n    }\n  } finally {\n    ac.abort()\n  }\n  return initialValue\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  const result = []\n  for await (const val of this) {\n    var _options$signal4\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal4 = options.signal) !== null &&\n      _options$signal4 !== undefined &&\n      _options$signal4.aborted\n    ) {\n      throw new AbortError(undefined, {\n        cause: options.signal.reason\n      })\n    }\n    ArrayPrototypePush(result, val)\n  }\n  return result\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options)\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val\n    }\n  }.call(this)\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number)\n  if (NumberIsNaN(number)) {\n    return 0\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)\n  }\n  return number\n}\nfunction drop(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* drop() {\n    var _options$signal5\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal5 = options.signal) !== null &&\n      _options$signal5 !== undefined &&\n      _options$signal5.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal6\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal6 = options.signal) !== null &&\n        _options$signal6 !== undefined &&\n        _options$signal6.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- <= 0) {\n        yield val\n      }\n    }\n  }.call(this)\n}\nfunction take(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* take() {\n    var _options$signal7\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal7 = options.signal) !== null &&\n      _options$signal7 !== undefined &&\n      _options$signal7.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal8\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal8 = options.signal) !== null &&\n        _options$signal8 !== undefined &&\n        _options$signal8.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- > 0) {\n        yield val\n      }\n\n      // Don't get another item from iterator in case we reached the end\n      if (number <= 0) {\n        return\n      }\n    }\n  }.call(this)\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n}\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL29wZXJhdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixzREFBc0QsK0hBQTJDO0FBQ2pHO0FBQ0EsV0FBVyxpRkFBaUY7QUFDNUY7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDL0IsUUFBUSx1REFBdUQsRUFBRSxtQkFBTyxDQUFDLHNGQUFlO0FBQ3hGLHFCQUFxQiwwSEFBd0M7QUFDN0QsK0JBQStCLDBIQUF3QztBQUN2RSxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1HQUFpQjtBQUM5QyxzQkFBc0IsbUJBQU8sQ0FBQyx1RkFBVztBQUN6QyxRQUFRLDJCQUEyQixFQUFFLG1CQUFPLENBQUMseUdBQW9CO0FBQ2pFLFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxtRkFBUztBQUN0RCxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLDhFQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEZBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0hBQXlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V0aC1sb25kb24tMjAyNC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvb3BlcmF0b3JzLmpzPzU0ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEFib3J0Q29udHJvbGxlciA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyIHx8IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKS5BYm9ydENvbnRyb2xsZXJcbmNvbnN0IHtcbiAgY29kZXM6IHsgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSwgRVJSX01JU1NJTkdfQVJHUywgRVJSX09VVF9PRl9SQU5HRSB9LFxuICBBYm9ydEVycm9yXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKVxuY29uc3QgeyB2YWxpZGF0ZUFib3J0U2lnbmFsLCB2YWxpZGF0ZUludGVnZXIsIHZhbGlkYXRlT2JqZWN0IH0gPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJylcbmNvbnN0IGtXZWFrSGFuZGxlciA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKS5TeW1ib2woJ2tXZWFrJylcbmNvbnN0IGtSZXNpc3RTdG9wUHJvcGFnYXRpb24gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJykuU3ltYm9sKCdrUmVzaXN0U3RvcFByb3BhZ2F0aW9uJylcbmNvbnN0IHsgZmluaXNoZWQgfSA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpXG5jb25zdCBzdGF0aWNDb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJylcbmNvbnN0IHsgYWRkQWJvcnRTaWduYWxOb1ZhbGlkYXRlIH0gPSByZXF1aXJlKCcuL2FkZC1hYm9ydC1zaWduYWwnKVxuY29uc3QgeyBpc1dyaXRhYmxlLCBpc05vZGVTdHJlYW0gfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgeyBkZXByZWNhdGUgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpXG5jb25zdCB7XG4gIEFycmF5UHJvdG90eXBlUHVzaCxcbiAgQm9vbGVhbixcbiAgTWF0aEZsb29yLFxuICBOdW1iZXIsXG4gIE51bWJlcklzTmFOLFxuICBQcm9taXNlLFxuICBQcm9taXNlUmVqZWN0LFxuICBQcm9taXNlUmVzb2x2ZSxcbiAgUHJvbWlzZVByb3RvdHlwZVRoZW4sXG4gIFN5bWJvbFxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3Qga0VtcHR5ID0gU3ltYm9sKCdrRW1wdHknKVxuY29uc3Qga0VvZiA9IFN5bWJvbCgna0VvZicpXG5mdW5jdGlvbiBjb21wb3NlKHN0cmVhbSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnNpZ25hbCkgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIH1cbiAgaWYgKGlzTm9kZVN0cmVhbShzdHJlYW0pICYmICFpc1dyaXRhYmxlKHN0cmVhbSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKCdzdHJlYW0nLCBzdHJlYW0sICdtdXN0IGJlIHdyaXRhYmxlJylcbiAgfVxuICBjb25zdCBjb21wb3NlZFN0cmVhbSA9IHN0YXRpY0NvbXBvc2UodGhpcywgc3RyZWFtKVxuICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5zaWduYWwpIHtcbiAgICAvLyBOb3QgdmFsaWRhdGluZyBhcyB3ZSBhbHJlYWR5IHZhbGlkYXRlZCBiZWZvcmVcbiAgICBhZGRBYm9ydFNpZ25hbE5vVmFsaWRhdGUob3B0aW9ucy5zaWduYWwsIGNvbXBvc2VkU3RyZWFtKVxuICB9XG4gIHJldHVybiBjb21wb3NlZFN0cmVhbVxufVxuZnVuY3Rpb24gbWFwKGZuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgWydGdW5jdGlvbicsICdBc3luY0Z1bmN0aW9uJ10sIGZuKVxuICB9XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgfVxuICBsZXQgY29uY3VycmVuY3kgPSAxXG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLmNvbmN1cnJlbmN5KSAhPSBudWxsKSB7XG4gICAgY29uY3VycmVuY3kgPSBNYXRoRmxvb3Iob3B0aW9ucy5jb25jdXJyZW5jeSlcbiAgfVxuICBsZXQgaGlnaFdhdGVyTWFyayA9IGNvbmN1cnJlbmN5IC0gMVxuICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oaWdoV2F0ZXJNYXJrKSAhPSBudWxsKSB7XG4gICAgaGlnaFdhdGVyTWFyayA9IE1hdGhGbG9vcihvcHRpb25zLmhpZ2hXYXRlck1hcmspXG4gIH1cbiAgdmFsaWRhdGVJbnRlZ2VyKGNvbmN1cnJlbmN5LCAnb3B0aW9ucy5jb25jdXJyZW5jeScsIDEpXG4gIHZhbGlkYXRlSW50ZWdlcihoaWdoV2F0ZXJNYXJrLCAnb3B0aW9ucy5oaWdoV2F0ZXJNYXJrJywgMClcbiAgaGlnaFdhdGVyTWFyayArPSBjb25jdXJyZW5jeVxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24qIG1hcCgpIHtcbiAgICBjb25zdCBzaWduYWwgPSByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKS5BYm9ydFNpZ25hbEFueShcbiAgICAgIFtvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsXS5maWx0ZXIoQm9vbGVhbilcbiAgICApXG4gICAgY29uc3Qgc3RyZWFtID0gdGhpc1xuICAgIGNvbnN0IHF1ZXVlID0gW11cbiAgICBjb25zdCBzaWduYWxPcHQgPSB7XG4gICAgICBzaWduYWxcbiAgICB9XG4gICAgbGV0IG5leHRcbiAgICBsZXQgcmVzdW1lXG4gICAgbGV0IGRvbmUgPSBmYWxzZVxuICAgIGxldCBjbnQgPSAwXG4gICAgZnVuY3Rpb24gb25DYXRjaCgpIHtcbiAgICAgIGRvbmUgPSB0cnVlXG4gICAgICBhZnRlckl0ZW1Qcm9jZXNzZWQoKVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZnRlckl0ZW1Qcm9jZXNzZWQoKSB7XG4gICAgICBjbnQgLT0gMVxuICAgICAgbWF5YmVSZXN1bWUoKVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXliZVJlc3VtZSgpIHtcbiAgICAgIGlmIChyZXN1bWUgJiYgIWRvbmUgJiYgY250IDwgY29uY3VycmVuY3kgJiYgcXVldWUubGVuZ3RoIDwgaGlnaFdhdGVyTWFyaykge1xuICAgICAgICByZXN1bWUoKVxuICAgICAgICByZXN1bWUgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGxldCB2YWwgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKClcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbCA9IGZuKHZhbCwgc2lnbmFsT3B0KVxuICAgICAgICAgICAgaWYgKHZhbCA9PT0ga0VtcHR5KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWwgPSBQcm9taXNlUmVzb2x2ZSh2YWwpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB2YWwgPSBQcm9taXNlUmVqZWN0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgY250ICs9IDFcbiAgICAgICAgICBQcm9taXNlUHJvdG90eXBlVGhlbih2YWwsIGFmdGVySXRlbVByb2Nlc3NlZCwgb25DYXRjaClcbiAgICAgICAgICBxdWV1ZS5wdXNoKHZhbClcbiAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgbmV4dCgpXG4gICAgICAgICAgICBuZXh0ID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRvbmUgJiYgKHF1ZXVlLmxlbmd0aCA+PSBoaWdoV2F0ZXJNYXJrIHx8IGNudCA+PSBjb25jdXJyZW5jeSkpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIHJlc3VtZSA9IHJlc29sdmVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnB1c2goa0VvZilcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCB2YWwgPSBQcm9taXNlUmVqZWN0KGVycilcbiAgICAgICAgUHJvbWlzZVByb3RvdHlwZVRoZW4odmFsLCBhZnRlckl0ZW1Qcm9jZXNzZWQsIG9uQ2F0Y2gpXG4gICAgICAgIHF1ZXVlLnB1c2godmFsKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZG9uZSA9IHRydWVcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBuZXh0KClcbiAgICAgICAgICBuZXh0ID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHB1bXAoKVxuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IGF3YWl0IHF1ZXVlWzBdXG4gICAgICAgICAgaWYgKHZhbCA9PT0ga0VvZikge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsICE9PSBrRW1wdHkpIHtcbiAgICAgICAgICAgIHlpZWxkIHZhbFxuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZS5zaGlmdCgpXG4gICAgICAgICAgbWF5YmVSZXN1bWUoKVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgbmV4dCA9IHJlc29sdmVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSA9IHRydWVcbiAgICAgIGlmIChyZXN1bWUpIHtcbiAgICAgICAgcmVzdW1lKClcbiAgICAgICAgcmVzdW1lID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfS5jYWxsKHRoaXMpXG59XG5mdW5jdGlvbiBhc0luZGV4ZWRQYWlycyhvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgfVxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24qIGFzSW5kZXhlZFBhaXJzKCkge1xuICAgIGxldCBpbmRleCA9IDBcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiB0aGlzKSB7XG4gICAgICB2YXIgX29wdGlvbnMkc2lnbmFsXG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMgIT09IG51bGwgJiZcbiAgICAgICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChfb3B0aW9ucyRzaWduYWwgPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsLmFib3J0ZWRcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcih7XG4gICAgICAgICAgY2F1c2U6IG9wdGlvbnMuc2lnbmFsLnJlYXNvblxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgeWllbGQgW2luZGV4KyssIHZhbF1cbiAgICB9XG4gIH0uY2FsbCh0aGlzKVxufVxuYXN5bmMgZnVuY3Rpb24gc29tZShmbiwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICBmb3IgYXdhaXQgKGNvbnN0IHVudXNlZCBvZiBmaWx0ZXIuY2FsbCh0aGlzLCBmbiwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuYXN5bmMgZnVuY3Rpb24gZXZlcnkoZm4sIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCBbJ0Z1bmN0aW9uJywgJ0FzeW5jRnVuY3Rpb24nXSwgZm4pXG4gIH1cbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVfTW9yZ2FuJTI3c19sYXdzXG4gIHJldHVybiAhKGF3YWl0IHNvbWUuY2FsbChcbiAgICB0aGlzLFxuICAgIGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICByZXR1cm4gIShhd2FpdCBmbiguLi5hcmdzKSlcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKSlcbn1cbmFzeW5jIGZ1bmN0aW9uIGZpbmQoZm4sIG9wdGlvbnMpIHtcbiAgZm9yIGF3YWl0IChjb25zdCByZXN1bHQgb2YgZmlsdGVyLmNhbGwodGhpcywgZm4sIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG4gIHJldHVybiB1bmRlZmluZWRcbn1cbmFzeW5jIGZ1bmN0aW9uIGZvckVhY2goZm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCBbJ0Z1bmN0aW9uJywgJ0FzeW5jRnVuY3Rpb24nXSwgZm4pXG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZm9yRWFjaEZuKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgZm4odmFsdWUsIG9wdGlvbnMpXG4gICAgcmV0dXJuIGtFbXB0eVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBmb3IgYXdhaXQgKGNvbnN0IHVudXNlZCBvZiBtYXAuY2FsbCh0aGlzLCBmb3JFYWNoRm4sIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGZpbHRlcihmbiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdmbicsIFsnRnVuY3Rpb24nLCAnQXN5bmNGdW5jdGlvbiddLCBmbilcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmaWx0ZXJGbih2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChhd2FpdCBmbih2YWx1ZSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICByZXR1cm4ga0VtcHR5XG4gIH1cbiAgcmV0dXJuIG1hcC5jYWxsKHRoaXMsIGZpbHRlckZuLCBvcHRpb25zKVxufVxuXG4vLyBTcGVjaWZpYyB0byBwcm92aWRlIGJldHRlciBlcnJvciB0byByZWR1Y2Ugc2luY2UgdGhlIGFyZ3VtZW50IGlzIG9ubHlcbi8vIG1pc3NpbmcgaWYgdGhlIHN0cmVhbSBoYXMgbm8gaXRlbXMgaW4gaXQgLSBidXQgdGhlIGNvZGUgaXMgc3RpbGwgYXBwcm9wcmlhdGVcbmNsYXNzIFJlZHVjZUF3YXJlRXJyTWlzc2luZ0FyZ3MgZXh0ZW5kcyBFUlJfTUlTU0lOR19BUkdTIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3JlZHVjZScpXG4gICAgdGhpcy5tZXNzYWdlID0gJ1JlZHVjZSBvZiBhbiBlbXB0eSBzdHJlYW0gcmVxdWlyZXMgYW4gaW5pdGlhbCB2YWx1ZSdcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVkdWNlKHJlZHVjZXIsIGluaXRpYWxWYWx1ZSwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkc2lnbmFsMlxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3JlZHVjZXInLCBbJ0Z1bmN0aW9uJywgJ0FzeW5jRnVuY3Rpb24nXSwgcmVkdWNlcilcbiAgfVxuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnNpZ25hbCkgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIH1cbiAgbGV0IGhhc0luaXRpYWxWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gIGlmIChcbiAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgKF9vcHRpb25zJHNpZ25hbDIgPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICBfb3B0aW9ucyRzaWduYWwyICE9PSB1bmRlZmluZWQgJiZcbiAgICBfb3B0aW9ucyRzaWduYWwyLmFib3J0ZWRcbiAgKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEFib3J0RXJyb3IodW5kZWZpbmVkLCB7XG4gICAgICBjYXVzZTogb3B0aW9ucy5zaWduYWwucmVhc29uXG4gICAgfSlcbiAgICB0aGlzLm9uY2UoJ2Vycm9yJywgKCkgPT4ge30pIC8vIFRoZSBlcnJvciBpcyBhbHJlYWR5IHByb3BhZ2F0ZWRcbiAgICBhd2FpdCBmaW5pc2hlZCh0aGlzLmRlc3Ryb3koZXJyKSlcbiAgICB0aHJvdyBlcnJcbiAgfVxuICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICBjb25zdCBzaWduYWwgPSBhYy5zaWduYWxcbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIG9uY2U6IHRydWUsXG4gICAgICBba1dlYWtIYW5kbGVyXTogdGhpcyxcbiAgICAgIFtrUmVzaXN0U3RvcFByb3BhZ2F0aW9uXTogdHJ1ZVxuICAgIH1cbiAgICBvcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGFjLmFib3J0KCksIG9wdHMpXG4gIH1cbiAgbGV0IGdvdEFueUl0ZW1Gcm9tU3RyZWFtID0gZmFsc2VcbiAgdHJ5IHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHRoaXMpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRzaWduYWwzXG4gICAgICBnb3RBbnlJdGVtRnJvbVN0cmVhbSA9IHRydWVcbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgICBvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKF9vcHRpb25zJHNpZ25hbDMgPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsMyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIF9vcHRpb25zJHNpZ25hbDMuYWJvcnRlZFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKClcbiAgICAgIH1cbiAgICAgIGlmICghaGFzSW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IHZhbHVlXG4gICAgICAgIGhhc0luaXRpYWxWYWx1ZSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IGF3YWl0IHJlZHVjZXIoaW5pdGlhbFZhbHVlLCB2YWx1ZSwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWdvdEFueUl0ZW1Gcm9tU3RyZWFtICYmICFoYXNJbml0aWFsVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBSZWR1Y2VBd2FyZUVyck1pc3NpbmdBcmdzKClcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgYWMuYWJvcnQoKVxuICB9XG4gIHJldHVybiBpbml0aWFsVmFsdWVcbn1cbmFzeW5jIGZ1bmN0aW9uIHRvQXJyYXkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnNpZ25hbCkgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgdGhpcykge1xuICAgIHZhciBfb3B0aW9ucyRzaWduYWw0XG4gICAgaWYgKFxuICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAoX29wdGlvbnMkc2lnbmFsNCA9IG9wdGlvbnMuc2lnbmFsKSAhPT0gbnVsbCAmJlxuICAgICAgX29wdGlvbnMkc2lnbmFsNCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBfb3B0aW9ucyRzaWduYWw0LmFib3J0ZWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKHVuZGVmaW5lZCwge1xuICAgICAgICBjYXVzZTogb3B0aW9ucy5zaWduYWwucmVhc29uXG4gICAgICB9KVxuICAgIH1cbiAgICBBcnJheVByb3RvdHlwZVB1c2gocmVzdWx0LCB2YWwpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuZnVuY3Rpb24gZmxhdE1hcChmbiwgb3B0aW9ucykge1xuICBjb25zdCB2YWx1ZXMgPSBtYXAuY2FsbCh0aGlzLCBmbiwgb3B0aW9ucylcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiBmbGF0TWFwKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHZhbHVlcykge1xuICAgICAgeWllbGQqIHZhbFxuICAgIH1cbiAgfS5jYWxsKHRoaXMpXG59XG5mdW5jdGlvbiB0b0ludGVnZXJPckluZmluaXR5KG51bWJlcikge1xuICAvLyBXZSBjb2VyY2UgaGVyZSB0byBhbGlnbiB3aXRoIHRoZSBzcGVjXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWl0ZXJhdG9yLWhlbHBlcnMvaXNzdWVzLzE2OVxuICBudW1iZXIgPSBOdW1iZXIobnVtYmVyKVxuICBpZiAoTnVtYmVySXNOYU4obnVtYmVyKSkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKG51bWJlciA8IDApIHtcbiAgICB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRSgnbnVtYmVyJywgJz49IDAnLCBudW1iZXIpXG4gIH1cbiAgcmV0dXJuIG51bWJlclxufVxuZnVuY3Rpb24gZHJvcChudW1iZXIsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJylcbiAgfVxuICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5zaWduYWwpICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCAnb3B0aW9ucy5zaWduYWwnKVxuICB9XG4gIG51bWJlciA9IHRvSW50ZWdlck9ySW5maW5pdHkobnVtYmVyKVxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24qIGRyb3AoKSB7XG4gICAgdmFyIF9vcHRpb25zJHNpZ25hbDVcbiAgICBpZiAoXG4gICAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgICBvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChfb3B0aW9ucyRzaWduYWw1ID0gb3B0aW9ucy5zaWduYWwpICE9PSBudWxsICYmXG4gICAgICBfb3B0aW9ucyRzaWduYWw1ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIF9vcHRpb25zJHNpZ25hbDUuYWJvcnRlZFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoKVxuICAgIH1cbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiB0aGlzKSB7XG4gICAgICB2YXIgX29wdGlvbnMkc2lnbmFsNlxuICAgICAgaWYgKFxuICAgICAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgICAgIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAoX29wdGlvbnMkc2lnbmFsNiA9IG9wdGlvbnMuc2lnbmFsKSAhPT0gbnVsbCAmJlxuICAgICAgICBfb3B0aW9ucyRzaWduYWw2ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsNi5hYm9ydGVkXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoKVxuICAgICAgfVxuICAgICAgaWYgKG51bWJlci0tIDw9IDApIHtcbiAgICAgICAgeWllbGQgdmFsXG4gICAgICB9XG4gICAgfVxuICB9LmNhbGwodGhpcylcbn1cbmZ1bmN0aW9uIHRha2UobnVtYmVyLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgfVxuICBudW1iZXIgPSB0b0ludGVnZXJPckluZmluaXR5KG51bWJlcilcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiB0YWtlKCkge1xuICAgIHZhciBfb3B0aW9ucyRzaWduYWw3XG4gICAgaWYgKFxuICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAoX29wdGlvbnMkc2lnbmFsNyA9IG9wdGlvbnMuc2lnbmFsKSAhPT0gbnVsbCAmJlxuICAgICAgX29wdGlvbnMkc2lnbmFsNyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBfb3B0aW9ucyRzaWduYWw3LmFib3J0ZWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKClcbiAgICB9XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgdGhpcykge1xuICAgICAgdmFyIF9vcHRpb25zJHNpZ25hbDhcbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgICBvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKF9vcHRpb25zJHNpZ25hbDggPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsOCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIF9vcHRpb25zJHNpZ25hbDguYWJvcnRlZFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKClcbiAgICAgIH1cbiAgICAgIGlmIChudW1iZXItLSA+IDApIHtcbiAgICAgICAgeWllbGQgdmFsXG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IGdldCBhbm90aGVyIGl0ZW0gZnJvbSBpdGVyYXRvciBpbiBjYXNlIHdlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgaWYgKG51bWJlciA8PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfS5jYWxsKHRoaXMpXG59XG5tb2R1bGUuZXhwb3J0cy5zdHJlYW1SZXR1cm5pbmdPcGVyYXRvcnMgPSB7XG4gIGFzSW5kZXhlZFBhaXJzOiBkZXByZWNhdGUoYXNJbmRleGVkUGFpcnMsICdyZWFkYWJsZS5hc0luZGV4ZWRQYWlycyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4nKSxcbiAgZHJvcCxcbiAgZmlsdGVyLFxuICBmbGF0TWFwLFxuICBtYXAsXG4gIHRha2UsXG4gIGNvbXBvc2Vcbn1cbm1vZHVsZS5leHBvcnRzLnByb21pc2VSZXR1cm5pbmdPcGVyYXRvcnMgPSB7XG4gIGV2ZXJ5LFxuICBmb3JFYWNoLFxuICByZWR1Y2UsXG4gIHRvQXJyYXksXG4gIHNvbWUsXG4gIGZpbmRcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/operators.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/passthrough.js":
/*!**************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/passthrough.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nconst { ObjectSetPrototypeOf } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nmodule.exports = PassThrough\nconst Transform = __webpack_require__(/*! ./transform */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/transform.js\")\nObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype)\nObjectSetPrototypeOf(PassThrough, Transform)\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options)\n  Transform.call(this, options)\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3Bhc3N0aHJvdWdoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVZOztBQUVaLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDakU7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldGgtbG9uZG9uLTIwMjQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3Bhc3N0aHJvdWdoLmpzP2JkNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBPYmplY3RTZXRQcm90b3R5cGVPZiB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybScpXG5PYmplY3RTZXRQcm90b3R5cGVPZihQYXNzVGhyb3VnaC5wcm90b3R5cGUsIFRyYW5zZm9ybS5wcm90b3R5cGUpXG5PYmplY3RTZXRQcm90b3R5cGVPZihQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpXG59XG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/passthrough.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(ssr)/./node_modules/process/index.js\")\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nconst { once } = __webpack_require__(/*! ../../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\")\nconst destroyImpl = __webpack_require__(/*! ./destroy */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/duplex.js\")\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\")\nconst { validateFunction, validateAbortSignal } = __webpack_require__(/*! ../validators */ \"(ssr)/./node_modules/readable-stream/lib/internal/validators.js\")\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream,\n  isTransformStream,\n  isWebStream,\n  isReadableStream,\n  isReadableFinished\n} = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(ssr)/./node_modules/abort-controller/dist/abort-controller.js\").AbortController)\nlet PassThrough\nlet Readable\nlet addAbortListener\nfunction destroyer(stream, reading, writing) {\n  let finished = false\n  stream.on('close', () => {\n    finished = true\n  })\n  const cleanup = eos(\n    stream,\n    {\n      readable: reading,\n      writable: writing\n    },\n    (err) => {\n      finished = !err\n    }\n  )\n  return {\n    destroy: (err) => {\n      if (finished) return\n      finished = true\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))\n    },\n    cleanup\n  }\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')\n  return streams.pop()\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val)\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = __webpack_require__(/*! ./readable */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/readable.js\")\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val)\n}\nasync function pumpToNode(iterable, writable, finish, { end }) {\n  let error\n  let onresolve = null\n  const resume = (err) => {\n    if (err) {\n      error = err\n    }\n    if (onresolve) {\n      const callback = onresolve\n      onresolve = null\n      callback()\n    }\n  }\n  const wait = () =>\n    new Promise((resolve, reject) => {\n      if (error) {\n        reject(error)\n      } else {\n        onresolve = () => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        }\n      }\n    })\n  writable.on('drain', resume)\n  const cleanup = eos(\n    writable,\n    {\n      readable: false\n    },\n    resume\n  )\n  try {\n    if (writable.writableNeedDrain) {\n      await wait()\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait()\n      }\n    }\n    if (end) {\n      writable.end()\n      await wait()\n    }\n    finish()\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err)\n  } finally {\n    cleanup()\n    writable.off('drain', resume)\n  }\n}\nasync function pumpToWeb(readable, writable, finish, { end }) {\n  if (isTransformStream(writable)) {\n    writable = writable.writable\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter()\n  try {\n    for await (const chunk of readable) {\n      await writer.ready\n      writer.write(chunk).catch(() => {})\n    }\n    await writer.ready\n    if (end) {\n      await writer.close()\n    }\n    finish()\n  } catch (err) {\n    try {\n      await writer.abort(err)\n      finish(err)\n    } catch (err) {\n      finish(err)\n    }\n  }\n}\nfunction pipeline(...streams) {\n  return pipelineImpl(streams, once(popCallback(streams)))\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0]\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = []\n  validateAbortSignal(outerSignal, 'options.signal')\n  function abort() {\n    finishImpl(new AbortError())\n  }\n  addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\").addAbortListener)\n  let disposable\n  if (outerSignal) {\n    disposable = addAbortListener(outerSignal, abort)\n  }\n  let error\n  let value\n  const destroys = []\n  let finishCount = 0\n  function finish(err) {\n    finishImpl(err, --finishCount === 0)\n  }\n  function finishImpl(err, final) {\n    var _disposable\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err\n    }\n    if (!error && !final) {\n      return\n    }\n    while (destroys.length) {\n      destroys.shift()(error)\n    }\n    ;(_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]()\n    ac.abort()\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn())\n      }\n      process.nextTick(callback, error, value)\n    }\n  }\n  let ret\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i]\n    const reading = i < streams.length - 1\n    const writing = i > 0\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false\n    const isLastStream = i === streams.length - 1\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy, cleanup } = destroyer(stream, reading, writing)\n        destroys.push(destroy)\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err)\n        }\n      }\n      stream.on('error', onError)\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError)\n        })\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        })\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream\n      } else {\n        ret = Duplex.from(stream)\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        var _ret\n        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable)\n      } else {\n        ret = makeAsyncIterable(ret)\n      }\n      ret = stream(ret, {\n        signal\n      })\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)\n        }\n      } else {\n        var _ret2\n        if (!PassThrough) {\n          PassThrough = __webpack_require__(/*! ./passthrough */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/passthrough.js\")\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        })\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then\n        if (typeof then === 'function') {\n          finishCount++\n          then.call(\n            ret,\n            (val) => {\n              value = val\n              if (val != null) {\n                pt.write(val)\n              }\n              if (end) {\n                pt.end()\n              }\n              process.nextTick(finish)\n            },\n            (err) => {\n              pt.destroy(err)\n              process.nextTick(finish, err)\n            }\n          )\n        } else if (isIterable(ret, true)) {\n          finishCount++\n          pumpToNode(ret, pt, finish, {\n            end\n          })\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret\n          finishCount++\n          pumpToNode(toRead, pt, finish, {\n            end\n          })\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)\n        }\n        ret = pt\n        const { destroy, cleanup } = destroyer(ret, false, true)\n        destroys.push(destroy)\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        })\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret\n        finishCount++\n        pumpToNode(toRead, stream, finish, {\n          end\n        })\n      } else if (isIterable(ret)) {\n        finishCount++\n        pumpToNode(ret, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++\n        pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n          end\n        })\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++\n        pumpToWeb(ret, stream, finish, {\n          end\n        })\n      } else if (isTransformStream(ret)) {\n        finishCount++\n        pumpToWeb(ret.readable, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else {\n      ret = Duplex.from(stream)\n    }\n  }\n  if (\n    (signal !== null && signal !== undefined && signal.aborted) ||\n    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)\n  ) {\n    process.nextTick(abort)\n  }\n  return ret\n}\nfunction pipe(src, dst, finish, { end }) {\n  let ended = false\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE())\n    }\n  })\n  src.pipe(dst, {\n    end: false\n  }) // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n\n    function endFn() {\n      ended = true\n      dst.end()\n    }\n    if (isReadableFinished(src)) {\n      // End the destination if the source has already ended.\n      process.nextTick(endFn)\n    } else {\n      src.once('end', endFn)\n    }\n  } else {\n    finish()\n  }\n  eos(\n    src,\n    {\n      readable: true,\n      writable: false\n    },\n    (err) => {\n      const rState = src._readableState\n      if (\n        err &&\n        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n        rState &&\n        rState.ended &&\n        !rState.errored &&\n        !rState.errorEmitted\n      ) {\n        // Some readable streams will emit 'close' before 'end'. However, since\n        // this is on the readable side 'end' should still be emitted if the\n        // stream has been ended and no error emitted. This should be allowed in\n        // favor of backwards compatibility. Since the stream is piped to a\n        // destination this should not result in any observable difference.\n        // We don't need to check if this is a writable premature close since\n        // eos will only fail with premature close on the reading side for\n        // duplex streams.\n        src.once('end', finish).once('error', finish)\n      } else {\n        finish(err)\n      }\n    }\n  )\n  return eos(\n    dst,\n    {\n      readable: false,\n      writable: true\n    },\n    finish\n  )\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFVOztBQUVsQztBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQVEsNERBQTRELEVBQUUsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDdEcsWUFBWSxtQkFBTyxDQUFDLG1HQUFpQjtBQUNyQyxRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLDhFQUFpQjtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBVztBQUN2QyxlQUFlLG1CQUFPLENBQUMscUZBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGtGQUFtQjtBQUMvQixRQUFRLHdDQUF3QyxFQUFFLG1CQUFPLENBQUMsc0ZBQWU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsbUZBQVM7QUFDckIsc0RBQXNELCtIQUEyQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyx5RkFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxLQUFLO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNIQUEyQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDJFQUEyRSxNQUFNO0FBQ2pGO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQywrRkFBZTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXRoLWxvbmRvbi0yMDI0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcz84MDlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHJlcGxhY2VtZW50IHN0YXJ0ICovXG5cbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzLycpXG5cbi8qIHJlcGxhY2VtZW50IGVuZCAqL1xuLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9wdW1wIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuXG47KCd1c2Ugc3RyaWN0JylcbmNvbnN0IHsgQXJyYXlJc0FycmF5LCBQcm9taXNlLCBTeW1ib2xBc3luY0l0ZXJhdG9yLCBTeW1ib2xEaXNwb3NlIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpXG5jb25zdCB7IG9uY2UgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpXG5jb25zdCBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vZGVzdHJveScpXG5jb25zdCBEdXBsZXggPSByZXF1aXJlKCcuL2R1cGxleCcpXG5jb25zdCB7XG4gIGFnZ3JlZ2F0ZVR3b0Vycm9ycyxcbiAgY29kZXM6IHtcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUsXG4gICAgRVJSX01JU1NJTkdfQVJHUyxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRVxuICB9LFxuICBBYm9ydEVycm9yXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKVxuY29uc3QgeyB2YWxpZGF0ZUZ1bmN0aW9uLCB2YWxpZGF0ZUFib3J0U2lnbmFsIH0gPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJylcbmNvbnN0IHtcbiAgaXNJdGVyYWJsZSxcbiAgaXNSZWFkYWJsZSxcbiAgaXNSZWFkYWJsZU5vZGVTdHJlYW0sXG4gIGlzTm9kZVN0cmVhbSxcbiAgaXNUcmFuc2Zvcm1TdHJlYW0sXG4gIGlzV2ViU3RyZWFtLFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc1JlYWRhYmxlRmluaXNoZWRcbn0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IEFib3J0Q29udHJvbGxlciA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyIHx8IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKS5BYm9ydENvbnRyb2xsZXJcbmxldCBQYXNzVGhyb3VnaFxubGV0IFJlYWRhYmxlXG5sZXQgYWRkQWJvcnRMaXN0ZW5lclxuZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZykge1xuICBsZXQgZmluaXNoZWQgPSBmYWxzZVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgIGZpbmlzaGVkID0gdHJ1ZVxuICB9KVxuICBjb25zdCBjbGVhbnVwID0gZW9zKFxuICAgIHN0cmVhbSxcbiAgICB7XG4gICAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICAgIHdyaXRhYmxlOiB3cml0aW5nXG4gICAgfSxcbiAgICAoZXJyKSA9PiB7XG4gICAgICBmaW5pc2hlZCA9ICFlcnJcbiAgICB9XG4gIClcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiAoZXJyKSA9PiB7XG4gICAgICBpZiAoZmluaXNoZWQpIHJldHVyblxuICAgICAgZmluaXNoZWQgPSB0cnVlXG4gICAgICBkZXN0cm95SW1wbC5kZXN0cm95ZXIoc3RyZWFtLCBlcnIgfHwgbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdwaXBlJykpXG4gICAgfSxcbiAgICBjbGVhbnVwXG4gIH1cbn1cbmZ1bmN0aW9uIHBvcENhbGxiYWNrKHN0cmVhbXMpIHtcbiAgLy8gU3RyZWFtcyBzaG91bGQgbmV2ZXIgYmUgYW4gZW1wdHkgYXJyYXkuIEl0IHNob3VsZCBhbHdheXMgY29udGFpbiBhdCBsZWFzdFxuICAvLyBhIHNpbmdsZSBzdHJlYW0uIFRoZXJlZm9yZSBvcHRpbWl6ZSBmb3IgdGhlIGF2ZXJhZ2UgY2FzZSBpbnN0ZWFkIG9mXG4gIC8vIGNoZWNraW5nIGZvciBsZW5ndGggPT09IDAgYXMgd2VsbC5cbiAgdmFsaWRhdGVGdW5jdGlvbihzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0sICdzdHJlYW1zW3N0cmVhbS5sZW5ndGggLSAxXScpXG4gIHJldHVybiBzdHJlYW1zLnBvcCgpXG59XG5mdW5jdGlvbiBtYWtlQXN5bmNJdGVyYWJsZSh2YWwpIHtcbiAgaWYgKGlzSXRlcmFibGUodmFsKSkge1xuICAgIHJldHVybiB2YWxcbiAgfSBlbHNlIGlmIChpc1JlYWRhYmxlTm9kZVN0cmVhbSh2YWwpKSB7XG4gICAgLy8gTGVnYWN5IHN0cmVhbXMgYXJlIG5vdCBJdGVyYWJsZS5cbiAgICByZXR1cm4gZnJvbVJlYWRhYmxlKHZhbClcbiAgfVxuICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3ZhbCcsIFsnUmVhZGFibGUnLCAnSXRlcmFibGUnLCAnQXN5bmNJdGVyYWJsZSddLCB2YWwpXG59XG5hc3luYyBmdW5jdGlvbiogZnJvbVJlYWRhYmxlKHZhbCkge1xuICBpZiAoIVJlYWRhYmxlKSB7XG4gICAgUmVhZGFibGUgPSByZXF1aXJlKCcuL3JlYWRhYmxlJylcbiAgfVxuICB5aWVsZCogUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbEFzeW5jSXRlcmF0b3JdLmNhbGwodmFsKVxufVxuYXN5bmMgZnVuY3Rpb24gcHVtcFRvTm9kZShpdGVyYWJsZSwgd3JpdGFibGUsIGZpbmlzaCwgeyBlbmQgfSkge1xuICBsZXQgZXJyb3JcbiAgbGV0IG9ucmVzb2x2ZSA9IG51bGxcbiAgY29uc3QgcmVzdW1lID0gKGVycikgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yID0gZXJyXG4gICAgfVxuICAgIGlmIChvbnJlc29sdmUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gb25yZXNvbHZlXG4gICAgICBvbnJlc29sdmUgPSBudWxsXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG4gIGNvbnN0IHdhaXQgPSAoKSA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbnJlc29sdmUgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIHdyaXRhYmxlLm9uKCdkcmFpbicsIHJlc3VtZSlcbiAgY29uc3QgY2xlYW51cCA9IGVvcyhcbiAgICB3cml0YWJsZSxcbiAgICB7XG4gICAgICByZWFkYWJsZTogZmFsc2VcbiAgICB9LFxuICAgIHJlc3VtZVxuICApXG4gIHRyeSB7XG4gICAgaWYgKHdyaXRhYmxlLndyaXRhYmxlTmVlZERyYWluKSB7XG4gICAgICBhd2FpdCB3YWl0KClcbiAgICB9XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyYWJsZSkge1xuICAgICAgaWYgKCF3cml0YWJsZS53cml0ZShjaHVuaykpIHtcbiAgICAgICAgYXdhaXQgd2FpdCgpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgIHdyaXRhYmxlLmVuZCgpXG4gICAgICBhd2FpdCB3YWl0KClcbiAgICB9XG4gICAgZmluaXNoKClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZmluaXNoKGVycm9yICE9PSBlcnIgPyBhZ2dyZWdhdGVUd29FcnJvcnMoZXJyb3IsIGVycikgOiBlcnIpXG4gIH0gZmluYWxseSB7XG4gICAgY2xlYW51cCgpXG4gICAgd3JpdGFibGUub2ZmKCdkcmFpbicsIHJlc3VtZSlcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcHVtcFRvV2ViKHJlYWRhYmxlLCB3cml0YWJsZSwgZmluaXNoLCB7IGVuZCB9KSB7XG4gIGlmIChpc1RyYW5zZm9ybVN0cmVhbSh3cml0YWJsZSkpIHtcbiAgICB3cml0YWJsZSA9IHdyaXRhYmxlLndyaXRhYmxlXG4gIH1cbiAgLy8gaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jZXhhbXBsZS1tYW51YWwtd3JpdGUtd2l0aC1iYWNrcHJlc3N1cmVcbiAgY29uc3Qgd3JpdGVyID0gd3JpdGFibGUuZ2V0V3JpdGVyKClcbiAgdHJ5IHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlYWRhYmxlKSB7XG4gICAgICBhd2FpdCB3cml0ZXIucmVhZHlcbiAgICAgIHdyaXRlci53cml0ZShjaHVuaykuY2F0Y2goKCkgPT4ge30pXG4gICAgfVxuICAgIGF3YWl0IHdyaXRlci5yZWFkeVxuICAgIGlmIChlbmQpIHtcbiAgICAgIGF3YWl0IHdyaXRlci5jbG9zZSgpXG4gICAgfVxuICAgIGZpbmlzaCgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3cml0ZXIuYWJvcnQoZXJyKVxuICAgICAgZmluaXNoKGVycilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGZpbmlzaChlcnIpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwaXBlbGluZSguLi5zdHJlYW1zKSB7XG4gIHJldHVybiBwaXBlbGluZUltcGwoc3RyZWFtcywgb25jZShwb3BDYWxsYmFjayhzdHJlYW1zKSkpXG59XG5mdW5jdGlvbiBwaXBlbGluZUltcGwoc3RyZWFtcywgY2FsbGJhY2ssIG9wdHMpIHtcbiAgaWYgKHN0cmVhbXMubGVuZ3RoID09PSAxICYmIEFycmF5SXNBcnJheShzdHJlYW1zWzBdKSkge1xuICAgIHN0cmVhbXMgPSBzdHJlYW1zWzBdXG4gIH1cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJylcbiAgfVxuICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICBjb25zdCBzaWduYWwgPSBhYy5zaWduYWxcbiAgY29uc3Qgb3V0ZXJTaWduYWwgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdHMuc2lnbmFsXG5cbiAgLy8gTmVlZCB0byBjbGVhbnVwIGV2ZW50IGxpc3RlbmVycyBpZiBsYXN0IHN0cmVhbSBpcyByZWFkYWJsZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzM1NDUyXG4gIGNvbnN0IGxhc3RTdHJlYW1DbGVhbnVwID0gW11cbiAgdmFsaWRhdGVBYm9ydFNpZ25hbChvdXRlclNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgZmluaXNoSW1wbChuZXcgQWJvcnRFcnJvcigpKVxuICB9XG4gIGFkZEFib3J0TGlzdGVuZXIgPSBhZGRBYm9ydExpc3RlbmVyIHx8IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpLmFkZEFib3J0TGlzdGVuZXJcbiAgbGV0IGRpc3Bvc2FibGVcbiAgaWYgKG91dGVyU2lnbmFsKSB7XG4gICAgZGlzcG9zYWJsZSA9IGFkZEFib3J0TGlzdGVuZXIob3V0ZXJTaWduYWwsIGFib3J0KVxuICB9XG4gIGxldCBlcnJvclxuICBsZXQgdmFsdWVcbiAgY29uc3QgZGVzdHJveXMgPSBbXVxuICBsZXQgZmluaXNoQ291bnQgPSAwXG4gIGZ1bmN0aW9uIGZpbmlzaChlcnIpIHtcbiAgICBmaW5pc2hJbXBsKGVyciwgLS1maW5pc2hDb3VudCA9PT0gMClcbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hJbXBsKGVyciwgZmluYWwpIHtcbiAgICB2YXIgX2Rpc3Bvc2FibGVcbiAgICBpZiAoZXJyICYmICghZXJyb3IgfHwgZXJyb3IuY29kZSA9PT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykpIHtcbiAgICAgIGVycm9yID0gZXJyXG4gICAgfVxuICAgIGlmICghZXJyb3IgJiYgIWZpbmFsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgd2hpbGUgKGRlc3Ryb3lzLmxlbmd0aCkge1xuICAgICAgZGVzdHJveXMuc2hpZnQoKShlcnJvcilcbiAgICB9XG4gICAgOyhfZGlzcG9zYWJsZSA9IGRpc3Bvc2FibGUpID09PSBudWxsIHx8IF9kaXNwb3NhYmxlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfZGlzcG9zYWJsZVtTeW1ib2xEaXNwb3NlXSgpXG4gICAgYWMuYWJvcnQoKVxuICAgIGlmIChmaW5hbCkge1xuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICBsYXN0U3RyZWFtQ2xlYW51cC5mb3JFYWNoKChmbikgPT4gZm4oKSlcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIGVycm9yLCB2YWx1ZSlcbiAgICB9XG4gIH1cbiAgbGV0IHJldFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdHJlYW0gPSBzdHJlYW1zW2ldXG4gICAgY29uc3QgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDFcbiAgICBjb25zdCB3cml0aW5nID0gaSA+IDBcbiAgICBjb25zdCBlbmQgPSByZWFkaW5nIHx8IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdHMuZW5kKSAhPT0gZmFsc2VcbiAgICBjb25zdCBpc0xhc3RTdHJlYW0gPSBpID09PSBzdHJlYW1zLmxlbmd0aCAtIDFcbiAgICBpZiAoaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgY29uc3QgeyBkZXN0cm95LCBjbGVhbnVwIH0gPSBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nKVxuICAgICAgICBkZXN0cm95cy5wdXNoKGRlc3Ryb3kpXG4gICAgICAgIGlmIChpc1JlYWRhYmxlKHN0cmVhbSkgJiYgaXNMYXN0U3RyZWFtKSB7XG4gICAgICAgICAgbGFzdFN0cmVhbUNsZWFudXAucHVzaChjbGVhbnVwKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENhdGNoIHN0cmVhbSBlcnJvcnMgdGhhdCBvY2N1ciBhZnRlciBwaXBlL3B1bXAgaGFzIGNvbXBsZXRlZC5cbiAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLm5hbWUgIT09ICdBYm9ydEVycm9yJyAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgICAgIGZpbmlzaChlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0cmVhbS5vbignZXJyb3InLCBvbkVycm9yKVxuICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtKSAmJiBpc0xhc3RTdHJlYW0pIHtcbiAgICAgICAgbGFzdFN0cmVhbUNsZWFudXAucHVzaCgoKSA9PiB7XG4gICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXQgPSBzdHJlYW0oe1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KVxuICAgICAgICBpZiAoIWlzSXRlcmFibGUocmV0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ0l0ZXJhYmxlLCBBc3luY0l0ZXJhYmxlIG9yIFN0cmVhbScsICdzb3VyY2UnLCByZXQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNJdGVyYWJsZShzdHJlYW0pIHx8IGlzUmVhZGFibGVOb2RlU3RyZWFtKHN0cmVhbSkgfHwgaXNUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtKSkge1xuICAgICAgICByZXQgPSBzdHJlYW1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IER1cGxleC5mcm9tKHN0cmVhbSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChpc1RyYW5zZm9ybVN0cmVhbShyZXQpKSB7XG4gICAgICAgIHZhciBfcmV0XG4gICAgICAgIHJldCA9IG1ha2VBc3luY0l0ZXJhYmxlKChfcmV0ID0gcmV0KSA9PT0gbnVsbCB8fCBfcmV0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfcmV0LnJlYWRhYmxlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbWFrZUFzeW5jSXRlcmFibGUocmV0KVxuICAgICAgfVxuICAgICAgcmV0ID0gc3RyZWFtKHJldCwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pXG4gICAgICBpZiAocmVhZGluZykge1xuICAgICAgICBpZiAoIWlzSXRlcmFibGUocmV0LCB0cnVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ0FzeW5jSXRlcmFibGUnLCBgdHJhbnNmb3JtWyR7aSAtIDF9XWAsIHJldClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9yZXQyXG4gICAgICAgIGlmICghUGFzc1Rocm91Z2gpIHtcbiAgICAgICAgICBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vcGFzc3Rocm91Z2gnKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgYXJndW1lbnQgdG8gcGlwZWxpbmUgaXMgbm90IGEgc3RyZWFtXG4gICAgICAgIC8vIHdlIG11c3QgY3JlYXRlIGEgcHJveHkgc3RyZWFtIHNvIHRoYXQgcGlwZWxpbmUoLi4uKVxuICAgICAgICAvLyBhbHdheXMgcmV0dXJucyBhIHN0cmVhbSB3aGljaCBjYW4gYmUgZnVydGhlclxuICAgICAgICAvLyBjb21wb3NlZCB0aHJvdWdoIGAucGlwZShzdHJlYW0pYC5cblxuICAgICAgICBjb25zdCBwdCA9IG5ldyBQYXNzVGhyb3VnaCh7XG4gICAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIEhhbmRsZSBQcm9taXNlcy9BKyBzcGVjLCBgdGhlbmAgY291bGQgYmUgYSBnZXR0ZXIgdGhhdCB0aHJvd3Mgb25cbiAgICAgICAgLy8gc2Vjb25kIHVzZS5cbiAgICAgICAgY29uc3QgdGhlbiA9IChfcmV0MiA9IHJldCkgPT09IG51bGwgfHwgX3JldDIgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9yZXQyLnRoZW5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZmluaXNoQ291bnQrK1xuICAgICAgICAgIHRoZW4uY2FsbChcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgICh2YWwpID0+IHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWxcbiAgICAgICAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHQud3JpdGUodmFsKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICBwdC5lbmQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcHQuZGVzdHJveShlcnIpXG4gICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoLCBlcnIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKGlzSXRlcmFibGUocmV0LCB0cnVlKSkge1xuICAgICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgICBwdW1wVG9Ob2RlKHJldCwgcHQsIGZpbmlzaCwge1xuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlYWRhYmxlU3RyZWFtKHJldCkgfHwgaXNUcmFuc2Zvcm1TdHJlYW0ocmV0KSkge1xuICAgICAgICAgIGNvbnN0IHRvUmVhZCA9IHJldC5yZWFkYWJsZSB8fCByZXRcbiAgICAgICAgICBmaW5pc2hDb3VudCsrXG4gICAgICAgICAgcHVtcFRvTm9kZSh0b1JlYWQsIHB0LCBmaW5pc2gsIHtcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnQXN5bmNJdGVyYWJsZSBvciBQcm9taXNlJywgJ2Rlc3RpbmF0aW9uJywgcmV0KVxuICAgICAgICB9XG4gICAgICAgIHJldCA9IHB0XG4gICAgICAgIGNvbnN0IHsgZGVzdHJveSwgY2xlYW51cCB9ID0gZGVzdHJveWVyKHJldCwgZmFsc2UsIHRydWUpXG4gICAgICAgIGRlc3Ryb3lzLnB1c2goZGVzdHJveSlcbiAgICAgICAgaWYgKGlzTGFzdFN0cmVhbSkge1xuICAgICAgICAgIGxhc3RTdHJlYW1DbGVhbnVwLnB1c2goY2xlYW51cClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICAgIGlmIChpc1JlYWRhYmxlTm9kZVN0cmVhbShyZXQpKSB7XG4gICAgICAgIGZpbmlzaENvdW50ICs9IDJcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IHBpcGUocmV0LCBzdHJlYW0sIGZpbmlzaCwge1xuICAgICAgICAgIGVuZFxuICAgICAgICB9KVxuICAgICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0pICYmIGlzTGFzdFN0cmVhbSkge1xuICAgICAgICAgIGxhc3RTdHJlYW1DbGVhbnVwLnB1c2goY2xlYW51cClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1RyYW5zZm9ybVN0cmVhbShyZXQpIHx8IGlzUmVhZGFibGVTdHJlYW0ocmV0KSkge1xuICAgICAgICBjb25zdCB0b1JlYWQgPSByZXQucmVhZGFibGUgfHwgcmV0XG4gICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgcHVtcFRvTm9kZSh0b1JlYWQsIHN0cmVhbSwgZmluaXNoLCB7XG4gICAgICAgICAgZW5kXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGlzSXRlcmFibGUocmV0KSkge1xuICAgICAgICBmaW5pc2hDb3VudCsrXG4gICAgICAgIHB1bXBUb05vZGUocmV0LCBzdHJlYW0sIGZpbmlzaCwge1xuICAgICAgICAgIGVuZFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFxuICAgICAgICAgICd2YWwnLFxuICAgICAgICAgIFsnUmVhZGFibGUnLCAnSXRlcmFibGUnLCAnQXN5bmNJdGVyYWJsZScsICdSZWFkYWJsZVN0cmVhbScsICdUcmFuc2Zvcm1TdHJlYW0nXSxcbiAgICAgICAgICByZXRcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgcmV0ID0gc3RyZWFtXG4gICAgfSBlbHNlIGlmIChpc1dlYlN0cmVhbShzdHJlYW0pKSB7XG4gICAgICBpZiAoaXNSZWFkYWJsZU5vZGVTdHJlYW0ocmV0KSkge1xuICAgICAgICBmaW5pc2hDb3VudCsrXG4gICAgICAgIHB1bXBUb1dlYihtYWtlQXN5bmNJdGVyYWJsZShyZXQpLCBzdHJlYW0sIGZpbmlzaCwge1xuICAgICAgICAgIGVuZFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChpc1JlYWRhYmxlU3RyZWFtKHJldCkgfHwgaXNJdGVyYWJsZShyZXQpKSB7XG4gICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgcHVtcFRvV2ViKHJldCwgc3RyZWFtLCBmaW5pc2gsIHtcbiAgICAgICAgICBlbmRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoaXNUcmFuc2Zvcm1TdHJlYW0ocmV0KSkge1xuICAgICAgICBmaW5pc2hDb3VudCsrXG4gICAgICAgIHB1bXBUb1dlYihyZXQucmVhZGFibGUsIHN0cmVhbSwgZmluaXNoLCB7XG4gICAgICAgICAgZW5kXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXG4gICAgICAgICAgJ3ZhbCcsXG4gICAgICAgICAgWydSZWFkYWJsZScsICdJdGVyYWJsZScsICdBc3luY0l0ZXJhYmxlJywgJ1JlYWRhYmxlU3RyZWFtJywgJ1RyYW5zZm9ybVN0cmVhbSddLFxuICAgICAgICAgIHJldFxuICAgICAgICApXG4gICAgICB9XG4gICAgICByZXQgPSBzdHJlYW1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ID0gRHVwbGV4LmZyb20oc3RyZWFtKVxuICAgIH1cbiAgfVxuICBpZiAoXG4gICAgKHNpZ25hbCAhPT0gbnVsbCAmJiBzaWduYWwgIT09IHVuZGVmaW5lZCAmJiBzaWduYWwuYWJvcnRlZCkgfHxcbiAgICAob3V0ZXJTaWduYWwgIT09IG51bGwgJiYgb3V0ZXJTaWduYWwgIT09IHVuZGVmaW5lZCAmJiBvdXRlclNpZ25hbC5hYm9ydGVkKVxuICApIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGFib3J0KVxuICB9XG4gIHJldHVybiByZXRcbn1cbmZ1bmN0aW9uIHBpcGUoc3JjLCBkc3QsIGZpbmlzaCwgeyBlbmQgfSkge1xuICBsZXQgZW5kZWQgPSBmYWxzZVxuICBkc3Qub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgIGlmICghZW5kZWQpIHtcbiAgICAgIC8vIEZpbmlzaCBpZiB0aGUgZGVzdGluYXRpb24gY2xvc2VzIGJlZm9yZSB0aGUgc291cmNlIGhhcyBjb21wbGV0ZWQuXG4gICAgICBmaW5pc2gobmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCkpXG4gICAgfVxuICB9KVxuICBzcmMucGlwZShkc3QsIHtcbiAgICBlbmQ6IGZhbHNlXG4gIH0pIC8vIElmIGVuZCBpcyB0cnVlIHdlIGFscmVhZHkgd2lsbCBoYXZlIGEgbGlzdGVuZXIgdG8gZW5kIGRzdC5cblxuICBpZiAoZW5kKSB7XG4gICAgLy8gQ29tcGF0LiBCZWZvcmUgbm9kZSB2MTAuMTIuMCBzdGRpbyB1c2VkIHRvIHRocm93IGFuIGVycm9yIHNvXG4gICAgLy8gcGlwZSgpIGRpZC9kb2VzIG5vdCBlbmQoKSBzdGRpbyBkZXN0aW5hdGlvbnMuXG4gICAgLy8gTm93IHRoZXkgYWxsb3cgaXQgYnV0IFwic2VjcmV0bHlcIiBkb24ndCBjbG9zZSB0aGUgdW5kZXJseWluZyBmZC5cblxuICAgIGZ1bmN0aW9uIGVuZEZuKCkge1xuICAgICAgZW5kZWQgPSB0cnVlXG4gICAgICBkc3QuZW5kKClcbiAgICB9XG4gICAgaWYgKGlzUmVhZGFibGVGaW5pc2hlZChzcmMpKSB7XG4gICAgICAvLyBFbmQgdGhlIGRlc3RpbmF0aW9uIGlmIHRoZSBzb3VyY2UgaGFzIGFscmVhZHkgZW5kZWQuXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKVxuICAgIH0gZWxzZSB7XG4gICAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmlzaCgpXG4gIH1cbiAgZW9zKFxuICAgIHNyYyxcbiAgICB7XG4gICAgICByZWFkYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0sXG4gICAgKGVycikgPT4ge1xuICAgICAgY29uc3QgclN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlXG4gICAgICBpZiAoXG4gICAgICAgIGVyciAmJlxuICAgICAgICBlcnIuY29kZSA9PT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJyAmJlxuICAgICAgICByU3RhdGUgJiZcbiAgICAgICAgclN0YXRlLmVuZGVkICYmXG4gICAgICAgICFyU3RhdGUuZXJyb3JlZCAmJlxuICAgICAgICAhclN0YXRlLmVycm9yRW1pdHRlZFxuICAgICAgKSB7XG4gICAgICAgIC8vIFNvbWUgcmVhZGFibGUgc3RyZWFtcyB3aWxsIGVtaXQgJ2Nsb3NlJyBiZWZvcmUgJ2VuZCcuIEhvd2V2ZXIsIHNpbmNlXG4gICAgICAgIC8vIHRoaXMgaXMgb24gdGhlIHJlYWRhYmxlIHNpZGUgJ2VuZCcgc2hvdWxkIHN0aWxsIGJlIGVtaXR0ZWQgaWYgdGhlXG4gICAgICAgIC8vIHN0cmVhbSBoYXMgYmVlbiBlbmRlZCBhbmQgbm8gZXJyb3IgZW1pdHRlZC4gVGhpcyBzaG91bGQgYmUgYWxsb3dlZCBpblxuICAgICAgICAvLyBmYXZvciBvZiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gU2luY2UgdGhlIHN0cmVhbSBpcyBwaXBlZCB0byBhXG4gICAgICAgIC8vIGRlc3RpbmF0aW9uIHRoaXMgc2hvdWxkIG5vdCByZXN1bHQgaW4gYW55IG9ic2VydmFibGUgZGlmZmVyZW5jZS5cbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBpZiB0aGlzIGlzIGEgd3JpdGFibGUgcHJlbWF0dXJlIGNsb3NlIHNpbmNlXG4gICAgICAgIC8vIGVvcyB3aWxsIG9ubHkgZmFpbCB3aXRoIHByZW1hdHVyZSBjbG9zZSBvbiB0aGUgcmVhZGluZyBzaWRlIGZvclxuICAgICAgICAvLyBkdXBsZXggc3RyZWFtcy5cbiAgICAgICAgc3JjLm9uY2UoJ2VuZCcsIGZpbmlzaCkub25jZSgnZXJyb3InLCBmaW5pc2gpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5pc2goZXJyKVxuICAgICAgfVxuICAgIH1cbiAgKVxuICByZXR1cm4gZW9zKFxuICAgIGRzdCxcbiAgICB7XG4gICAgICByZWFkYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgZmluaXNoXG4gIClcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwaXBlbGluZUltcGwsXG4gIHBpcGVsaW5lXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/pipeline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/readable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/readable.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(ssr)/./node_modules/process/index.js\")\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n;('use strict')\nconst {\n  ArrayPrototypeIndexOf,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperties,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  SafeSet,\n  SymbolAsyncDispose,\n  SymbolAsyncIterator,\n  Symbol\n} = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nmodule.exports = Readable\nReadable.ReadableState = ReadableState\nconst { EventEmitter: EE } = __webpack_require__(/*! events */ \"events\")\nconst { Stream, prependListener } = __webpack_require__(/*! ./legacy */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/legacy.js\")\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { addAbortSignal } = __webpack_require__(/*! ./add-abort-signal */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\")\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nlet debug = (__webpack_require__(/*! ../../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\").debuglog)('stream', (fn) => {\n  debug = fn\n})\nconst BufferList = __webpack_require__(/*! ./buffer_list */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/buffer_list.js\")\nconst destroyImpl = __webpack_require__(/*! ./destroy */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst { getHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./state */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/state.js\")\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_OUT_OF_RANGE,\n    ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n  },\n  AbortError\n} = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\")\nconst { validateObject } = __webpack_require__(/*! ../validators */ \"(ssr)/./node_modules/readable-stream/lib/internal/validators.js\")\nconst kPaused = Symbol('kPaused')\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\")\nconst from = __webpack_require__(/*! ./from */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/from.js\")\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Readable, Stream)\nconst nop = () => {}\nconst { errorOrDestroy } = destroyImpl\nconst kObjectMode = 1 << 0\nconst kEnded = 1 << 1\nconst kEndEmitted = 1 << 2\nconst kReading = 1 << 3\nconst kConstructed = 1 << 4\nconst kSync = 1 << 5\nconst kNeedReadable = 1 << 6\nconst kEmittedReadable = 1 << 7\nconst kReadableListening = 1 << 8\nconst kResumeScheduled = 1 << 9\nconst kErrorEmitted = 1 << 10\nconst kEmitClose = 1 << 11\nconst kAutoDestroy = 1 << 12\nconst kDestroyed = 1 << 13\nconst kClosed = 1 << 14\nconst kCloseEmitted = 1 << 15\nconst kMultiAwaitDrain = 1 << 16\nconst kReadingMore = 1 << 17\nconst kDataEmitted = 1 << 18\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false,\n    get() {\n      return (this.state & bit) !== 0\n    },\n    set(value) {\n      if (value) this.state |= bit\n      else this.state &= ~bit\n    }\n  }\n}\nObjectDefineProperties(ReadableState.prototype, {\n  objectMode: makeBitMapDescriptor(kObjectMode),\n  ended: makeBitMapDescriptor(kEnded),\n  endEmitted: makeBitMapDescriptor(kEndEmitted),\n  reading: makeBitMapDescriptor(kReading),\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed),\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  sync: makeBitMapDescriptor(kSync),\n  // Whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  needReadable: makeBitMapDescriptor(kNeedReadable),\n  emittedReadable: makeBitMapDescriptor(kEmittedReadable),\n  readableListening: makeBitMapDescriptor(kReadableListening),\n  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted),\n  emitClose: makeBitMapDescriptor(kEmitClose),\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy),\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed),\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed),\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted),\n  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),\n  // If true, a maybeReadMore has been scheduled.\n  readingMore: makeBitMapDescriptor(kReadingMore),\n  dataEmitted: makeBitMapDescriptor(kDataEmitted)\n})\nfunction ReadableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof __webpack_require__(/*! ./duplex */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/duplex.js\")\n\n  // Bit map field to store ReadableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  if (options && options.objectMode) this.state |= kObjectMode\n  if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList()\n  this.length = 0\n  this.pipes = []\n  this.flowing = null\n  this[kPaused] = null\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this.state &= ~kEmitClose\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls, 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null\n  this.decoder = null\n  this.encoding = null\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding)\n    this.encoding = options.encoding\n  }\n}\nfunction Readable(options) {\n  if (!(this instanceof Readable)) return new Readable(options)\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof __webpack_require__(/*! ./duplex */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/duplex.js\")\n  this._readableState = new ReadableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal && !isDuplex) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this, this._readableState)\n    }\n  })\n}\nReadable.prototype.destroy = destroyImpl.destroy\nReadable.prototype._undestroy = destroyImpl.undestroy\nReadable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nReadable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\nReadable.prototype[SymbolAsyncDispose] = function () {\n  let error\n  if (!this.destroyed) {\n    error = this.readableEnded ? null : new AbortError()\n    this.destroy(error)\n  }\n  return new Promise((resolve, reject) => eos(this, (err) => (err && err !== error ? reject(err) : resolve(null))))\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, false)\n}\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, true)\n}\nfunction readableAddChunk(stream, chunk, encoding, addToFront) {\n  debug('readableAddChunk', chunk)\n  const state = stream._readableState\n  let err\n  if ((state.state & kObjectMode) === 0) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting, if state.encoding is set, we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk, encoding).toString(state.encoding)\n        } else {\n          chunk = Buffer.from(chunk, encoding)\n          encoding = ''\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = ''\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = ''\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  if (err) {\n    errorOrDestroy(stream, err)\n  } else if (chunk === null) {\n    state.state &= ~kReading\n    onEofChunk(stream, state)\n  } else if ((state.state & kObjectMode) !== 0 || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT())\n      else if (state.destroyed || state.errored) return false\n      else addChunk(stream, state, chunk, true)\n    } else if (state.ended) {\n      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF())\n    } else if (state.destroyed || state.errored) {\n      return false\n    } else {\n      state.state &= ~kReading\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk)\n        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false)\n        else maybeReadMore(stream, state)\n      } else {\n        addChunk(stream, state, chunk, false)\n      }\n    }\n  } else if (!addToFront) {\n    state.state &= ~kReading\n    maybeReadMore(stream, state)\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0)\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if ((state.state & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n    state.dataEmitted = true\n    stream.emit('data', chunk)\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length\n    if (addToFront) state.buffer.unshift(chunk)\n    else state.buffer.push(chunk)\n    if ((state.state & kNeedReadable) !== 0) emitReadable(stream)\n  }\n  maybeReadMore(stream, state)\n}\nReadable.prototype.isPaused = function () {\n  const state = this._readableState\n  return state[kPaused] === true || state.flowing === false\n}\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  const decoder = new StringDecoder(enc)\n  this._readableState.decoder = decoder\n  // If setEncoding(null), decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding\n  const buffer = this._readableState.buffer\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = ''\n  for (const data of buffer) {\n    content += decoder.write(data)\n  }\n  buffer.clear()\n  if (content !== '') buffer.push(content)\n  this._readableState.length = content.length\n  return this\n}\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--\n    n |= n >>> 1\n    n |= n >>> 2\n    n |= n >>> 4\n    n |= n >>> 8\n    n |= n >>> 16\n    n++\n  }\n  return n\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || (state.length === 0 && state.ended)) return 0\n  if ((state.state & kObjectMode) !== 0) return 1\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length) return state.buffer.first().length\n    return state.length\n  }\n  if (n <= state.length) return n\n  return state.ended ? state.length : 0\n}\n\n// You can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n)\n  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n  // in this scenario, so we are doing it manually.\n  if (n === undefined) {\n    n = NaN\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n, 10)\n  }\n  const state = this._readableState\n  const nOrig = n\n\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)\n  if (n !== 0) state.state &= ~kEmittedReadable\n\n  // If we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (\n    n === 0 &&\n    state.needReadable &&\n    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)\n  ) {\n    debug('read: emitReadable', state.length, state.ended)\n    if (state.length === 0 && state.ended) endReadable(this)\n    else emitReadable(this)\n    return null\n  }\n  n = howMuchToRead(n, state)\n\n  // If we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this)\n    return null\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  let doRead = (state.state & kNeedReadable) !== 0\n  debug('need readable', doRead)\n\n  // If we currently have less than the highWaterMark, then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true\n    debug('length less than watermark', doRead)\n  }\n\n  // However, if we've ended, then there's no point, if we're already\n  // reading, then it's unnecessary, if we're constructing we have to wait,\n  // and if we're destroyed or errored, then it's not allowed,\n  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n    doRead = false\n    debug('reading, ended or constructing', doRead)\n  } else if (doRead) {\n    debug('do read')\n    state.state |= kReading | kSync\n    // If the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.state |= kNeedReadable\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark)\n    } catch (err) {\n      errorOrDestroy(this, err)\n    }\n    state.state &= ~kSync\n\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state)\n  }\n  let ret\n  if (n > 0) ret = fromList(n, state)\n  else ret = null\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark\n    n = 0\n  } else {\n    state.length -= n\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this)\n  }\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true\n    this.emit('data', ret)\n  }\n  return ret\n}\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk')\n  if (state.ended) return\n  if (state.decoder) {\n    const chunk = state.decoder.end()\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk)\n      state.length += state.objectMode ? 1 : chunk.length\n    }\n  }\n  state.ended = true\n  if (state.sync) {\n    // If we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream)\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false\n    state.emittedReadable = true\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream)\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState\n  debug('emitReadable', state.needReadable, state.emittedReadable)\n  state.needReadable = false\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing)\n    state.emittedReadable = true\n    process.nextTick(emitReadable_, stream)\n  }\n}\nfunction emitReadable_(stream) {\n  const state = stream._readableState\n  debug('emitReadable_', state.destroyed, state.length, state.ended)\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable')\n    state.emittedReadable = false\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark\n  flow(stream)\n}\n\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true\n    process.nextTick(maybeReadMore_, stream, state)\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (\n    !state.reading &&\n    !state.ended &&\n    (state.length < state.highWaterMark || (state.flowing && state.length === 0))\n  ) {\n    const len = state.length\n    debug('maybeReadMore read 0')\n    stream.read(0)\n    if (len === state.length)\n      // Didn't get any data, stop spinning.\n      break\n  }\n  state.readingMore = false\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')\n}\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  const src = this\n  const state = this._readableState\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true\n      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : [])\n    }\n  }\n  state.pipes.push(dest)\n  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts)\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr\n  const endFn = doEnd ? onend : unpipe\n  if (state.endEmitted) process.nextTick(endFn)\n  else src.once('end', endFn)\n  dest.on('unpipe', onunpipe)\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe')\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true\n        cleanup()\n      }\n    }\n  }\n  function onend() {\n    debug('onend')\n    dest.end()\n  }\n  let ondrain\n  let cleanedUp = false\n  function cleanup() {\n    debug('cleanup')\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close', onclose)\n    dest.removeListener('finish', onfinish)\n    if (ondrain) {\n      dest.removeListener('drain', ondrain)\n    }\n    dest.removeListener('error', onerror)\n    dest.removeListener('unpipe', onunpipe)\n    src.removeListener('end', onend)\n    src.removeListener('end', unpipe)\n    src.removeListener('data', ondata)\n    cleanedUp = true\n\n    // If the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain()\n  }\n  function pause() {\n    // If the user unpiped during `dest.write()`, it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response, pause', 0)\n        state.awaitDrainWriters = dest\n        state.multiAwaitDrain = false\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response, pause', state.awaitDrainWriters.size)\n        state.awaitDrainWriters.add(dest)\n      }\n      src.pause()\n    }\n    if (!ondrain) {\n      // When the dest drains, it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow(), but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src, dest)\n      dest.on('drain', ondrain)\n    }\n  }\n  src.on('data', ondata)\n  function ondata(chunk) {\n    debug('ondata')\n    const ret = dest.write(chunk)\n    debug('dest.write', ret)\n    if (ret === false) {\n      pause()\n    }\n  }\n\n  // If the dest has an error, then stop piping into it.\n  // However, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er)\n    unpipe()\n    dest.removeListener('error', onerror)\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest, er)\n      } else {\n        dest.emit('error', er)\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror)\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish)\n    unpipe()\n  }\n  dest.once('close', onclose)\n  function onfinish() {\n    debug('onfinish')\n    dest.removeListener('close', onclose)\n    unpipe()\n  }\n  dest.once('finish', onfinish)\n  function unpipe() {\n    debug('unpipe')\n    src.unpipe(dest)\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe', src)\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    pause()\n  } else if (!state.flowing) {\n    debug('pipe resume')\n    src.resume()\n  }\n  return dest\n}\nfunction pipeOnDrain(src, dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState\n\n    // `ondrain` will call directly,\n    // `this` maybe not a reference to dest,\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain', 1)\n      state.awaitDrainWriters = null\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain', state.awaitDrainWriters.size)\n      state.awaitDrainWriters.delete(dest)\n    }\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {\n      src.resume()\n    }\n  }\n}\nReadable.prototype.unpipe = function (dest) {\n  const state = this._readableState\n  const unpipeInfo = {\n    hasUnpiped: false\n  }\n\n  // If we're not piping anywhere, then do nothing.\n  if (state.pipes.length === 0) return this\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes\n    state.pipes = []\n    this.pause()\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      })\n    return this\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes, dest)\n  if (index === -1) return this\n  state.pipes.splice(index, 1)\n  if (state.pipes.length === 0) this.pause()\n  dest.emit('unpipe', this, unpipeInfo)\n  return this\n}\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn)\n  const state = this._readableState\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false) this.resume()\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true\n      state.flowing = false\n      state.emittedReadable = false\n      debug('on readable', state.length, state.reading)\n      if (state.length) {\n        emitReadable(this)\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this)\n      }\n    }\n  }\n  return res\n}\nReadable.prototype.addListener = Readable.prototype.on\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn)\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nReadable.prototype.off = Readable.prototype.removeListener\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments)\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nfunction updateReadableListening(self) {\n  const state = self._readableState\n  state.readableListening = self.listenerCount('readable') > 0\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume()\n  } else if (!state.readableListening) {\n    state.flowing = null\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0')\n  self.read(0)\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  const state = this._readableState\n  if (!state.flowing) {\n    debug('resume')\n    // We flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume().\n    state.flowing = !state.readableListening\n    resume(this, state)\n  }\n  state[kPaused] = false\n  return this\n}\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true\n    process.nextTick(resume_, stream, state)\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading)\n  if (!state.reading) {\n    stream.read(0)\n  }\n  state.resumeScheduled = false\n  stream.emit('resume')\n  flow(stream)\n  if (state.flowing && !state.reading) stream.read(0)\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing)\n  if (this._readableState.flowing !== false) {\n    debug('pause')\n    this._readableState.flowing = false\n    this.emit('pause')\n  }\n  this._readableState[kPaused] = true\n  return this\n}\nfunction flow(stream) {\n  const state = stream._readableState\n  debug('flow', state.flowing)\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  let paused = false\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method, e.g. Readable.wrap(stream).\n\n  stream.on('data', (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true\n      stream.pause()\n    }\n  })\n  stream.on('end', () => {\n    this.push(null)\n  })\n  stream.on('error', (err) => {\n    errorOrDestroy(this, err)\n  })\n  stream.on('close', () => {\n    this.destroy()\n  })\n  stream.on('destroy', () => {\n    this.destroy()\n  })\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false\n      stream.resume()\n    }\n  }\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream)\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j]\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream)\n    }\n  }\n  return this\n}\nReadable.prototype[SymbolAsyncIterator] = function () {\n  return streamToAsyncIterator(this)\n}\nReadable.prototype.iterator = function (options) {\n  if (options !== undefined) {\n    validateObject(options, 'options')\n  }\n  return streamToAsyncIterator(this, options)\n}\nfunction streamToAsyncIterator(stream, options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream, {\n      objectMode: true\n    })\n  }\n  const iter = createAsyncIterator(stream, options)\n  iter.stream = stream\n  return iter\n}\nasync function* createAsyncIterator(stream, options) {\n  let callback = nop\n  function next(resolve) {\n    if (this === stream) {\n      callback()\n      callback = nop\n    } else {\n      callback = resolve\n    }\n  }\n  stream.on('readable', next)\n  let error\n  const cleanup = eos(\n    stream,\n    {\n      writable: false\n    },\n    (err) => {\n      error = err ? aggregateTwoErrors(error, err) : null\n      callback()\n      callback = nop\n    }\n  )\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read()\n      if (chunk !== null) {\n        yield chunk\n      } else if (error) {\n        throw error\n      } else if (error === null) {\n        return\n      } else {\n        await new Promise(next)\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error, err)\n    throw error\n  } finally {\n    if (\n      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream, null)\n    } else {\n      stream.off('readable', next)\n      cleanup()\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype, {\n  readable: {\n    __proto__: null,\n    get() {\n      const r = this._readableState\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted\n    },\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val\n      }\n    }\n  },\n  readableDidRead: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.dataEmitted\n    }\n  },\n  readableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      )\n    }\n  },\n  readableHighWaterMark: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.highWaterMark\n    }\n  },\n  readableBuffer: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState && this._readableState.buffer\n    }\n  },\n  readableFlowing: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.flowing\n    },\n    set: function (state) {\n      if (this._readableState) {\n        this._readableState.flowing = state\n      }\n    }\n  },\n  readableLength: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState.length\n    }\n  },\n  readableObjectMode: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.objectMode : false\n    }\n  },\n  readableEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.encoding : null\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.errored : null\n    }\n  },\n  closed: {\n    __proto__: null,\n    get() {\n      return this._readableState ? this._readableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.destroyed : false\n    },\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return\n      }\n\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value\n    }\n  },\n  readableEnded: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false\n    }\n  }\n})\nObjectDefineProperties(ReadableState.prototype, {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null,\n    get() {\n      return this.pipes.length\n    }\n  },\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null,\n    get() {\n      return this[kPaused] !== false\n    },\n    set(value) {\n      this[kPaused] = !!value\n    }\n  }\n})\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered.\n  if (state.length === 0) return null\n  let ret\n  if (state.objectMode) ret = state.buffer.shift()\n  else if (!n || n >= state.length) {\n    // Read it all, truncate the list.\n    if (state.decoder) ret = state.buffer.join('')\n    else if (state.buffer.length === 1) ret = state.buffer.first()\n    else ret = state.buffer.concat(state.length)\n    state.buffer.clear()\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n, state.decoder)\n  }\n  return ret\n}\nfunction endReadable(stream) {\n  const state = stream._readableState\n  debug('endReadable', state.endEmitted)\n  if (!state.endEmitted) {\n    state.ended = true\n    process.nextTick(endReadableNT, state, stream)\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length)\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n    state.endEmitted = true\n    stream.emit('end')\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT, stream)\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState\n      const autoDestroy =\n        !wState ||\n        (wState.autoDestroy &&\n          // We don't expect the writable to ever 'finish'\n          // if writable is explicitly set to false.\n          (wState.finished || wState.writable === false))\n      if (autoDestroy) {\n        stream.destroy()\n      }\n    }\n  }\n}\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded && !stream.destroyed\n  if (writable) {\n    stream.end()\n  }\n}\nReadable.from = function (iterable, opts) {\n  return from(Readable, iterable, opts)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nReadable.fromWeb = function (readableStream, options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)\n}\nReadable.toWeb = function (streamReadable, options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)\n}\nReadable.wrap = function (src, options) {\n  var _ref, _src$readableObjectMo\n  return new Readable({\n    objectMode:\n      (_ref =\n        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined\n          ? _src$readableObjectMo\n          : src.objectMode) !== null && _ref !== undefined\n        ? _ref\n        : true,\n    ...options,\n    destroy(err, callback) {\n      destroyImpl.destroyer(src, err)\n      callback(err)\n    }\n  }).wrap(src)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3JlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEZBQXdCO0FBQ3BDO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDN0MsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHFGQUFVO0FBQ3RELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbkMsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLHlHQUFvQjtBQUN2RCxZQUFZLG1CQUFPLENBQUMsbUdBQWlCO0FBQ3JDLFlBQVksOEdBQW1DO0FBQy9DO0FBQ0EsQ0FBQztBQUNELG1CQUFtQixtQkFBTyxDQUFDLCtGQUFlO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLHVGQUFXO0FBQ3ZDLFFBQVEsNENBQTRDLEVBQUUsbUJBQU8sQ0FBQyxtRkFBUztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsa0ZBQW1CO0FBQy9CLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxzRkFBZTtBQUNsRDtBQUNBLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxzQ0FBZ0I7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLGlGQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1CQUFPLENBQUMscUZBQVU7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxtQkFBTyxDQUFDLHFGQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXRoLWxvbmRvbi0yMDI0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9yZWFkYWJsZS5qcz9hZWQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHJlcGxhY2VtZW50IHN0YXJ0ICovXG5cbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzLycpXG5cbi8qIHJlcGxhY2VtZW50IGVuZCAqL1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbjsoJ3VzZSBzdHJpY3QnKVxuY29uc3Qge1xuICBBcnJheVByb3RvdHlwZUluZGV4T2YsXG4gIE51bWJlcklzSW50ZWdlcixcbiAgTnVtYmVySXNOYU4sXG4gIE51bWJlclBhcnNlSW50LFxuICBPYmplY3REZWZpbmVQcm9wZXJ0aWVzLFxuICBPYmplY3RLZXlzLFxuICBPYmplY3RTZXRQcm90b3R5cGVPZixcbiAgUHJvbWlzZSxcbiAgU2FmZVNldCxcbiAgU3ltYm9sQXN5bmNEaXNwb3NlLFxuICBTeW1ib2xBc3luY0l0ZXJhdG9yLFxuICBTeW1ib2xcbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGVcblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlXG5jb25zdCB7IEV2ZW50RW1pdHRlcjogRUUgfSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCB7IFN0cmVhbSwgcHJlcGVuZExpc3RlbmVyIH0gPSByZXF1aXJlKCcuL2xlZ2FjeScpXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgYWRkQWJvcnRTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWRkLWFib3J0LXNpZ25hbCcpXG5jb25zdCBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKVxubGV0IGRlYnVnID0gcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJykuZGVidWdsb2coJ3N0cmVhbScsIChmbikgPT4ge1xuICBkZWJ1ZyA9IGZuXG59KVxuY29uc3QgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vYnVmZmVyX2xpc3QnKVxuY29uc3QgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2Rlc3Ryb3knKVxuY29uc3QgeyBnZXRIaWdoV2F0ZXJNYXJrLCBnZXREZWZhdWx0SGlnaFdhdGVyTWFyayB9ID0gcmVxdWlyZSgnLi9zdGF0ZScpXG5jb25zdCB7XG4gIGFnZ3JlZ2F0ZVR3b0Vycm9ycyxcbiAgY29kZXM6IHtcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfT1VUX09GX1JBTkdFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVFxuICB9LFxuICBBYm9ydEVycm9yXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKVxuY29uc3QgeyB2YWxpZGF0ZU9iamVjdCB9ID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpXG5jb25zdCBrUGF1c2VkID0gU3ltYm9sKCdrUGF1c2VkJylcbmNvbnN0IHsgU3RyaW5nRGVjb2RlciB9ID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKVxuY29uc3QgZnJvbSA9IHJlcXVpcmUoJy4vZnJvbScpXG5PYmplY3RTZXRQcm90b3R5cGVPZihSZWFkYWJsZS5wcm90b3R5cGUsIFN0cmVhbS5wcm90b3R5cGUpXG5PYmplY3RTZXRQcm90b3R5cGVPZihSZWFkYWJsZSwgU3RyZWFtKVxuY29uc3Qgbm9wID0gKCkgPT4ge31cbmNvbnN0IHsgZXJyb3JPckRlc3Ryb3kgfSA9IGRlc3Ryb3lJbXBsXG5jb25zdCBrT2JqZWN0TW9kZSA9IDEgPDwgMFxuY29uc3Qga0VuZGVkID0gMSA8PCAxXG5jb25zdCBrRW5kRW1pdHRlZCA9IDEgPDwgMlxuY29uc3Qga1JlYWRpbmcgPSAxIDw8IDNcbmNvbnN0IGtDb25zdHJ1Y3RlZCA9IDEgPDwgNFxuY29uc3Qga1N5bmMgPSAxIDw8IDVcbmNvbnN0IGtOZWVkUmVhZGFibGUgPSAxIDw8IDZcbmNvbnN0IGtFbWl0dGVkUmVhZGFibGUgPSAxIDw8IDdcbmNvbnN0IGtSZWFkYWJsZUxpc3RlbmluZyA9IDEgPDwgOFxuY29uc3Qga1Jlc3VtZVNjaGVkdWxlZCA9IDEgPDwgOVxuY29uc3Qga0Vycm9yRW1pdHRlZCA9IDEgPDwgMTBcbmNvbnN0IGtFbWl0Q2xvc2UgPSAxIDw8IDExXG5jb25zdCBrQXV0b0Rlc3Ryb3kgPSAxIDw8IDEyXG5jb25zdCBrRGVzdHJveWVkID0gMSA8PCAxM1xuY29uc3Qga0Nsb3NlZCA9IDEgPDwgMTRcbmNvbnN0IGtDbG9zZUVtaXR0ZWQgPSAxIDw8IDE1XG5jb25zdCBrTXVsdGlBd2FpdERyYWluID0gMSA8PCAxNlxuY29uc3Qga1JlYWRpbmdNb3JlID0gMSA8PCAxN1xuY29uc3Qga0RhdGFFbWl0dGVkID0gMSA8PCAxOFxuXG4vLyBUT0RPKGJlbmphbWluZ3IpIGl0IGlzIGxpa2VseSBzbG93ZXIgdG8gZG8gaXQgdGhpcyB3YXkgdGhhbiB3aXRoIGZyZWUgZnVuY3Rpb25zXG5mdW5jdGlvbiBtYWtlQml0TWFwRGVzY3JpcHRvcihiaXQpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuc3RhdGUgJiBiaXQpICE9PSAwXG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkgdGhpcy5zdGF0ZSB8PSBiaXRcbiAgICAgIGVsc2UgdGhpcy5zdGF0ZSAmPSB+Yml0XG4gICAgfVxuICB9XG59XG5PYmplY3REZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RhdGUucHJvdG90eXBlLCB7XG4gIG9iamVjdE1vZGU6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtPYmplY3RNb2RlKSxcbiAgZW5kZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtFbmRlZCksXG4gIGVuZEVtaXR0ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtFbmRFbWl0dGVkKSxcbiAgcmVhZGluZzogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa1JlYWRpbmcpLFxuICAvLyBTdHJlYW0gaXMgc3RpbGwgYmVpbmcgY29uc3RydWN0ZWQgYW5kIGNhbm5vdCBiZVxuICAvLyBkZXN0cm95ZWQgdW50aWwgY29uc3RydWN0aW9uIGZpbmlzaGVkIG9yIGZhaWxlZC5cbiAgLy8gQXN5bmMgY29uc3RydWN0aW9uIGlzIG9wdCBpbiwgdGhlcmVmb3JlIHdlIHN0YXJ0IGFzXG4gIC8vIGNvbnN0cnVjdGVkLlxuICBjb25zdHJ1Y3RlZDogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa0NvbnN0cnVjdGVkKSxcbiAgLy8gQSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICBzeW5jOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrU3luYyksXG4gIC8vIFdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICBuZWVkUmVhZGFibGU6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtOZWVkUmVhZGFibGUpLFxuICBlbWl0dGVkUmVhZGFibGU6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtFbWl0dGVkUmVhZGFibGUpLFxuICByZWFkYWJsZUxpc3RlbmluZzogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa1JlYWRhYmxlTGlzdGVuaW5nKSxcbiAgcmVzdW1lU2NoZWR1bGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrUmVzdW1lU2NoZWR1bGVkKSxcbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW4uXG4gIGVycm9yRW1pdHRlZDogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa0Vycm9yRW1pdHRlZCksXG4gIGVtaXRDbG9zZTogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa0VtaXRDbG9zZSksXG4gIGF1dG9EZXN0cm95OiBtYWtlQml0TWFwRGVzY3JpcHRvcihrQXV0b0Rlc3Ryb3kpLFxuICAvLyBIYXMgaXQgYmVlbiBkZXN0cm95ZWQuXG4gIGRlc3Ryb3llZDogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa0Rlc3Ryb3llZCksXG4gIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdHJlYW0gaGFzIGZpbmlzaGVkIGRlc3Ryb3lpbmcuXG4gIGNsb3NlZDogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa0Nsb3NlZCksXG4gIC8vIFRydWUgaWYgY2xvc2UgaGFzIGJlZW4gZW1pdHRlZCBvciB3b3VsZCBoYXZlIGJlZW4gZW1pdHRlZFxuICAvLyBkZXBlbmRpbmcgb24gZW1pdENsb3NlLlxuICBjbG9zZUVtaXR0ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtDbG9zZUVtaXR0ZWQpLFxuICBtdWx0aUF3YWl0RHJhaW46IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtNdWx0aUF3YWl0RHJhaW4pLFxuICAvLyBJZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkLlxuICByZWFkaW5nTW9yZTogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa1JlYWRpbmdNb3JlKSxcbiAgZGF0YUVtaXR0ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtEYXRhRW1pdHRlZClcbn0pXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgcmVxdWlyZSgnLi9kdXBsZXgnKVxuXG4gIC8vIEJpdCBtYXAgZmllbGQgdG8gc3RvcmUgUmVhZGFibGVTdGF0ZSBtb3JlIGVmZmNpZW50bHkgd2l0aCAxIGJpdCBwZXIgZmllbGRcbiAgLy8gaW5zdGVhZCBvZiBhIFY4IHNsb3QgcGVyIGZpZWxkLlxuICB0aGlzLnN0YXRlID0ga0VtaXRDbG9zZSB8IGtBdXRvRGVzdHJveSB8IGtDb25zdHJ1Y3RlZCB8IGtTeW5jXG4gIC8vIE9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5LlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9iamVjdE1vZGUpIHRoaXMuc3RhdGUgfD0ga09iamVjdE1vZGVcbiAgaWYgKGlzRHVwbGV4ICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUpIHRoaXMuc3RhdGUgfD0ga09iamVjdE1vZGVcblxuICAvLyBUaGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IG9wdGlvbnNcbiAgICA/IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KVxuICAgIDogZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsoZmFsc2UpXG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKS5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLnBpcGVzID0gW11cbiAgdGhpcy5mbG93aW5nID0gbnVsbFxuICB0aGlzW2tQYXVzZWRdID0gbnVsbFxuXG4gIC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW1pdENsb3NlID09PSBmYWxzZSkgdGhpcy5zdGF0ZSAmPSB+a0VtaXRDbG9zZVxuXG4gIC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKS5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hdXRvRGVzdHJveSA9PT0gZmFsc2UpIHRoaXMuc3RhdGUgJj0gfmtBdXRvRGVzdHJveVxuXG4gIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdHJlYW0gaGFzIGVycm9yZWQuIFdoZW4gdHJ1ZSBubyBmdXJ0aGVyXG4gIC8vIF9yZWFkIGNhbGxzLCAnZGF0YScgb3IgJ3JlYWRhYmxlJyBldmVudHMgc2hvdWxkIG9jY3VyLiBUaGlzIGlzIG5lZWRlZFxuICAvLyBzaW5jZSB3aGVuIGF1dG9EZXN0cm95IGlzIGRpc2FibGVkIHdlIG5lZWQgYSB3YXkgdG8gdGVsbCB3aGV0aGVyIHRoZVxuICAvLyBzdHJlYW0gaGFzIGZhaWxlZC5cbiAgdGhpcy5lcnJvcmVkID0gbnVsbFxuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcpIHx8ICd1dGY4J1xuXG4gIC8vIFJlZiB0aGUgcGlwZWQgZGVzdCB3aGljaCB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQgb24gaXRcbiAgLy8gdHlwZTogbnVsbCB8IFdyaXRhYmxlIHwgU2V0PFdyaXRhYmxlPi5cbiAgdGhpcy5hd2FpdERyYWluV3JpdGVycyA9IG51bGxcbiAgdGhpcy5kZWNvZGVyID0gbnVsbFxuICB0aGlzLmVuY29kaW5nID0gbnVsbFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZylcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZ1xuICB9XG59XG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucylcblxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNS5cbiAgY29uc3QgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgcmVxdWlyZSgnLi9kdXBsZXgnKVxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWRcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb25zdHJ1Y3QgPT09ICdmdW5jdGlvbicpIHRoaXMuX2NvbnN0cnVjdCA9IG9wdGlvbnMuY29uc3RydWN0XG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsICYmICFpc0R1cGxleCkgYWRkQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsIHRoaXMpXG4gIH1cbiAgU3RyZWFtLmNhbGwodGhpcywgb3B0aW9ucylcbiAgZGVzdHJveUltcGwuY29uc3RydWN0KHRoaXMsICgpID0+IHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUpIHtcbiAgICAgIG1heWJlUmVhZE1vcmUodGhpcywgdGhpcy5fcmVhZGFibGVTdGF0ZSlcbiAgICB9XG4gIH0pXG59XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3lcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpXG59XG5SZWFkYWJsZS5wcm90b3R5cGVbRUUuY2FwdHVyZVJlamVjdGlvblN5bWJvbF0gPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZGVzdHJveShlcnIpXG59XG5SZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sQXN5bmNEaXNwb3NlXSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGVycm9yXG4gIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICBlcnJvciA9IHRoaXMucmVhZGFibGVFbmRlZCA/IG51bGwgOiBuZXcgQWJvcnRFcnJvcigpXG4gICAgdGhpcy5kZXN0cm95KGVycm9yKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBlb3ModGhpcywgKGVycikgPT4gKGVyciAmJiBlcnIgIT09IGVycm9yID8gcmVqZWN0KGVycikgOiByZXNvbHZlKG51bGwpKSkpXG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKS5cblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIHRydWUpXG59XG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspXG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGxldCBlcnJcbiAgaWYgKChzdGF0ZS5zdGF0ZSAmIGtPYmplY3RNb2RlKSA9PT0gMCkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZ1xuICAgICAgaWYgKHN0YXRlLmVuY29kaW5nICE9PSBlbmNvZGluZykge1xuICAgICAgICBpZiAoYWRkVG9Gcm9udCAmJiBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICAgIC8vIFdoZW4gdW5zaGlmdGluZywgaWYgc3RhdGUuZW5jb2RpbmcgaXMgc2V0LCB3ZSBoYXZlIHRvIHNhdmVcbiAgICAgICAgICAvLyB0aGUgc3RyaW5nIGluIHRoZSBCdWZmZXJMaXN0IHdpdGggdGhlIHN0YXRlIGVuY29kaW5nLlxuICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKS50b1N0cmluZyhzdGF0ZS5lbmNvZGluZylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZylcbiAgICAgICAgICBlbmNvZGluZyA9ICcnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNodW5rIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBlbmNvZGluZyA9ICcnXG4gICAgfSBlbHNlIGlmIChTdHJlYW0uX2lzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgIGNodW5rID0gU3RyZWFtLl91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspXG4gICAgICBlbmNvZGluZyA9ICcnXG4gICAgfSBlbHNlIGlmIChjaHVuayAhPSBudWxsKSB7XG4gICAgICBlcnIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspXG4gICAgfVxuICB9XG4gIGlmIChlcnIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycilcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnN0YXRlICY9IH5rUmVhZGluZ1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSlcbiAgfSBlbHNlIGlmICgoc3RhdGUuc3RhdGUgJiBrT2JqZWN0TW9kZSkgIT09IDAgfHwgKGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApKSB7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgIGlmICgoc3RhdGUuc3RhdGUgJiBrRW5kRW1pdHRlZCkgIT09IDApIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSlcbiAgICAgIGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCB8fCBzdGF0ZS5lcnJvcmVkKSByZXR1cm4gZmFsc2VcbiAgICAgIGVsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKVxuICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkIHx8IHN0YXRlLmVycm9yZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5zdGF0ZSAmPSB+a1JlYWRpbmdcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspXG4gICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKVxuICAgICAgICBlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSlcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5zdGF0ZSAmPSB+a1JlYWRpbmdcbiAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpXG4gIH1cblxuICAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxuICAvLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZSBtb3JlIGJ5dGVzLlxuICAvLyBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLCBzdWNoIGFzIHRoZSByZXBsLlxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMClcbn1cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYyAmJiBzdHJlYW0ubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIC8vIFVzZSB0aGUgZ3VhcmQgdG8gYXZvaWQgY3JlYXRpbmcgYFNldCgpYCByZXBlYXRlZGx5XG4gICAgLy8gd2hlbiB3ZSBoYXZlIG11bHRpcGxlIHBpcGVzLlxuICAgIGlmICgoc3RhdGUuc3RhdGUgJiBrTXVsdGlBd2FpdERyYWluKSAhPT0gMCkge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMuY2xlYXIoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5hd2FpdERyYWluV3JpdGVycyA9IG51bGxcbiAgICB9XG4gICAgc3RhdGUuZGF0YUVtaXR0ZWQgPSB0cnVlXG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuaylcbiAgfSBlbHNlIHtcbiAgICAvLyBVcGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aFxuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuaylcbiAgICBlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKVxuICAgIGlmICgoc3RhdGUuc3RhdGUgJiBrTmVlZFJlYWRhYmxlKSAhPT0gMCkgZW1pdFJlYWRhYmxlKHN0cmVhbSlcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpXG59XG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICByZXR1cm4gc3RhdGVba1BhdXNlZF0gPT09IHRydWUgfHwgc3RhdGUuZmxvd2luZyA9PT0gZmFsc2Vcbn1cblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXJcbiAgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjguXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2RpbmdcbiAgY29uc3QgYnVmZmVyID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXJcbiAgLy8gSXRlcmF0ZSBvdmVyIGN1cnJlbnQgYnVmZmVyIHRvIGNvbnZlcnQgYWxyZWFkeSBzdG9yZWQgQnVmZmVyczpcbiAgbGV0IGNvbnRlbnQgPSAnJ1xuICBmb3IgKGNvbnN0IGRhdGEgb2YgYnVmZmVyKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKGRhdGEpXG4gIH1cbiAgYnVmZmVyLmNsZWFyKClcbiAgaWYgKGNvbnRlbnQgIT09ICcnKSBidWZmZXIucHVzaChjb250ZW50KVxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxR0IuXG5jb25zdCBNQVhfSFdNID0gMHg0MDAwMDAwMFxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+IE1BWF9IV00pIHtcbiAgICB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRSgnc2l6ZScsICc8PSAxR2lCJywgbilcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHMuXG4gICAgbi0tXG4gICAgbiB8PSBuID4+PiAxXG4gICAgbiB8PSBuID4+PiAyXG4gICAgbiB8PSBuID4+PiA0XG4gICAgbiB8PSBuID4+PiA4XG4gICAgbiB8PSBuID4+PiAxNlxuICAgIG4rK1xuICB9XG4gIHJldHVybiBuXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpKSByZXR1cm4gMFxuICBpZiAoKHN0YXRlLnN0YXRlICYga09iamVjdE1vZGUpICE9PSAwKSByZXR1cm4gMVxuICBpZiAoTnVtYmVySXNOYU4obikpIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWUuXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmZpcnN0KCkubGVuZ3RoXG4gICAgcmV0dXJuIHN0YXRlLmxlbmd0aFxuICB9XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG5cbiAgcmV0dXJuIHN0YXRlLmVuZGVkID8gc3RhdGUubGVuZ3RoIDogMFxufVxuXG4vLyBZb3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pXG4gIC8vIFNhbWUgYXMgcGFyc2VJbnQodW5kZWZpbmVkLCAxMCksIGhvd2V2ZXIgVjggNy4zIHBlcmZvcm1hbmNlIHJlZ3Jlc3NlZFxuICAvLyBpbiB0aGlzIHNjZW5hcmlvLCBzbyB3ZSBhcmUgZG9pbmcgaXQgbWFudWFsbHkuXG4gIGlmIChuID09PSB1bmRlZmluZWQpIHtcbiAgICBuID0gTmFOXG4gIH0gZWxzZSBpZiAoIU51bWJlcklzSW50ZWdlcihuKSkge1xuICAgIG4gPSBOdW1iZXJQYXJzZUludChuLCAxMClcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGVcbiAgY29uc3Qgbk9yaWcgPSBuXG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5zdGF0ZSAmPSB+a0VtaXR0ZWRSZWFkYWJsZVxuXG4gIC8vIElmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKFxuICAgIG4gPT09IDAgJiZcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKVxuICApIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZClcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKVxuICAgIGVsc2UgZW1pdFJlYWRhYmxlKHRoaXMpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSlcblxuICAvLyBJZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcylcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIGxldCBkb1JlYWQgPSAoc3RhdGUuc3RhdGUgJiBrTmVlZFJlYWRhYmxlKSAhPT0gMFxuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZClcblxuICAvLyBJZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWUuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlXG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKVxuICB9XG5cbiAgLy8gSG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnksIGlmIHdlJ3JlIGNvbnN0cnVjdGluZyB3ZSBoYXZlIHRvIHdhaXQsXG4gIC8vIGFuZCBpZiB3ZSdyZSBkZXN0cm95ZWQgb3IgZXJyb3JlZCwgdGhlbiBpdCdzIG5vdCBhbGxvd2VkLFxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZyB8fCBzdGF0ZS5kZXN0cm95ZWQgfHwgc3RhdGUuZXJyb3JlZCB8fCAhc3RhdGUuY29uc3RydWN0ZWQpIHtcbiAgICBkb1JlYWQgPSBmYWxzZVxuICAgIGRlYnVnKCdyZWFkaW5nLCBlbmRlZCBvciBjb25zdHJ1Y3RpbmcnLCBkb1JlYWQpXG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKVxuICAgIHN0YXRlLnN0YXRlIHw9IGtSZWFkaW5nIHwga1N5bmNcbiAgICAvLyBJZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLnN0YXRlIHw9IGtOZWVkUmVhZGFibGVcblxuICAgIC8vIENhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0cnkge1xuICAgICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3kodGhpcywgZXJyKVxuICAgIH1cbiAgICBzdGF0ZS5zdGF0ZSAmPSB+a1N5bmNcblxuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKVxuICB9XG4gIGxldCByZXRcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSlcbiAgZWxzZSByZXQgPSBudWxsXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFya1xuICAgIG4gPSAwXG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG5cbiAgICBpZiAoc3RhdGUubXVsdGlBd2FpdERyYWluKSB7XG4gICAgICBzdGF0ZS5hd2FpdERyYWluV3JpdGVycy5jbGVhcigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzID0gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWVcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpXG4gIH1cbiAgaWYgKHJldCAhPT0gbnVsbCAmJiAhc3RhdGUuZXJyb3JFbWl0dGVkICYmICFzdGF0ZS5jbG9zZUVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5kYXRhRW1pdHRlZCA9IHRydWVcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJylcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm5cbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICBjb25zdCBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKClcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuaylcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aFxuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWVcbiAgaWYgKHN0YXRlLnN5bmMpIHtcbiAgICAvLyBJZiB3ZSBhcmUgc3luYywgd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZW1pdCB0aGUgZGF0YS5cbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcbiAgICAvLyB0aGUgcmVhZGFibGUgY29kZSB0cmlnZ2VycyBkdXJpbmcgYSByZWFkKCkgY2FsbC5cbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKVxuICB9IGVsc2Uge1xuICAgIC8vIEVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZVxuICAgIC8vIFdlIGhhdmUgdG8gZW1pdCByZWFkYWJsZSBub3cgdGhhdCB3ZSBhcmUgRU9GLiBNb2R1bGVzXG4gICAgLy8gaW4gdGhlIGVjb3N5c3RlbSAoZS5nLiBkaWNlcikgcmVseSBvbiB0aGlzIGV2ZW50IGJlaW5nIHN5bmMuXG4gICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pXG4gIH1cbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKVxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZVxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWVcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSlcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmICFzdGF0ZS5lcnJvcmVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJylcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZVxuICB9XG5cbiAgLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmOlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrXG4gIGZsb3coc3RyZWFtKVxufVxuXG4vLyBBdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlICYmIHN0YXRlLmNvbnN0cnVjdGVkKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlXG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSlcbiAgfVxufVxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxuICAvLyAgIG1ldGhvZCwgYnV0IHRoZXkgYXJlIHByb2Nlc3NpbmcgdGhlIGNhbGwgYXN5bmNocm9ub3VzbHkgYW5kIGhhdmUgX25vdF9cbiAgLy8gICBjYWxsZWQgcHVzaCgpIHdpdGggbmV3IGRhdGEuIEluIHRoaXMgY2FzZSB3ZSBza2lwIHBlcmZvcm1pbmcgbW9yZVxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXG4gIC8vICAgdXAgY2FsbGluZyBwdXNoKCkgd2l0aCBtb3JlIGRhdGEuXG4gIHdoaWxlIChcbiAgICAhc3RhdGUucmVhZGluZyAmJlxuICAgICFzdGF0ZS5lbmRlZCAmJlxuICAgIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpXG4gICkge1xuICAgIGNvbnN0IGxlbiA9IHN0YXRlLmxlbmd0aFxuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpXG4gICAgc3RyZWFtLnJlYWQoMClcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBEaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlXG59XG5cbi8vIEFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhyb3cgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJylcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIGNvbnN0IHNyYyA9IHRoaXNcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGlmIChzdGF0ZS5waXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoIXN0YXRlLm11bHRpQXdhaXREcmFpbikge1xuICAgICAgc3RhdGUubXVsdGlBd2FpdERyYWluID0gdHJ1ZVxuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMgPSBuZXcgU2FmZVNldChzdGF0ZS5hd2FpdERyYWluV3JpdGVycyA/IFtzdGF0ZS5hd2FpdERyYWluV3JpdGVyc10gOiBbXSlcbiAgICB9XG4gIH1cbiAgc3RhdGUucGlwZXMucHVzaChkZXN0KVxuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXMubGVuZ3RoLCBwaXBlT3B0cylcbiAgY29uc3QgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyXG4gIGNvbnN0IGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZVxuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzcy5uZXh0VGljayhlbmRGbilcbiAgZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKVxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZVxuICAgICAgICBjbGVhbnVwKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJylcbiAgICBkZXN0LmVuZCgpXG4gIH1cbiAgbGV0IG9uZHJhaW5cbiAgbGV0IGNsZWFuZWRVcCA9IGZhbHNlXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKVxuICAgIC8vIENsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW4uXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKVxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKVxuICAgIGlmIChvbmRyYWluKSB7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pXG4gICAgfVxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcilcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSlcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKVxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSlcbiAgICBjbGVhbmVkVXAgPSB0cnVlXG5cbiAgICAvLyBJZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChvbmRyYWluICYmIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKVxuICB9XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICBpZiAoIWNsZWFuZWRVcCkge1xuICAgICAgaWYgKHN0YXRlLnBpcGVzLmxlbmd0aCA9PT0gMSAmJiBzdGF0ZS5waXBlc1swXSA9PT0gZGVzdCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgMClcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMgPSBkZXN0XG4gICAgICAgIHN0YXRlLm11bHRpQXdhaXREcmFpbiA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnBpcGVzLmxlbmd0aCA+IDEgJiYgc3RhdGUucGlwZXMuaW5jbHVkZXMoZGVzdCkpIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzLnNpemUpXG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzLmFkZChkZXN0KVxuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKClcbiAgICB9XG4gICAgaWYgKCFvbmRyYWluKSB7XG4gICAgICAvLyBXaGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gICAgICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgICAgIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gICAgICAvLyB0b28gc2xvdy5cbiAgICAgIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMsIGRlc3QpXG4gICAgICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pXG4gICAgfVxuICB9XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSlcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpXG4gICAgY29uc3QgcmV0ID0gZGVzdC53cml0ZShjaHVuaylcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldClcbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgcGF1c2UoKVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBIb3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKVxuICAgIHVucGlwZSgpXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKVxuICAgIGlmIChkZXN0Lmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIGNvbnN0IHMgPSBkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3JlYWRhYmxlU3RhdGVcbiAgICAgIGlmIChzICYmICFzLmVycm9yRW1pdHRlZCkge1xuICAgICAgICAvLyBVc2VyIGluY29ycmVjdGx5IGVtaXR0ZWQgJ2Vycm9yJyBkaXJlY3RseSBvbiB0aGUgc3RyZWFtLlxuICAgICAgICBlcnJvck9yRGVzdHJveShkZXN0LCBlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKVxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpXG4gICAgdW5waXBlKClcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSlcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJylcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpXG4gICAgdW5waXBlKClcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKVxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpXG4gICAgc3JjLnVucGlwZShkZXN0KVxuICB9XG5cbiAgLy8gVGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG8uXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYylcblxuICAvLyBTdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG5cbiAgaWYgKGRlc3Qud3JpdGFibGVOZWVkRHJhaW4gPT09IHRydWUpIHtcbiAgICBwYXVzZSgpXG4gIH0gZWxzZSBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKVxuICAgIHNyYy5yZXN1bWUoKVxuICB9XG4gIHJldHVybiBkZXN0XG59XG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMsIGRlc3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGVcblxuICAgIC8vIGBvbmRyYWluYCB3aWxsIGNhbGwgZGlyZWN0bHksXG4gICAgLy8gYHRoaXNgIG1heWJlIG5vdCBhIHJlZmVyZW5jZSB0byBkZXN0LFxuICAgIC8vIHNvIHdlIHVzZSB0aGUgcmVhbCBkZXN0IGhlcmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzID09PSBkZXN0KSB7XG4gICAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCAxKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMgPSBudWxsXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5tdWx0aUF3YWl0RHJhaW4pIHtcbiAgICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzLnNpemUpXG4gICAgICBzdGF0ZS5hd2FpdERyYWluV3JpdGVycy5kZWxldGUoZGVzdClcbiAgICB9XG4gICAgaWYgKCghc3RhdGUuYXdhaXREcmFpbldyaXRlcnMgfHwgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMuc2l6ZSA9PT0gMCkgJiYgc3JjLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSkge1xuICAgICAgc3JjLnJlc3VtZSgpXG4gICAgfVxuICB9XG59XG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHVucGlwZUluZm8gPSB7XG4gICAgaGFzVW5waXBlZDogZmFsc2VcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXNcbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICBjb25zdCBkZXN0cyA9IHN0YXRlLnBpcGVzXG4gICAgc3RhdGUucGlwZXMgPSBbXVxuICAgIHRoaXMucGF1c2UoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzdHMubGVuZ3RoOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBUcnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICBjb25zdCBpbmRleCA9IEFycmF5UHJvdG90eXBlSW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdClcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXNcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKVxuICBpZiAoc3RhdGUucGlwZXMubGVuZ3RoID09PSAwKSB0aGlzLnBhdXNlKClcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKVxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBTZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZy5cblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgY29uc3QgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbilcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gVXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwXG5cbiAgICAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkLlxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKVxuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlXG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2VcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlXG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKVxuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICBjb25zdCByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKVxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcylcbiAgfVxuICByZXR1cm4gcmVzXG59XG5SZWFkYWJsZS5wcm90b3R5cGUub2ZmID0gUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIGNvbnN0IHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgaWYgKGV2ID09PSAncmVhZGFibGUnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcylcbiAgfVxuICByZXR1cm4gcmVzXG59XG5mdW5jdGlvbiB1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyhzZWxmKSB7XG4gIGNvbnN0IHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZVxuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDBcbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiBzdGF0ZVtrUGF1c2VkXSA9PT0gZmFsc2UpIHtcbiAgICAvLyBGbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlXG5cbiAgICAvLyBDcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZS5cbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpXG4gIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgc3RhdGUuZmxvd2luZyA9IG51bGxcbiAgfVxufVxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKVxuICBzZWxmLnJlYWQoMClcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKVxuICAgIC8vIFdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKCkuXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZ1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSlcbiAgfVxuICBzdGF0ZVtrUGF1c2VkXSA9IGZhbHNlXG4gIHJldHVybiB0aGlzXG59XG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWVcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpXG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZylcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMClcbiAgfVxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZVxuICBzdHJlYW0uZW1pdCgncmVzdW1lJylcbiAgZmxvdyhzdHJlYW0pXG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKVxufVxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKVxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2VcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJylcbiAgfVxuICB0aGlzLl9yZWFkYWJsZVN0YXRlW2tQYXVzZWRdID0gdHJ1ZVxuICByZXR1cm4gdGhpc1xufVxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKVxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKTtcbn1cblxuLy8gV3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIGxldCBwYXVzZWQgPSBmYWxzZVxuXG4gIC8vIFRPRE8gKHJvbmFnKTogU2hvdWxkIHRoaXMuZGVzdHJveShlcnIpIGVtaXRcbiAgLy8gJ2Vycm9yJyBvbiB0aGUgd3JhcHBlZCBzdHJlYW0/IFdvdWxkIHJlcXVpcmVcbiAgLy8gYSBzdGF0aWMgZmFjdG9yeSBtZXRob2QsIGUuZy4gUmVhZGFibGUud3JhcChzdHJlYW0pLlxuXG4gIHN0cmVhbS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgIGlmICghdGhpcy5wdXNoKGNodW5rKSAmJiBzdHJlYW0ucGF1c2UpIHtcbiAgICAgIHBhdXNlZCA9IHRydWVcbiAgICAgIHN0cmVhbS5wYXVzZSgpXG4gICAgfVxuICB9KVxuICBzdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICB0aGlzLnB1c2gobnVsbClcbiAgfSlcbiAgc3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBlcnJvck9yRGVzdHJveSh0aGlzLCBlcnIpXG4gIH0pXG4gIHN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgfSlcbiAgc3RyZWFtLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgIHRoaXMuZGVzdHJveSgpXG4gIH0pXG4gIHRoaXMuX3JlYWQgPSAoKSA9PiB7XG4gICAgaWYgKHBhdXNlZCAmJiBzdHJlYW0ucmVzdW1lKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZVxuICAgICAgc3RyZWFtLnJlc3VtZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gUHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLiBJbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgY29uc3Qgc3RyZWFtS2V5cyA9IE9iamVjdEtleXMoc3RyZWFtKVxuICBmb3IgKGxldCBqID0gMTsgaiA8IHN0cmVhbUtleXMubGVuZ3RoOyBqKyspIHtcbiAgICBjb25zdCBpID0gc3RyZWFtS2V5c1tqXVxuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IHN0cmVhbVtpXS5iaW5kKHN0cmVhbSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2xBc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHN0cmVhbVRvQXN5bmNJdGVyYXRvcih0aGlzKVxufVxuUmVhZGFibGUucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJylcbiAgfVxuICByZXR1cm4gc3RyZWFtVG9Bc3luY0l0ZXJhdG9yKHRoaXMsIG9wdGlvbnMpXG59XG5mdW5jdGlvbiBzdHJlYW1Ub0FzeW5jSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyZWFtLnJlYWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHJlYW0gPSBSZWFkYWJsZS53cmFwKHN0cmVhbSwge1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZVxuICAgIH0pXG4gIH1cbiAgY29uc3QgaXRlciA9IGNyZWF0ZUFzeW5jSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKVxuICBpdGVyLnN0cmVhbSA9IHN0cmVhbVxuICByZXR1cm4gaXRlclxufVxuYXN5bmMgZnVuY3Rpb24qIGNyZWF0ZUFzeW5jSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKSB7XG4gIGxldCBjYWxsYmFjayA9IG5vcFxuICBmdW5jdGlvbiBuZXh0KHJlc29sdmUpIHtcbiAgICBpZiAodGhpcyA9PT0gc3RyZWFtKSB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICBjYWxsYmFjayA9IG5vcFxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayA9IHJlc29sdmVcbiAgICB9XG4gIH1cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG5leHQpXG4gIGxldCBlcnJvclxuICBjb25zdCBjbGVhbnVwID0gZW9zKFxuICAgIHN0cmVhbSxcbiAgICB7XG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9LFxuICAgIChlcnIpID0+IHtcbiAgICAgIGVycm9yID0gZXJyID8gYWdncmVnYXRlVHdvRXJyb3JzKGVycm9yLCBlcnIpIDogbnVsbFxuICAgICAgY2FsbGJhY2soKVxuICAgICAgY2FsbGJhY2sgPSBub3BcbiAgICB9XG4gIClcbiAgdHJ5IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgY2h1bmsgPSBzdHJlYW0uZGVzdHJveWVkID8gbnVsbCA6IHN0cmVhbS5yZWFkKClcbiAgICAgIGlmIChjaHVuayAhPT0gbnVsbCkge1xuICAgICAgICB5aWVsZCBjaHVua1xuICAgICAgfSBlbHNlIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfSBlbHNlIGlmIChlcnJvciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKG5leHQpXG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvciA9IGFnZ3JlZ2F0ZVR3b0Vycm9ycyhlcnJvciwgZXJyKVxuICAgIHRocm93IGVycm9yXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKFxuICAgICAgKGVycm9yIHx8IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuZGVzdHJveU9uUmV0dXJuKSAhPT0gZmFsc2UpICYmXG4gICAgICAoZXJyb3IgPT09IHVuZGVmaW5lZCB8fCBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuYXV0b0Rlc3Ryb3kpXG4gICAgKSB7XG4gICAgICBkZXN0cm95SW1wbC5kZXN0cm95ZXIoc3RyZWFtLCBudWxsKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ub2ZmKCdyZWFkYWJsZScsIG5leHQpXG4gICAgICBjbGVhbnVwKClcbiAgICB9XG4gIH1cbn1cblxuLy8gTWFraW5nIGl0IGV4cGxpY2l0IHRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBlbnVtZXJhYmxlXG4vLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbi8vIHVzZXJsYW5kIHdpbGwgZmFpbC5cbk9iamVjdERlZmluZVByb3BlcnRpZXMoUmVhZGFibGUucHJvdG90eXBlLCB7XG4gIHJlYWRhYmxlOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gICAgICAvLyByLnJlYWRhYmxlID09PSBmYWxzZSBtZWFucyB0aGF0IHRoaXMgaXMgcGFydCBvZiBhIER1cGxleCBzdHJlYW1cbiAgICAgIC8vIHdoZXJlIHRoZSByZWFkYWJsZSBzaWRlIHdhcyBkaXNhYmxlZCB1cG9uIGNvbnN0cnVjdGlvbi5cbiAgICAgIC8vIENvbXBhdC4gVGhlIHVzZXIgbWlnaHQgbWFudWFsbHkgZGlzYWJsZSByZWFkYWJsZSBzaWRlIHRocm91Z2hcbiAgICAgIC8vIGRlcHJlY2F0ZWQgc2V0dGVyLlxuICAgICAgcmV0dXJuICEhciAmJiByLnJlYWRhYmxlICE9PSBmYWxzZSAmJiAhci5kZXN0cm95ZWQgJiYgIXIuZXJyb3JFbWl0dGVkICYmICFyLmVuZEVtaXR0ZWRcbiAgICB9LFxuICAgIHNldCh2YWwpIHtcbiAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQuXG4gICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRhYmxlID0gISF2YWxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlYWRhYmxlRGlkUmVhZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUFib3J0ZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISEoXG4gICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGFibGUgIT09IGZhbHNlICYmXG4gICAgICAgICh0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCB8fCB0aGlzLl9yZWFkYWJsZVN0YXRlLmVycm9yZWQpICYmXG4gICAgICAgICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWRcbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIHJlYWRhYmxlSGlnaFdhdGVyTWFyazoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcmtcbiAgICB9XG4gIH0sXG4gIHJlYWRhYmxlQnVmZmVyOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXJcbiAgICB9XG4gIH0sXG4gIHJlYWRhYmxlRmxvd2luZzoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmdcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVhZGFibGVMZW5ndGg6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoXG4gICAgfVxuICB9LFxuICByZWFkYWJsZU9iamVjdE1vZGU6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgPyB0aGlzLl9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcmVhZGFibGVFbmNvZGluZzoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSA/IHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgOiBudWxsXG4gICAgfVxuICB9LFxuICBlcnJvcmVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlID8gdGhpcy5fcmVhZGFibGVTdGF0ZS5lcnJvcmVkIDogbnVsbFxuICAgIH1cbiAgfSxcbiAgY2xvc2VkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlID8gdGhpcy5fcmVhZGFibGVTdGF0ZS5jbG9zZWQgOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgZGVzdHJveWVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlID8gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgOiBmYWxzZVxuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAvLyBXZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZC5cbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWVcbiAgICB9XG4gIH0sXG4gIHJlYWRhYmxlRW5kZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgPyB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgOiBmYWxzZVxuICAgIH1cbiAgfVxufSlcbk9iamVjdERlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdGF0ZS5wcm90b3R5cGUsIHtcbiAgLy8gTGVnYWN5IGdldHRlciBmb3IgYHBpcGVzQ291bnRgLlxuICBwaXBlc0NvdW50OiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBpcGVzLmxlbmd0aFxuICAgIH1cbiAgfSxcbiAgLy8gTGVnYWN5IHByb3BlcnR5IGZvciBgcGF1c2VkYC5cbiAgcGF1c2VkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW2tQYXVzZWRdICE9PSBmYWxzZVxuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzW2tQYXVzZWRdID0gISF2YWx1ZVxuICAgIH1cbiAgfVxufSlcblxuLy8gRXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3RcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZC5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGxcbiAgbGV0IHJldFxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KClcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyBSZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3QuXG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKVxuICAgIGVsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpXG4gICAgZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aClcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKVxuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0LlxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSlcbiAgfVxufVxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZU5UJywgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKVxuXG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVycm9yZWQgJiYgIXN0YXRlLmNsb3NlRW1pdHRlZCAmJiAhc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZVxuICAgIHN0cmVhbS5lbWl0KCdlbmQnKVxuICAgIGlmIChzdHJlYW0ud3JpdGFibGUgJiYgc3RyZWFtLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFdyaXRhYmxlTlQsIHN0cmVhbSlcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbC5cbiAgICAgIGNvbnN0IHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICAgICAgY29uc3QgYXV0b0Rlc3Ryb3kgPVxuICAgICAgICAhd1N0YXRlIHx8XG4gICAgICAgICh3U3RhdGUuYXV0b0Rlc3Ryb3kgJiZcbiAgICAgICAgICAvLyBXZSBkb24ndCBleHBlY3QgdGhlIHdyaXRhYmxlIHRvIGV2ZXIgJ2ZpbmlzaCdcbiAgICAgICAgICAvLyBpZiB3cml0YWJsZSBpcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZS5cbiAgICAgICAgICAod1N0YXRlLmZpbmlzaGVkIHx8IHdTdGF0ZS53cml0YWJsZSA9PT0gZmFsc2UpKVxuICAgICAgaWYgKGF1dG9EZXN0cm95KSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlTlQoc3RyZWFtKSB7XG4gIGNvbnN0IHdyaXRhYmxlID0gc3RyZWFtLndyaXRhYmxlICYmICFzdHJlYW0ud3JpdGFibGVFbmRlZCAmJiAhc3RyZWFtLmRlc3Ryb3llZFxuICBpZiAod3JpdGFibGUpIHtcbiAgICBzdHJlYW0uZW5kKClcbiAgfVxufVxuUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgb3B0cykge1xuICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpXG59XG5sZXQgd2ViU3RyZWFtc0FkYXB0ZXJzXG5cbi8vIExhenkgdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlc1xuZnVuY3Rpb24gbGF6eVdlYlN0cmVhbXMoKSB7XG4gIGlmICh3ZWJTdHJlYW1zQWRhcHRlcnMgPT09IHVuZGVmaW5lZCkgd2ViU3RyZWFtc0FkYXB0ZXJzID0ge31cbiAgcmV0dXJuIHdlYlN0cmVhbXNBZGFwdGVyc1xufVxuUmVhZGFibGUuZnJvbVdlYiA9IGZ1bmN0aW9uIChyZWFkYWJsZVN0cmVhbSwgb3B0aW9ucykge1xuICByZXR1cm4gbGF6eVdlYlN0cmVhbXMoKS5uZXdTdHJlYW1SZWFkYWJsZUZyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgb3B0aW9ucylcbn1cblJlYWRhYmxlLnRvV2ViID0gZnVuY3Rpb24gKHN0cmVhbVJlYWRhYmxlLCBvcHRpb25zKSB7XG4gIHJldHVybiBsYXp5V2ViU3RyZWFtcygpLm5ld1JlYWRhYmxlU3RyZWFtRnJvbVN0cmVhbVJlYWRhYmxlKHN0cmVhbVJlYWRhYmxlLCBvcHRpb25zKVxufVxuUmVhZGFibGUud3JhcCA9IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMpIHtcbiAgdmFyIF9yZWYsIF9zcmMkcmVhZGFibGVPYmplY3RNb1xuICByZXR1cm4gbmV3IFJlYWRhYmxlKHtcbiAgICBvYmplY3RNb2RlOlxuICAgICAgKF9yZWYgPVxuICAgICAgICAoX3NyYyRyZWFkYWJsZU9iamVjdE1vID0gc3JjLnJlYWRhYmxlT2JqZWN0TW9kZSkgIT09IG51bGwgJiYgX3NyYyRyZWFkYWJsZU9iamVjdE1vICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IF9zcmMkcmVhZGFibGVPYmplY3RNb1xuICAgICAgICAgIDogc3JjLm9iamVjdE1vZGUpICE9PSBudWxsICYmIF9yZWYgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IF9yZWZcbiAgICAgICAgOiB0cnVlLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgICBkZXN0cm95SW1wbC5kZXN0cm95ZXIoc3JjLCBlcnIpXG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfVxuICB9KS53cmFwKHNyYylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/readable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/state.js":
/*!********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/state.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { MathFloor, NumberIsInteger } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst { validateInteger } = __webpack_require__(/*! ../validators */ \"(ssr)/./node_modules/readable-stream/lib/internal/validators.js\")\nconst { ERR_INVALID_ARG_VALUE } = (__webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\").codes)\nlet defaultHighWaterMarkBytes = 16 * 1024\nlet defaultHighWaterMarkObjectMode = 16\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null\n}\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes\n}\nfunction setDefaultHighWaterMark(objectMode, value) {\n  validateInteger(value, 'value', 0)\n  if (objectMode) {\n    defaultHighWaterMarkObjectMode = value\n  } else {\n    defaultHighWaterMarkBytes = value\n  }\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey)\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark'\n      throw new ERR_INVALID_ARG_VALUE(name, hwm)\n    }\n    return MathFloor(hwm)\n  }\n\n  // Default value\n  return getDefaultHighWaterMark(state.objectMode)\n}\nmodule.exports = {\n  getHighWaterMark,\n  getDefaultHighWaterMark,\n  setDefaultHighWaterMark\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsNkJBQTZCLEVBQUUsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDdkUsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLHNGQUFlO0FBQ25ELFFBQVEsd0JBQXdCLEVBQUUsK0dBQWtDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxVQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldGgtbG9uZG9uLTIwMjQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzP2M5M2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgTWF0aEZsb29yLCBOdW1iZXJJc0ludGVnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgeyB2YWxpZGF0ZUludGVnZXIgfSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKVxuY29uc3QgeyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJykuY29kZXNcbmxldCBkZWZhdWx0SGlnaFdhdGVyTWFya0J5dGVzID0gMTYgKiAxMDI0XG5sZXQgZGVmYXVsdEhpZ2hXYXRlck1hcmtPYmplY3RNb2RlID0gMTZcbmZ1bmN0aW9uIGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpIHtcbiAgcmV0dXJuIG9wdGlvbnMuaGlnaFdhdGVyTWFyayAhPSBudWxsID8gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIDogaXNEdXBsZXggPyBvcHRpb25zW2R1cGxleEtleV0gOiBudWxsXG59XG5mdW5jdGlvbiBnZXREZWZhdWx0SGlnaFdhdGVyTWFyayhvYmplY3RNb2RlKSB7XG4gIHJldHVybiBvYmplY3RNb2RlID8gZGVmYXVsdEhpZ2hXYXRlck1hcmtPYmplY3RNb2RlIDogZGVmYXVsdEhpZ2hXYXRlck1hcmtCeXRlc1xufVxuZnVuY3Rpb24gc2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsob2JqZWN0TW9kZSwgdmFsdWUpIHtcbiAgdmFsaWRhdGVJbnRlZ2VyKHZhbHVlLCAndmFsdWUnLCAwKVxuICBpZiAob2JqZWN0TW9kZSkge1xuICAgIGRlZmF1bHRIaWdoV2F0ZXJNYXJrT2JqZWN0TW9kZSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgZGVmYXVsdEhpZ2hXYXRlck1hcmtCeXRlcyA9IHZhbHVlXG4gIH1cbn1cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgY29uc3QgaHdtID0gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSlcbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXJJc0ludGVnZXIoaHdtKSB8fCBod20gPCAwKSB7XG4gICAgICBjb25zdCBuYW1lID0gaXNEdXBsZXggPyBgb3B0aW9ucy4ke2R1cGxleEtleX1gIDogJ29wdGlvbnMuaGlnaFdhdGVyTWFyaydcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUobmFtZSwgaHdtKVxuICAgIH1cbiAgICByZXR1cm4gTWF0aEZsb29yKGh3bSlcbiAgfVxuXG4gIC8vIERlZmF1bHQgdmFsdWVcbiAgcmV0dXJuIGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrKHN0YXRlLm9iamVjdE1vZGUpXG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0SGlnaFdhdGVyTWFyayxcbiAgZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmssXG4gIHNldERlZmF1bHRIaWdoV2F0ZXJNYXJrXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/transform.js":
/*!************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/transform.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nconst { ObjectSetPrototypeOf, Symbol } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nmodule.exports = Transform\nconst { ERR_METHOD_NOT_IMPLEMENTED } = (__webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\").codes)\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/duplex.js\")\nconst { getHighWaterMark } = __webpack_require__(/*! ./state */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/state.js\")\nObjectSetPrototypeOf(Transform.prototype, Duplex.prototype)\nObjectSetPrototypeOf(Transform, Duplex)\nconst kCallback = Symbol('kCallback')\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options)\n\n  // TODO (ronag): This should preferably always be\n  // applied but would be semver-major. Or even better;\n  // make Transform a Readable with the Writable interface.\n  const readableHighWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', true) : null\n  if (readableHighWaterMark === 0) {\n    // A Duplex will buffer both on the writable and readable side while\n    // a Transform just wants to buffer hwm number of elements. To avoid\n    // buffering twice we disable buffering on the writable side.\n    options = {\n      ...options,\n      highWaterMark: null,\n      readableHighWaterMark,\n      // TODO (ronag): 0 is not optimal since we have\n      // a \"bug\" where we check needDrain before calling _write and not after.\n      // Refs: https://github.com/nodejs/node/pull/32887\n      // Refs: https://github.com/nodejs/node/pull/35941\n      writableHighWaterMark: options.writableHighWaterMark || 0\n    }\n  }\n  Duplex.call(this, options)\n\n  // We have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false\n  this[kCallback] = null\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform\n    if (typeof options.flush === 'function') this._flush = options.flush\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  // Backwards compat. Some Transform streams incorrectly implement _final\n  // instead of or in addition to _flush. By using 'prefinish' instead of\n  // implementing _final we continue supporting this unfortunate use case.\n  this.on('prefinish', prefinish)\n}\nfunction final(cb) {\n  if (typeof this._flush === 'function' && !this.destroyed) {\n    this._flush((er, data) => {\n      if (er) {\n        if (cb) {\n          cb(er)\n        } else {\n          this.destroy(er)\n        }\n        return\n      }\n      if (data != null) {\n        this.push(data)\n      }\n      this.push(null)\n      if (cb) {\n        cb()\n      }\n    })\n  } else {\n    this.push(null)\n    if (cb) {\n      cb()\n    }\n  }\n}\nfunction prefinish() {\n  if (this._final !== final) {\n    final.call(this)\n  }\n}\nTransform.prototype._final = final\nTransform.prototype._transform = function (chunk, encoding, callback) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()')\n}\nTransform.prototype._write = function (chunk, encoding, callback) {\n  const rState = this._readableState\n  const wState = this._writableState\n  const length = rState.length\n  this._transform(chunk, encoding, (err, val) => {\n    if (err) {\n      callback(err)\n      return\n    }\n    if (val != null) {\n      this.push(val)\n    }\n    if (\n      wState.ended ||\n      // Backwards compat.\n      length === rState.length ||\n      // Backwards compat.\n      rState.length < rState.highWaterMark\n    ) {\n      callback()\n    } else {\n      this[kCallback] = callback\n    }\n  })\n}\nTransform.prototype._read = function () {\n  if (this[kCallback]) {\n    const callback = this[kCallback]\n    this[kCallback] = null\n    callback()\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3RyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLFFBQVEsK0JBQStCLEVBQUUsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDekU7QUFDQSxRQUFRLDZCQUE2QixFQUFFLCtHQUFrQztBQUN6RSxlQUFlLG1CQUFPLENBQUMscUZBQVU7QUFDakMsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLG1GQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXRoLWxvbmRvbi0yMDI0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy90cmFuc2Zvcm0uanM/ODVkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBPYmplY3RTZXRQcm90b3R5cGVPZiwgU3ltYm9sIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtXG5jb25zdCB7IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpLmNvZGVzXG5jb25zdCBEdXBsZXggPSByZXF1aXJlKCcuL2R1cGxleCcpXG5jb25zdCB7IGdldEhpZ2hXYXRlck1hcmsgfSA9IHJlcXVpcmUoJy4vc3RhdGUnKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoVHJhbnNmb3JtLnByb3RvdHlwZSwgRHVwbGV4LnByb3RvdHlwZSlcbk9iamVjdFNldFByb3RvdHlwZU9mKFRyYW5zZm9ybSwgRHVwbGV4KVxuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdrQ2FsbGJhY2snKVxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpXG5cbiAgLy8gVE9ETyAocm9uYWcpOiBUaGlzIHNob3VsZCBwcmVmZXJhYmx5IGFsd2F5cyBiZVxuICAvLyBhcHBsaWVkIGJ1dCB3b3VsZCBiZSBzZW12ZXItbWFqb3IuIE9yIGV2ZW4gYmV0dGVyO1xuICAvLyBtYWtlIFRyYW5zZm9ybSBhIFJlYWRhYmxlIHdpdGggdGhlIFdyaXRhYmxlIGludGVyZmFjZS5cbiAgY29uc3QgcmVhZGFibGVIaWdoV2F0ZXJNYXJrID0gb3B0aW9ucyA/IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHRydWUpIDogbnVsbFxuICBpZiAocmVhZGFibGVIaWdoV2F0ZXJNYXJrID09PSAwKSB7XG4gICAgLy8gQSBEdXBsZXggd2lsbCBidWZmZXIgYm90aCBvbiB0aGUgd3JpdGFibGUgYW5kIHJlYWRhYmxlIHNpZGUgd2hpbGVcbiAgICAvLyBhIFRyYW5zZm9ybSBqdXN0IHdhbnRzIHRvIGJ1ZmZlciBod20gbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyBhdm9pZFxuICAgIC8vIGJ1ZmZlcmluZyB0d2ljZSB3ZSBkaXNhYmxlIGJ1ZmZlcmluZyBvbiB0aGUgd3JpdGFibGUgc2lkZS5cbiAgICBvcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhpZ2hXYXRlck1hcms6IG51bGwsXG4gICAgICByZWFkYWJsZUhpZ2hXYXRlck1hcmssXG4gICAgICAvLyBUT0RPIChyb25hZyk6IDAgaXMgbm90IG9wdGltYWwgc2luY2Ugd2UgaGF2ZVxuICAgICAgLy8gYSBcImJ1Z1wiIHdoZXJlIHdlIGNoZWNrIG5lZWREcmFpbiBiZWZvcmUgY2FsbGluZyBfd3JpdGUgYW5kIG5vdCBhZnRlci5cbiAgICAgIC8vIFJlZnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMyODg3XG4gICAgICAvLyBSZWZzOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zNTk0MVxuICAgICAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrOiBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyayB8fCAwXG4gICAgfVxuICB9XG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpXG5cbiAgLy8gV2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZVxuICB0aGlzW2tDYWxsYmFja10gPSBudWxsXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaFxuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICAvLyBCYWNrd2FyZHMgY29tcGF0LiBTb21lIFRyYW5zZm9ybSBzdHJlYW1zIGluY29ycmVjdGx5IGltcGxlbWVudCBfZmluYWxcbiAgLy8gaW5zdGVhZCBvZiBvciBpbiBhZGRpdGlvbiB0byBfZmx1c2guIEJ5IHVzaW5nICdwcmVmaW5pc2gnIGluc3RlYWQgb2ZcbiAgLy8gaW1wbGVtZW50aW5nIF9maW5hbCB3ZSBjb250aW51ZSBzdXBwb3J0aW5nIHRoaXMgdW5mb3J0dW5hdGUgdXNlIGNhc2UuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaClcbn1cbmZ1bmN0aW9uIGZpbmFsKGNiKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgdGhpcy5fZmx1c2goKGVyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IoZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KGVyKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnB1c2goZGF0YSlcbiAgICAgIH1cbiAgICAgIHRoaXMucHVzaChudWxsKVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHRoaXMucHVzaChudWxsKVxuICAgIGlmIChjYikge1xuICAgICAgY2IoKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICBpZiAodGhpcy5fZmluYWwgIT09IGZpbmFsKSB7XG4gICAgZmluYWwuY2FsbCh0aGlzKVxuICB9XG59XG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9maW5hbCA9IGZpbmFsXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB0aHJvdyBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ190cmFuc2Zvcm0oKScpXG59XG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJTdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGVcbiAgY29uc3Qgd1N0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuICBjb25zdCBsZW5ndGggPSByU3RhdGUubGVuZ3RoXG4gIHRoaXMuX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIChlcnIsIHZhbCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgIHRoaXMucHVzaCh2YWwpXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHdTdGF0ZS5lbmRlZCB8fFxuICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdC5cbiAgICAgIGxlbmd0aCA9PT0gclN0YXRlLmxlbmd0aCB8fFxuICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdC5cbiAgICAgIHJTdGF0ZS5sZW5ndGggPCByU3RhdGUuaGlnaFdhdGVyTWFya1xuICAgICkge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tDYWxsYmFja10gPSBjYWxsYmFja1xuICAgIH1cbiAgfSlcbn1cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzW2tDYWxsYmFja10pIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXNba0NhbGxiYWNrXVxuICAgIHRoaXNba0NhbGxiYWNrXSA9IG51bGxcbiAgICBjYWxsYmFjaygpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/transform.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/utils.js":
/*!********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/utils.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { SymbolAsyncIterator, SymbolIterator, SymbolFor } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\n\n// We need to use SymbolFor to make these globally available\n// for interopt with readable-stream, i.e. readable-stream\n// and node core needs to be able to read/write private state\n// from each other for proper interoperability.\nconst kIsDestroyed = SymbolFor('nodejs.stream.destroyed')\nconst kIsErrored = SymbolFor('nodejs.stream.errored')\nconst kIsReadable = SymbolFor('nodejs.stream.readable')\nconst kIsWritable = SymbolFor('nodejs.stream.writable')\nconst kIsDisturbed = SymbolFor('nodejs.stream.disturbed')\nconst kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise')\nconst kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction')\nfunction isReadableNodeStream(obj, strict = false) {\n  var _obj$_readableState\n  return !!(\n    (\n      obj &&\n      typeof obj.pipe === 'function' &&\n      typeof obj.on === 'function' &&\n      (!strict || (typeof obj.pause === 'function' && typeof obj.resume === 'function')) &&\n      (!obj._writableState ||\n        ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined\n          ? undefined\n          : _obj$_readableState.readable) !== false) &&\n      // Duplex\n      (!obj._writableState || obj._readableState)\n    ) // Writable has .pipe.\n  )\n}\n\nfunction isWritableNodeStream(obj) {\n  var _obj$_writableState\n  return !!(\n    (\n      obj &&\n      typeof obj.write === 'function' &&\n      typeof obj.on === 'function' &&\n      (!obj._readableState ||\n        ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined\n          ? undefined\n          : _obj$_writableState.writable) !== false)\n    ) // Duplex\n  )\n}\n\nfunction isDuplexNodeStream(obj) {\n  return !!(\n    obj &&\n    typeof obj.pipe === 'function' &&\n    obj._readableState &&\n    typeof obj.on === 'function' &&\n    typeof obj.write === 'function'\n  )\n}\nfunction isNodeStream(obj) {\n  return (\n    obj &&\n    (obj._readableState ||\n      obj._writableState ||\n      (typeof obj.write === 'function' && typeof obj.on === 'function') ||\n      (typeof obj.pipe === 'function' && typeof obj.on === 'function'))\n  )\n}\nfunction isReadableStream(obj) {\n  return !!(\n    obj &&\n    !isNodeStream(obj) &&\n    typeof obj.pipeThrough === 'function' &&\n    typeof obj.getReader === 'function' &&\n    typeof obj.cancel === 'function'\n  )\n}\nfunction isWritableStream(obj) {\n  return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === 'function' && typeof obj.abort === 'function')\n}\nfunction isTransformStream(obj) {\n  return !!(obj && !isNodeStream(obj) && typeof obj.readable === 'object' && typeof obj.writable === 'object')\n}\nfunction isWebStream(obj) {\n  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj)\n}\nfunction isIterable(obj, isAsync) {\n  if (obj == null) return false\n  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function'\n  if (isAsync === false) return typeof obj[SymbolIterator] === 'function'\n  return typeof obj[SymbolAsyncIterator] === 'function' || typeof obj[SymbolIterator] === 'function'\n}\nfunction isDestroyed(stream) {\n  if (!isNodeStream(stream)) return null\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const state = wState || rState\n  return !!(stream.destroyed || stream[kIsDestroyed] || (state !== null && state !== undefined && state.destroyed))\n}\n\n// Have been end():d.\nfunction isWritableEnded(stream) {\n  if (!isWritableNodeStream(stream)) return null\n  if (stream.writableEnded === true) return true\n  const wState = stream._writableState\n  if (wState !== null && wState !== undefined && wState.errored) return false\n  if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== 'boolean') return null\n  return wState.ended\n}\n\n// Have emitted 'finish'.\nfunction isWritableFinished(stream, strict) {\n  if (!isWritableNodeStream(stream)) return null\n  if (stream.writableFinished === true) return true\n  const wState = stream._writableState\n  if (wState !== null && wState !== undefined && wState.errored) return false\n  if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== 'boolean') return null\n  return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0))\n}\n\n// Have been push(null):d.\nfunction isReadableEnded(stream) {\n  if (!isReadableNodeStream(stream)) return null\n  if (stream.readableEnded === true) return true\n  const rState = stream._readableState\n  if (!rState || rState.errored) return false\n  if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== 'boolean') return null\n  return rState.ended\n}\n\n// Have emitted 'end'.\nfunction isReadableFinished(stream, strict) {\n  if (!isReadableNodeStream(stream)) return null\n  const rState = stream._readableState\n  if (rState !== null && rState !== undefined && rState.errored) return false\n  if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== 'boolean') return null\n  return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0))\n}\nfunction isReadable(stream) {\n  if (stream && stream[kIsReadable] != null) return stream[kIsReadable]\n  if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== 'boolean') return null\n  if (isDestroyed(stream)) return false\n  return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream)\n}\nfunction isWritable(stream) {\n  if (stream && stream[kIsWritable] != null) return stream[kIsWritable]\n  if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== 'boolean') return null\n  if (isDestroyed(stream)) return false\n  return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream)\n}\nfunction isFinished(stream, opts) {\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (isDestroyed(stream)) {\n    return true\n  }\n  if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {\n    return false\n  }\n  if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {\n    return false\n  }\n  return true\n}\nfunction isWritableErrored(stream) {\n  var _stream$_writableStat, _stream$_writableStat2\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (stream.writableErrored) {\n    return stream.writableErrored\n  }\n  return (_stream$_writableStat =\n    (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined\n      ? undefined\n      : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined\n    ? _stream$_writableStat\n    : null\n}\nfunction isReadableErrored(stream) {\n  var _stream$_readableStat, _stream$_readableStat2\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (stream.readableErrored) {\n    return stream.readableErrored\n  }\n  return (_stream$_readableStat =\n    (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined\n      ? undefined\n      : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined\n    ? _stream$_readableStat\n    : null\n}\nfunction isClosed(stream) {\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (typeof stream.closed === 'boolean') {\n    return stream.closed\n  }\n  const wState = stream._writableState\n  const rState = stream._readableState\n  if (\n    typeof (wState === null || wState === undefined ? undefined : wState.closed) === 'boolean' ||\n    typeof (rState === null || rState === undefined ? undefined : rState.closed) === 'boolean'\n  ) {\n    return (\n      (wState === null || wState === undefined ? undefined : wState.closed) ||\n      (rState === null || rState === undefined ? undefined : rState.closed)\n    )\n  }\n  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {\n    return stream._closed\n  }\n  return null\n}\nfunction isOutgoingMessage(stream) {\n  return (\n    typeof stream._closed === 'boolean' &&\n    typeof stream._defaultKeepAlive === 'boolean' &&\n    typeof stream._removedConnection === 'boolean' &&\n    typeof stream._removedContLen === 'boolean'\n  )\n}\nfunction isServerResponse(stream) {\n  return typeof stream._sent100 === 'boolean' && isOutgoingMessage(stream)\n}\nfunction isServerRequest(stream) {\n  var _stream$req\n  return (\n    typeof stream._consuming === 'boolean' &&\n    typeof stream._dumped === 'boolean' &&\n    ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) ===\n      undefined\n  )\n}\nfunction willEmitClose(stream) {\n  if (!isNodeStream(stream)) return null\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const state = wState || rState\n  return (\n    (!state && isServerResponse(stream)) || !!(state && state.autoDestroy && state.emitClose && state.closed === false)\n  )\n}\nfunction isDisturbed(stream) {\n  var _stream$kIsDisturbed\n  return !!(\n    stream &&\n    ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined\n      ? _stream$kIsDisturbed\n      : stream.readableDidRead || stream.readableAborted)\n  )\n}\nfunction isErrored(stream) {\n  var _ref,\n    _ref2,\n    _ref3,\n    _ref4,\n    _ref5,\n    _stream$kIsErrored,\n    _stream$_readableStat3,\n    _stream$_writableStat3,\n    _stream$_readableStat4,\n    _stream$_writableStat4\n  return !!(\n    stream &&\n    ((_ref =\n      (_ref2 =\n        (_ref3 =\n          (_ref4 =\n            (_ref5 =\n              (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined\n                ? _stream$kIsErrored\n                : stream.readableErrored) !== null && _ref5 !== undefined\n              ? _ref5\n              : stream.writableErrored) !== null && _ref4 !== undefined\n            ? _ref4\n            : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined\n            ? undefined\n            : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined\n          ? _ref3\n          : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined\n          ? undefined\n          : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined\n        ? _ref2\n        : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined\n        ? undefined\n        : _stream$_readableStat4.errored) !== null && _ref !== undefined\n      ? _ref\n      : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined\n      ? undefined\n      : _stream$_writableStat4.errored)\n  )\n}\nmodule.exports = {\n  isDestroyed,\n  kIsDestroyed,\n  isDisturbed,\n  kIsDisturbed,\n  isErrored,\n  kIsErrored,\n  isReadable,\n  kIsReadable,\n  kIsClosedPromise,\n  kControllerErrorFunction,\n  kIsWritable,\n  isClosed,\n  isDuplexNodeStream,\n  isFinished,\n  isIterable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableEnded,\n  isReadableFinished,\n  isReadableErrored,\n  isNodeStream,\n  isWebStream,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableEnded,\n  isWritableFinished,\n  isWritableErrored,\n  isServerRequest,\n  isServerResponse,\n  willEmitClose,\n  isTransformStream\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsaURBQWlELEVBQUUsbUJBQU8sQ0FBQyw0RkFBd0I7O0FBRTNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXRoLWxvbmRvbi0yMDI0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy91dGlscy5qcz80NzZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFN5bWJvbEFzeW5jSXRlcmF0b3IsIFN5bWJvbEl0ZXJhdG9yLCBTeW1ib2xGb3IgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuXG4vLyBXZSBuZWVkIHRvIHVzZSBTeW1ib2xGb3IgdG8gbWFrZSB0aGVzZSBnbG9iYWxseSBhdmFpbGFibGVcbi8vIGZvciBpbnRlcm9wdCB3aXRoIHJlYWRhYmxlLXN0cmVhbSwgaS5lLiByZWFkYWJsZS1zdHJlYW1cbi8vIGFuZCBub2RlIGNvcmUgbmVlZHMgdG8gYmUgYWJsZSB0byByZWFkL3dyaXRlIHByaXZhdGUgc3RhdGVcbi8vIGZyb20gZWFjaCBvdGhlciBmb3IgcHJvcGVyIGludGVyb3BlcmFiaWxpdHkuXG5jb25zdCBrSXNEZXN0cm95ZWQgPSBTeW1ib2xGb3IoJ25vZGVqcy5zdHJlYW0uZGVzdHJveWVkJylcbmNvbnN0IGtJc0Vycm9yZWQgPSBTeW1ib2xGb3IoJ25vZGVqcy5zdHJlYW0uZXJyb3JlZCcpXG5jb25zdCBrSXNSZWFkYWJsZSA9IFN5bWJvbEZvcignbm9kZWpzLnN0cmVhbS5yZWFkYWJsZScpXG5jb25zdCBrSXNXcml0YWJsZSA9IFN5bWJvbEZvcignbm9kZWpzLnN0cmVhbS53cml0YWJsZScpXG5jb25zdCBrSXNEaXN0dXJiZWQgPSBTeW1ib2xGb3IoJ25vZGVqcy5zdHJlYW0uZGlzdHVyYmVkJylcbmNvbnN0IGtJc0Nsb3NlZFByb21pc2UgPSBTeW1ib2xGb3IoJ25vZGVqcy53ZWJzdHJlYW0uaXNDbG9zZWRQcm9taXNlJylcbmNvbnN0IGtDb250cm9sbGVyRXJyb3JGdW5jdGlvbiA9IFN5bWJvbEZvcignbm9kZWpzLndlYnN0cmVhbS5jb250cm9sbGVyRXJyb3JGdW5jdGlvbicpXG5mdW5jdGlvbiBpc1JlYWRhYmxlTm9kZVN0cmVhbShvYmosIHN0cmljdCA9IGZhbHNlKSB7XG4gIHZhciBfb2JqJF9yZWFkYWJsZVN0YXRlXG4gIHJldHVybiAhIShcbiAgICAoXG4gICAgICBvYmogJiZcbiAgICAgIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIG9iai5vbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKCFzdHJpY3QgfHwgKHR5cGVvZiBvYmoucGF1c2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5yZXN1bWUgPT09ICdmdW5jdGlvbicpKSAmJlxuICAgICAgKCFvYmouX3dyaXRhYmxlU3RhdGUgfHxcbiAgICAgICAgKChfb2JqJF9yZWFkYWJsZVN0YXRlID0gb2JqLl9yZWFkYWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfb2JqJF9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogX29iaiRfcmVhZGFibGVTdGF0ZS5yZWFkYWJsZSkgIT09IGZhbHNlKSAmJlxuICAgICAgLy8gRHVwbGV4XG4gICAgICAoIW9iai5fd3JpdGFibGVTdGF0ZSB8fCBvYmouX3JlYWRhYmxlU3RhdGUpXG4gICAgKSAvLyBXcml0YWJsZSBoYXMgLnBpcGUuXG4gIClcbn1cblxuZnVuY3Rpb24gaXNXcml0YWJsZU5vZGVTdHJlYW0ob2JqKSB7XG4gIHZhciBfb2JqJF93cml0YWJsZVN0YXRlXG4gIHJldHVybiAhIShcbiAgICAoXG4gICAgICBvYmogJiZcbiAgICAgIHR5cGVvZiBvYmoud3JpdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICghb2JqLl9yZWFkYWJsZVN0YXRlIHx8XG4gICAgICAgICgoX29iaiRfd3JpdGFibGVTdGF0ZSA9IG9iai5fd3JpdGFibGVTdGF0ZSkgPT09IG51bGwgfHwgX29iaiRfd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICA6IF9vYmokX3dyaXRhYmxlU3RhdGUud3JpdGFibGUpICE9PSBmYWxzZSlcbiAgICApIC8vIER1cGxleFxuICApXG59XG5cbmZ1bmN0aW9uIGlzRHVwbGV4Tm9kZVN0cmVhbShvYmopIHtcbiAgcmV0dXJuICEhKFxuICAgIG9iaiAmJlxuICAgIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIG9iai5fcmVhZGFibGVTdGF0ZSAmJlxuICAgIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqLndyaXRlID09PSAnZnVuY3Rpb24nXG4gIClcbn1cbmZ1bmN0aW9uIGlzTm9kZVN0cmVhbShvYmopIHtcbiAgcmV0dXJuIChcbiAgICBvYmogJiZcbiAgICAob2JqLl9yZWFkYWJsZVN0YXRlIHx8XG4gICAgICBvYmouX3dyaXRhYmxlU3RhdGUgfHxcbiAgICAgICh0eXBlb2Ygb2JqLndyaXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAodHlwZW9mIG9iai5waXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbicpKVxuICApXG59XG5mdW5jdGlvbiBpc1JlYWRhYmxlU3RyZWFtKG9iaikge1xuICByZXR1cm4gISEoXG4gICAgb2JqICYmXG4gICAgIWlzTm9kZVN0cmVhbShvYmopICYmXG4gICAgdHlwZW9mIG9iai5waXBlVGhyb3VnaCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmouZ2V0UmVhZGVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iai5jYW5jZWwgPT09ICdmdW5jdGlvbidcbiAgKVxufVxuZnVuY3Rpb24gaXNXcml0YWJsZVN0cmVhbShvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAmJiAhaXNOb2RlU3RyZWFtKG9iaikgJiYgdHlwZW9mIG9iai5nZXRXcml0ZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5hYm9ydCA9PT0gJ2Z1bmN0aW9uJylcbn1cbmZ1bmN0aW9uIGlzVHJhbnNmb3JtU3RyZWFtKG9iaikge1xuICByZXR1cm4gISEob2JqICYmICFpc05vZGVTdHJlYW0ob2JqKSAmJiB0eXBlb2Ygb2JqLnJlYWRhYmxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLndyaXRhYmxlID09PSAnb2JqZWN0Jylcbn1cbmZ1bmN0aW9uIGlzV2ViU3RyZWFtKG9iaikge1xuICByZXR1cm4gaXNSZWFkYWJsZVN0cmVhbShvYmopIHx8IGlzV3JpdGFibGVTdHJlYW0ob2JqKSB8fCBpc1RyYW5zZm9ybVN0cmVhbShvYmopXG59XG5mdW5jdGlvbiBpc0l0ZXJhYmxlKG9iaiwgaXNBc3luYykge1xuICBpZiAob2JqID09IG51bGwpIHJldHVybiBmYWxzZVxuICBpZiAoaXNBc3luYyA9PT0gdHJ1ZSkgcmV0dXJuIHR5cGVvZiBvYmpbU3ltYm9sQXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbidcbiAgaWYgKGlzQXN5bmMgPT09IGZhbHNlKSByZXR1cm4gdHlwZW9mIG9ialtTeW1ib2xJdGVyYXRvcl0gPT09ICdmdW5jdGlvbidcbiAgcmV0dXJuIHR5cGVvZiBvYmpbU3ltYm9sQXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9ialtTeW1ib2xJdGVyYXRvcl0gPT09ICdmdW5jdGlvbidcbn1cbmZ1bmN0aW9uIGlzRGVzdHJveWVkKHN0cmVhbSkge1xuICBpZiAoIWlzTm9kZVN0cmVhbShzdHJlYW0pKSByZXR1cm4gbnVsbFxuICBjb25zdCB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgY29uc3QgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHN0YXRlID0gd1N0YXRlIHx8IHJTdGF0ZVxuICByZXR1cm4gISEoc3RyZWFtLmRlc3Ryb3llZCB8fCBzdHJlYW1ba0lzRGVzdHJveWVkXSB8fCAoc3RhdGUgIT09IG51bGwgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS5kZXN0cm95ZWQpKVxufVxuXG4vLyBIYXZlIGJlZW4gZW5kKCk6ZC5cbmZ1bmN0aW9uIGlzV3JpdGFibGVFbmRlZChzdHJlYW0pIHtcbiAgaWYgKCFpc1dyaXRhYmxlTm9kZVN0cmVhbShzdHJlYW0pKSByZXR1cm4gbnVsbFxuICBpZiAoc3RyZWFtLndyaXRhYmxlRW5kZWQgPT09IHRydWUpIHJldHVybiB0cnVlXG4gIGNvbnN0IHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBpZiAod1N0YXRlICE9PSBudWxsICYmIHdTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHdTdGF0ZS5lcnJvcmVkKSByZXR1cm4gZmFsc2VcbiAgaWYgKHR5cGVvZiAod1N0YXRlID09PSBudWxsIHx8IHdTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogd1N0YXRlLmVuZGVkKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICByZXR1cm4gd1N0YXRlLmVuZGVkXG59XG5cbi8vIEhhdmUgZW1pdHRlZCAnZmluaXNoJy5cbmZ1bmN0aW9uIGlzV3JpdGFibGVGaW5pc2hlZChzdHJlYW0sIHN0cmljdCkge1xuICBpZiAoIWlzV3JpdGFibGVOb2RlU3RyZWFtKHN0cmVhbSkpIHJldHVybiBudWxsXG4gIGlmIChzdHJlYW0ud3JpdGFibGVGaW5pc2hlZCA9PT0gdHJ1ZSkgcmV0dXJuIHRydWVcbiAgY29uc3Qgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGlmICh3U3RhdGUgIT09IG51bGwgJiYgd1N0YXRlICE9PSB1bmRlZmluZWQgJiYgd1N0YXRlLmVycm9yZWQpIHJldHVybiBmYWxzZVxuICBpZiAodHlwZW9mICh3U3RhdGUgPT09IG51bGwgfHwgd1N0YXRlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB3U3RhdGUuZmluaXNoZWQpICE9PSAnYm9vbGVhbicpIHJldHVybiBudWxsXG4gIHJldHVybiAhISh3U3RhdGUuZmluaXNoZWQgfHwgKHN0cmljdCA9PT0gZmFsc2UgJiYgd1N0YXRlLmVuZGVkID09PSB0cnVlICYmIHdTdGF0ZS5sZW5ndGggPT09IDApKVxufVxuXG4vLyBIYXZlIGJlZW4gcHVzaChudWxsKTpkLlxuZnVuY3Rpb24gaXNSZWFkYWJsZUVuZGVkKHN0cmVhbSkge1xuICBpZiAoIWlzUmVhZGFibGVOb2RlU3RyZWFtKHN0cmVhbSkpIHJldHVybiBudWxsXG4gIGlmIChzdHJlYW0ucmVhZGFibGVFbmRlZCA9PT0gdHJ1ZSkgcmV0dXJuIHRydWVcbiAgY29uc3QgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGlmICghclN0YXRlIHx8IHJTdGF0ZS5lcnJvcmVkKSByZXR1cm4gZmFsc2VcbiAgaWYgKHR5cGVvZiAoclN0YXRlID09PSBudWxsIHx8IHJTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogclN0YXRlLmVuZGVkKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICByZXR1cm4gclN0YXRlLmVuZGVkXG59XG5cbi8vIEhhdmUgZW1pdHRlZCAnZW5kJy5cbmZ1bmN0aW9uIGlzUmVhZGFibGVGaW5pc2hlZChzdHJlYW0sIHN0cmljdCkge1xuICBpZiAoIWlzUmVhZGFibGVOb2RlU3RyZWFtKHN0cmVhbSkpIHJldHVybiBudWxsXG4gIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBpZiAoclN0YXRlICE9PSBudWxsICYmIHJTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHJTdGF0ZS5lcnJvcmVkKSByZXR1cm4gZmFsc2VcbiAgaWYgKHR5cGVvZiAoclN0YXRlID09PSBudWxsIHx8IHJTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogclN0YXRlLmVuZEVtaXR0ZWQpICE9PSAnYm9vbGVhbicpIHJldHVybiBudWxsXG4gIHJldHVybiAhIShyU3RhdGUuZW5kRW1pdHRlZCB8fCAoc3RyaWN0ID09PSBmYWxzZSAmJiByU3RhdGUuZW5kZWQgPT09IHRydWUgJiYgclN0YXRlLmxlbmd0aCA9PT0gMCkpXG59XG5mdW5jdGlvbiBpc1JlYWRhYmxlKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtICYmIHN0cmVhbVtrSXNSZWFkYWJsZV0gIT0gbnVsbCkgcmV0dXJuIHN0cmVhbVtrSXNSZWFkYWJsZV1cbiAgaWYgKHR5cGVvZiAoc3RyZWFtID09PSBudWxsIHx8IHN0cmVhbSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc3RyZWFtLnJlYWRhYmxlKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICBpZiAoaXNEZXN0cm95ZWQoc3RyZWFtKSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0pICYmIHN0cmVhbS5yZWFkYWJsZSAmJiAhaXNSZWFkYWJsZUZpbmlzaGVkKHN0cmVhbSlcbn1cbmZ1bmN0aW9uIGlzV3JpdGFibGUoc3RyZWFtKSB7XG4gIGlmIChzdHJlYW0gJiYgc3RyZWFtW2tJc1dyaXRhYmxlXSAhPSBudWxsKSByZXR1cm4gc3RyZWFtW2tJc1dyaXRhYmxlXVxuICBpZiAodHlwZW9mIChzdHJlYW0gPT09IG51bGwgfHwgc3RyZWFtID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzdHJlYW0ud3JpdGFibGUpICE9PSAnYm9vbGVhbicpIHJldHVybiBudWxsXG4gIGlmIChpc0Rlc3Ryb3llZChzdHJlYW0pKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGlzV3JpdGFibGVOb2RlU3RyZWFtKHN0cmVhbSkgJiYgc3RyZWFtLndyaXRhYmxlICYmICFpc1dyaXRhYmxlRW5kZWQoc3RyZWFtKVxufVxuZnVuY3Rpb24gaXNGaW5pc2hlZChzdHJlYW0sIG9wdHMpIHtcbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKGlzRGVzdHJveWVkKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmICgob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRzLnJlYWRhYmxlKSAhPT0gZmFsc2UgJiYgaXNSZWFkYWJsZShzdHJlYW0pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdHMud3JpdGFibGUpICE9PSBmYWxzZSAmJiBpc1dyaXRhYmxlKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuZnVuY3Rpb24gaXNXcml0YWJsZUVycm9yZWQoc3RyZWFtKSB7XG4gIHZhciBfc3RyZWFtJF93cml0YWJsZVN0YXQsIF9zdHJlYW0kX3dyaXRhYmxlU3RhdDJcbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKHN0cmVhbS53cml0YWJsZUVycm9yZWQpIHtcbiAgICByZXR1cm4gc3RyZWFtLndyaXRhYmxlRXJyb3JlZFxuICB9XG4gIHJldHVybiAoX3N0cmVhbSRfd3JpdGFibGVTdGF0ID1cbiAgICAoX3N0cmVhbSRfd3JpdGFibGVTdGF0MiA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSkgPT09IG51bGwgfHwgX3N0cmVhbSRfd3JpdGFibGVTdGF0MiA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBfc3RyZWFtJF93cml0YWJsZVN0YXQyLmVycm9yZWQpICE9PSBudWxsICYmIF9zdHJlYW0kX3dyaXRhYmxlU3RhdCAhPT0gdW5kZWZpbmVkXG4gICAgPyBfc3RyZWFtJF93cml0YWJsZVN0YXRcbiAgICA6IG51bGxcbn1cbmZ1bmN0aW9uIGlzUmVhZGFibGVFcnJvcmVkKHN0cmVhbSkge1xuICB2YXIgX3N0cmVhbSRfcmVhZGFibGVTdGF0LCBfc3RyZWFtJF9yZWFkYWJsZVN0YXQyXG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChzdHJlYW0ucmVhZGFibGVFcnJvcmVkKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5yZWFkYWJsZUVycm9yZWRcbiAgfVxuICByZXR1cm4gKF9zdHJlYW0kX3JlYWRhYmxlU3RhdCA9XG4gICAgKF9zdHJlYW0kX3JlYWRhYmxlU3RhdDIgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9zdHJlYW0kX3JlYWRhYmxlU3RhdDIgPT09IHVuZGVmaW5lZFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogX3N0cmVhbSRfcmVhZGFibGVTdGF0Mi5lcnJvcmVkKSAhPT0gbnVsbCAmJiBfc3RyZWFtJF9yZWFkYWJsZVN0YXQgIT09IHVuZGVmaW5lZFxuICAgID8gX3N0cmVhbSRfcmVhZGFibGVTdGF0XG4gICAgOiBudWxsXG59XG5mdW5jdGlvbiBpc0Nsb3NlZChzdHJlYW0pIHtcbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJlYW0uY2xvc2VkID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gc3RyZWFtLmNsb3NlZFxuICB9XG4gIGNvbnN0IHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBjb25zdCByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgaWYgKFxuICAgIHR5cGVvZiAod1N0YXRlID09PSBudWxsIHx8IHdTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogd1N0YXRlLmNsb3NlZCkgPT09ICdib29sZWFuJyB8fFxuICAgIHR5cGVvZiAoclN0YXRlID09PSBudWxsIHx8IHJTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogclN0YXRlLmNsb3NlZCkgPT09ICdib29sZWFuJ1xuICApIHtcbiAgICByZXR1cm4gKFxuICAgICAgKHdTdGF0ZSA9PT0gbnVsbCB8fCB3U3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHdTdGF0ZS5jbG9zZWQpIHx8XG4gICAgICAoclN0YXRlID09PSBudWxsIHx8IHJTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogclN0YXRlLmNsb3NlZClcbiAgICApXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJlYW0uX2Nsb3NlZCA9PT0gJ2Jvb2xlYW4nICYmIGlzT3V0Z29pbmdNZXNzYWdlKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gc3RyZWFtLl9jbG9zZWRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuZnVuY3Rpb24gaXNPdXRnb2luZ01lc3NhZ2Uoc3RyZWFtKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHN0cmVhbS5fY2xvc2VkID09PSAnYm9vbGVhbicgJiZcbiAgICB0eXBlb2Ygc3RyZWFtLl9kZWZhdWx0S2VlcEFsaXZlID09PSAnYm9vbGVhbicgJiZcbiAgICB0eXBlb2Ygc3RyZWFtLl9yZW1vdmVkQ29ubmVjdGlvbiA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgdHlwZW9mIHN0cmVhbS5fcmVtb3ZlZENvbnRMZW4gPT09ICdib29sZWFuJ1xuICApXG59XG5mdW5jdGlvbiBpc1NlcnZlclJlc3BvbnNlKHN0cmVhbSkge1xuICByZXR1cm4gdHlwZW9mIHN0cmVhbS5fc2VudDEwMCA9PT0gJ2Jvb2xlYW4nICYmIGlzT3V0Z29pbmdNZXNzYWdlKHN0cmVhbSlcbn1cbmZ1bmN0aW9uIGlzU2VydmVyUmVxdWVzdChzdHJlYW0pIHtcbiAgdmFyIF9zdHJlYW0kcmVxXG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHN0cmVhbS5fY29uc3VtaW5nID09PSAnYm9vbGVhbicgJiZcbiAgICB0eXBlb2Ygc3RyZWFtLl9kdW1wZWQgPT09ICdib29sZWFuJyAmJlxuICAgICgoX3N0cmVhbSRyZXEgPSBzdHJlYW0ucmVxKSA9PT0gbnVsbCB8fCBfc3RyZWFtJHJlcSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX3N0cmVhbSRyZXEudXBncmFkZU9yQ29ubmVjdCkgPT09XG4gICAgICB1bmRlZmluZWRcbiAgKVxufVxuZnVuY3Rpb24gd2lsbEVtaXRDbG9zZShzdHJlYW0pIHtcbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkgcmV0dXJuIG51bGxcbiAgY29uc3Qgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCBzdGF0ZSA9IHdTdGF0ZSB8fCByU3RhdGVcbiAgcmV0dXJuIChcbiAgICAoIXN0YXRlICYmIGlzU2VydmVyUmVzcG9uc2Uoc3RyZWFtKSkgfHwgISEoc3RhdGUgJiYgc3RhdGUuYXV0b0Rlc3Ryb3kgJiYgc3RhdGUuZW1pdENsb3NlICYmIHN0YXRlLmNsb3NlZCA9PT0gZmFsc2UpXG4gIClcbn1cbmZ1bmN0aW9uIGlzRGlzdHVyYmVkKHN0cmVhbSkge1xuICB2YXIgX3N0cmVhbSRrSXNEaXN0dXJiZWRcbiAgcmV0dXJuICEhKFxuICAgIHN0cmVhbSAmJlxuICAgICgoX3N0cmVhbSRrSXNEaXN0dXJiZWQgPSBzdHJlYW1ba0lzRGlzdHVyYmVkXSkgIT09IG51bGwgJiYgX3N0cmVhbSRrSXNEaXN0dXJiZWQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBfc3RyZWFtJGtJc0Rpc3R1cmJlZFxuICAgICAgOiBzdHJlYW0ucmVhZGFibGVEaWRSZWFkIHx8IHN0cmVhbS5yZWFkYWJsZUFib3J0ZWQpXG4gIClcbn1cbmZ1bmN0aW9uIGlzRXJyb3JlZChzdHJlYW0pIHtcbiAgdmFyIF9yZWYsXG4gICAgX3JlZjIsXG4gICAgX3JlZjMsXG4gICAgX3JlZjQsXG4gICAgX3JlZjUsXG4gICAgX3N0cmVhbSRrSXNFcnJvcmVkLFxuICAgIF9zdHJlYW0kX3JlYWRhYmxlU3RhdDMsXG4gICAgX3N0cmVhbSRfd3JpdGFibGVTdGF0MyxcbiAgICBfc3RyZWFtJF9yZWFkYWJsZVN0YXQ0LFxuICAgIF9zdHJlYW0kX3dyaXRhYmxlU3RhdDRcbiAgcmV0dXJuICEhKFxuICAgIHN0cmVhbSAmJlxuICAgICgoX3JlZiA9XG4gICAgICAoX3JlZjIgPVxuICAgICAgICAoX3JlZjMgPVxuICAgICAgICAgIChfcmVmNCA9XG4gICAgICAgICAgICAoX3JlZjUgPVxuICAgICAgICAgICAgICAoX3N0cmVhbSRrSXNFcnJvcmVkID0gc3RyZWFtW2tJc0Vycm9yZWRdKSAhPT0gbnVsbCAmJiBfc3RyZWFtJGtJc0Vycm9yZWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gX3N0cmVhbSRrSXNFcnJvcmVkXG4gICAgICAgICAgICAgICAgOiBzdHJlYW0ucmVhZGFibGVFcnJvcmVkKSAhPT0gbnVsbCAmJiBfcmVmNSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gX3JlZjVcbiAgICAgICAgICAgICAgOiBzdHJlYW0ud3JpdGFibGVFcnJvcmVkKSAhPT0gbnVsbCAmJiBfcmVmNCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IF9yZWY0XG4gICAgICAgICAgICA6IChfc3RyZWFtJF9yZWFkYWJsZVN0YXQzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfc3RyZWFtJF9yZWFkYWJsZVN0YXQzID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IF9zdHJlYW0kX3JlYWRhYmxlU3RhdDMuZXJyb3JFbWl0dGVkKSAhPT0gbnVsbCAmJiBfcmVmMyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBfcmVmM1xuICAgICAgICAgIDogKF9zdHJlYW0kX3dyaXRhYmxlU3RhdDMgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9zdHJlYW0kX3dyaXRhYmxlU3RhdDMgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBfc3RyZWFtJF93cml0YWJsZVN0YXQzLmVycm9yRW1pdHRlZCkgIT09IG51bGwgJiYgX3JlZjIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IF9yZWYyXG4gICAgICAgIDogKF9zdHJlYW0kX3JlYWRhYmxlU3RhdDQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9zdHJlYW0kX3JlYWRhYmxlU3RhdDQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IF9zdHJlYW0kX3JlYWRhYmxlU3RhdDQuZXJyb3JlZCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IF9yZWZcbiAgICAgIDogKF9zdHJlYW0kX3dyaXRhYmxlU3RhdDQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9zdHJlYW0kX3dyaXRhYmxlU3RhdDQgPT09IHVuZGVmaW5lZFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogX3N0cmVhbSRfd3JpdGFibGVTdGF0NC5lcnJvcmVkKVxuICApXG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNEZXN0cm95ZWQsXG4gIGtJc0Rlc3Ryb3llZCxcbiAgaXNEaXN0dXJiZWQsXG4gIGtJc0Rpc3R1cmJlZCxcbiAgaXNFcnJvcmVkLFxuICBrSXNFcnJvcmVkLFxuICBpc1JlYWRhYmxlLFxuICBrSXNSZWFkYWJsZSxcbiAga0lzQ2xvc2VkUHJvbWlzZSxcbiAga0NvbnRyb2xsZXJFcnJvckZ1bmN0aW9uLFxuICBrSXNXcml0YWJsZSxcbiAgaXNDbG9zZWQsXG4gIGlzRHVwbGV4Tm9kZVN0cmVhbSxcbiAgaXNGaW5pc2hlZCxcbiAgaXNJdGVyYWJsZSxcbiAgaXNSZWFkYWJsZU5vZGVTdHJlYW0sXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzUmVhZGFibGVFbmRlZCxcbiAgaXNSZWFkYWJsZUZpbmlzaGVkLFxuICBpc1JlYWRhYmxlRXJyb3JlZCxcbiAgaXNOb2RlU3RyZWFtLFxuICBpc1dlYlN0cmVhbSxcbiAgaXNXcml0YWJsZSxcbiAgaXNXcml0YWJsZU5vZGVTdHJlYW0sXG4gIGlzV3JpdGFibGVTdHJlYW0sXG4gIGlzV3JpdGFibGVFbmRlZCxcbiAgaXNXcml0YWJsZUZpbmlzaGVkLFxuICBpc1dyaXRhYmxlRXJyb3JlZCxcbiAgaXNTZXJ2ZXJSZXF1ZXN0LFxuICBpc1NlcnZlclJlc3BvbnNlLFxuICB3aWxsRW1pdENsb3NlLFxuICBpc1RyYW5zZm9ybVN0cmVhbVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/streams/writable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/writable.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(ssr)/./node_modules/process/index.js\")\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n;('use strict')\nconst {\n  ArrayPrototypeSlice,\n  Error,\n  FunctionPrototypeSymbolHasInstance,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf,\n  StringPrototypeToLowerCase,\n  Symbol,\n  SymbolHasInstance\n} = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nmodule.exports = Writable\nWritable.WritableState = WritableState\nconst { EventEmitter: EE } = __webpack_require__(/*! events */ \"events\")\nconst Stream = (__webpack_require__(/*! ./legacy */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/legacy.js\").Stream)\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst destroyImpl = __webpack_require__(/*! ./destroy */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst { addAbortSignal } = __webpack_require__(/*! ./add-abort-signal */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\")\nconst { getHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./state */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/state.js\")\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED,\n  ERR_STREAM_ALREADY_FINISHED,\n  ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING\n} = (__webpack_require__(/*! ../../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\").codes)\nconst { errorOrDestroy } = destroyImpl\nObjectSetPrototypeOf(Writable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Writable, Stream)\nfunction nop() {}\nconst kOnFinished = Symbol('kOnFinished')\nfunction WritableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof __webpack_require__(/*! ./duplex */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/duplex.js\")\n\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!(options && options.objectMode)\n  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode)\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // if _final has been called.\n  this.finalCalled = false\n\n  // drain event flag.\n  this.needDrain = false\n  // At the start of calling end()\n  this.ending = false\n  // When end() has been called, and returned.\n  this.ended = false\n  // When 'finish' is emitted.\n  this.finished = false\n\n  // Has it been destroyed\n  this.destroyed = false\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  const noDecode = !!(options && options.decodeStrings === false)\n  this.decodeStrings = !noDecode\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0\n\n  // A flag to see when we're in the middle of a write.\n  this.writing = false\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0\n\n  // A flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true\n\n  // A flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false\n\n  // The callback that's passed to _write(chunk, cb).\n  this.onwrite = onwrite.bind(undefined, stream)\n\n  // The callback that the user supplies to write(chunk, encoding, cb).\n  this.writecb = null\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  this.afterWriteTickInfo = null\n  resetBuffer(this)\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  this.constructed = true\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  this.prefinished = false\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  this.autoDestroy = !options || options.autoDestroy !== false\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  this.errored = null\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false\n  this[kOnFinished] = []\n}\nfunction resetBuffer(state) {\n  state.buffered = []\n  state.bufferedIndex = 0\n  state.allBuffers = true\n  state.allNoop = true\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  return ArrayPrototypeSlice(this.buffered, this.bufferedIndex)\n}\nObjectDefineProperty(WritableState.prototype, 'bufferedRequestCount', {\n  __proto__: null,\n  get() {\n    return this.buffered.length - this.bufferedIndex\n  }\n})\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof __webpack_require__(/*! ./duplex */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/duplex.js\")\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options)\n  this._writableState = new WritableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write\n    if (typeof options.writev === 'function') this._writev = options.writev\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.final === 'function') this._final = options.final\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    const state = this._writableState\n    if (!state.writing) {\n      clearBuffer(this, state)\n    }\n    finishMaybe(this, state)\n  })\n}\nObjectDefineProperty(Writable, SymbolHasInstance, {\n  __proto__: null,\n  value: function (object) {\n    if (FunctionPrototypeSymbolHasInstance(this, object)) return true\n    if (this !== Writable) return false\n    return object && object._writableState instanceof WritableState\n  }\n})\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE())\n}\nfunction _write(stream, chunk, encoding, cb) {\n  const state = stream._writableState\n  if (typeof encoding === 'function') {\n    cb = encoding\n    encoding = state.defaultEncoding\n  } else {\n    if (!encoding) encoding = state.defaultEncoding\n    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)\n    if (typeof cb !== 'function') cb = nop\n  }\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES()\n  } else if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      if (state.decodeStrings !== false) {\n        chunk = Buffer.from(chunk, encoding)\n        encoding = 'buffer'\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer'\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = 'buffer'\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  let err\n  if (state.ending) {\n    err = new ERR_STREAM_WRITE_AFTER_END()\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write')\n  }\n  if (err) {\n    process.nextTick(cb, err)\n    errorOrDestroy(stream, err, true)\n    return err\n  }\n  state.pendingcb++\n  return writeOrBuffer(stream, state, chunk, encoding, cb)\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  return _write(this, chunk, encoding, cb) === true\n}\nWritable.prototype.cork = function () {\n  this._writableState.corked++\n}\nWritable.prototype.uncork = function () {\n  const state = this._writableState\n  if (state.corked) {\n    state.corked--\n    if (!state.writing) clearBuffer(this, state)\n  }\n}\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = StringPrototypeToLowerCase(encoding)\n  if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)\n  this._writableState.defaultEncoding = encoding\n  return this\n}\n\n// If we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, callback) {\n  const len = state.objectMode ? 1 : chunk.length\n  state.length += len\n\n  // stream._write resets state.length\n  const ret = state.length < state.highWaterMark\n  // We must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true\n  if (state.writing || state.corked || state.errored || !state.constructed) {\n    state.buffered.push({\n      chunk,\n      encoding,\n      callback\n    })\n    if (state.allBuffers && encoding !== 'buffer') {\n      state.allBuffers = false\n    }\n    if (state.allNoop && callback !== nop) {\n      state.allNoop = false\n    }\n  } else {\n    state.writelen = len\n    state.writecb = callback\n    state.writing = true\n    state.sync = true\n    stream._write(chunk, encoding, state.onwrite)\n    state.sync = false\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && !state.errored && !state.destroyed\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len\n  state.writecb = cb\n  state.writing = true\n  state.sync = true\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'))\n  else if (writev) stream._writev(chunk, state.onwrite)\n  else stream._write(chunk, encoding, state.onwrite)\n  state.sync = false\n}\nfunction onwriteError(stream, state, er, cb) {\n  --state.pendingcb\n  cb(er)\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write, not to the buffered\n  // writes.\n  errorBuffer(state)\n  // This can emit error, but error must always follow cb.\n  errorOrDestroy(stream, er)\n}\nfunction onwrite(stream, er) {\n  const state = stream._writableState\n  const sync = state.sync\n  const cb = state.writecb\n  if (typeof cb !== 'function') {\n    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK())\n    return\n  }\n  state.writing = false\n  state.writecb = null\n  state.length -= state.writelen\n  state.writelen = 0\n  if (er) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack // eslint-disable-line no-unused-expressions\n\n    if (!state.errored) {\n      state.errored = er\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er\n    }\n    if (sync) {\n      process.nextTick(onwriteError, stream, state, er, cb)\n    } else {\n      onwriteError(stream, state, er, cb)\n    }\n  } else {\n    if (state.buffered.length > state.bufferedIndex) {\n      clearBuffer(stream, state)\n    }\n    if (sync) {\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case, we do not schedule a new nextTick(), but\n      // rather just increase a counter, to improve performance and avoid\n      // memory allocations.\n      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {\n        state.afterWriteTickInfo.count++\n      } else {\n        state.afterWriteTickInfo = {\n          count: 1,\n          cb,\n          stream,\n          state\n        }\n        process.nextTick(afterWriteTick, state.afterWriteTickInfo)\n      }\n    } else {\n      afterWrite(stream, state, 1, cb)\n    }\n  }\n}\nfunction afterWriteTick({ stream, state, count, cb }) {\n  state.afterWriteTickInfo = null\n  return afterWrite(stream, state, count, cb)\n}\nfunction afterWrite(stream, state, count, cb) {\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain\n  if (needDrain) {\n    state.needDrain = false\n    stream.emit('drain')\n  }\n  while (count-- > 0) {\n    state.pendingcb--\n    cb()\n  }\n  if (state.destroyed) {\n    errorBuffer(state)\n  }\n  finishMaybe(stream, state)\n}\n\n// If there's something in the buffer waiting, then invoke callbacks.\nfunction errorBuffer(state) {\n  if (state.writing) {\n    return\n  }\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n    var _state$errored\n    const { chunk, callback } = state.buffered[n]\n    const len = state.objectMode ? 1 : chunk.length\n    state.length -= len\n    callback(\n      (_state$errored = state.errored) !== null && _state$errored !== undefined\n        ? _state$errored\n        : new ERR_STREAM_DESTROYED('write')\n    )\n  }\n  const onfinishCallbacks = state[kOnFinished].splice(0)\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    var _state$errored2\n    onfinishCallbacks[i](\n      (_state$errored2 = state.errored) !== null && _state$errored2 !== undefined\n        ? _state$errored2\n        : new ERR_STREAM_DESTROYED('end')\n    )\n  }\n  resetBuffer(state)\n}\n\n// If there's something in the buffer waiting, then process it.\nfunction clearBuffer(stream, state) {\n  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {\n    return\n  }\n  const { buffered, bufferedIndex, objectMode } = state\n  const bufferedLength = buffered.length - bufferedIndex\n  if (!bufferedLength) {\n    return\n  }\n  let i = bufferedIndex\n  state.bufferProcessing = true\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1\n    const callback = state.allNoop\n      ? nop\n      : (err) => {\n          for (let n = i; n < buffered.length; ++n) {\n            buffered[n].callback(err)\n          }\n        }\n    // Make a copy of `buffered` if it's going to be used by `callback` above,\n    // since `doWrite` will mutate the array.\n    const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i)\n    chunks.allBuffers = state.allBuffers\n    doWrite(stream, state, true, state.length, chunks, '', callback)\n    resetBuffer(state)\n  } else {\n    do {\n      const { chunk, encoding, callback } = buffered[i]\n      buffered[i++] = null\n      const len = objectMode ? 1 : chunk.length\n      doWrite(stream, state, false, len, chunk, encoding, callback)\n    } while (i < buffered.length && !state.writing)\n    if (i === buffered.length) {\n      resetBuffer(state)\n    } else if (i > 256) {\n      buffered.splice(0, i)\n      state.bufferedIndex = 0\n    } else {\n      state.bufferedIndex = i\n    }\n  }\n  state.bufferProcessing = false\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  if (this._writev) {\n    this._writev(\n      [\n        {\n          chunk,\n          encoding\n        }\n      ],\n      cb\n    )\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()')\n  }\n}\nWritable.prototype._writev = null\nWritable.prototype.end = function (chunk, encoding, cb) {\n  const state = this._writableState\n  if (typeof chunk === 'function') {\n    cb = chunk\n    chunk = null\n    encoding = null\n  } else if (typeof encoding === 'function') {\n    cb = encoding\n    encoding = null\n  }\n  let err\n  if (chunk !== null && chunk !== undefined) {\n    const ret = _write(this, chunk, encoding)\n    if (ret instanceof Error) {\n      err = ret\n    }\n  }\n\n  // .end() fully uncorks.\n  if (state.corked) {\n    state.corked = 1\n    this.uncork()\n  }\n  if (err) {\n    // Do nothing...\n  } else if (!state.errored && !state.ending) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However, usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state.ending = true\n    finishMaybe(this, state, true)\n    state.ended = true\n  } else if (state.finished) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end')\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('end')\n  }\n  if (typeof cb === 'function') {\n    if (err || state.finished) {\n      process.nextTick(cb, err)\n    } else {\n      state[kOnFinished].push(cb)\n    }\n  }\n  return this\n}\nfunction needFinish(state) {\n  return (\n    state.ending &&\n    !state.destroyed &&\n    state.constructed &&\n    state.length === 0 &&\n    !state.errored &&\n    state.buffered.length === 0 &&\n    !state.finished &&\n    !state.writing &&\n    !state.errorEmitted &&\n    !state.closeEmitted\n  )\n}\nfunction callFinal(stream, state) {\n  let called = false\n  function onFinish(err) {\n    if (called) {\n      errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK())\n      return\n    }\n    called = true\n    state.pendingcb--\n    if (err) {\n      const onfinishCallbacks = state[kOnFinished].splice(0)\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i](err)\n      }\n      errorOrDestroy(stream, err, state.sync)\n    } else if (needFinish(state)) {\n      state.prefinished = true\n      stream.emit('prefinish')\n      // Backwards compat. Don't check state.sync here.\n      // Some streams assume 'finish' will be emitted\n      // asynchronously relative to _final callback.\n      state.pendingcb++\n      process.nextTick(finish, stream, state)\n    }\n  }\n  state.sync = true\n  state.pendingcb++\n  try {\n    stream._final(onFinish)\n  } catch (err) {\n    onFinish(err)\n  }\n  state.sync = false\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.finalCalled = true\n      callFinal(stream, state)\n    } else {\n      state.prefinished = true\n      stream.emit('prefinish')\n    }\n  }\n}\nfunction finishMaybe(stream, state, sync) {\n  if (needFinish(state)) {\n    prefinish(stream, state)\n    if (state.pendingcb === 0) {\n      if (sync) {\n        state.pendingcb++\n        process.nextTick(\n          (stream, state) => {\n            if (needFinish(state)) {\n              finish(stream, state)\n            } else {\n              state.pendingcb--\n            }\n          },\n          stream,\n          state\n        )\n      } else if (needFinish(state)) {\n        state.pendingcb++\n        finish(stream, state)\n      }\n    }\n  }\n}\nfunction finish(stream, state) {\n  state.pendingcb--\n  state.finished = true\n  const onfinishCallbacks = state[kOnFinished].splice(0)\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i]()\n  }\n  stream.emit('finish')\n  if (state.autoDestroy) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState\n    const autoDestroy =\n      !rState ||\n      (rState.autoDestroy &&\n        // We don't expect the readable to ever 'end'\n        // if readable is explicitly set to false.\n        (rState.endEmitted || rState.readable === false))\n    if (autoDestroy) {\n      stream.destroy()\n    }\n  }\n}\nObjectDefineProperties(Writable.prototype, {\n  closed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.destroyed : false\n    },\n    set(value) {\n      // Backward compatibility, the user is explicitly managing destroyed.\n      if (this._writableState) {\n        this._writableState.destroyed = value\n      }\n    }\n  },\n  writable: {\n    __proto__: null,\n    get() {\n      const w = this._writableState\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended\n    },\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val\n      }\n    }\n  },\n  writableFinished: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.finished : false\n    }\n  },\n  writableObjectMode: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.objectMode : false\n    }\n  },\n  writableBuffer: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.getBuffer()\n    }\n  },\n  writableEnded: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.ending : false\n    }\n  },\n  writableNeedDrain: {\n    __proto__: null,\n    get() {\n      const wState = this._writableState\n      if (!wState) return false\n      return !wState.destroyed && !wState.ending && wState.needDrain\n    }\n  },\n  writableHighWaterMark: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.highWaterMark\n    }\n  },\n  writableCorked: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.corked : 0\n    }\n  },\n  writableLength: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.length\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._writableState ? this._writableState.errored : null\n    }\n  },\n  writableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._writableState.writable !== false &&\n        (this._writableState.destroyed || this._writableState.errored) &&\n        !this._writableState.finished\n      )\n    }\n  }\n})\nconst destroy = destroyImpl.destroy\nWritable.prototype.destroy = function (err, cb) {\n  const state = this._writableState\n\n  // Invoke pending callbacks.\n  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {\n    process.nextTick(errorBuffer, state)\n  }\n  destroy.call(this, err, cb)\n  return this\n}\nWritable.prototype._undestroy = destroyImpl.undestroy\nWritable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nWritable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nWritable.fromWeb = function (writableStream, options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options)\n}\nWritable.toWeb = function (streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3dyaXRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRGQUF3QjtBQUNwQztBQUNBO0FBQ0EsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdDLGVBQWUsbUhBQTBCO0FBQ3pDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsdUZBQVc7QUFDdkMsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLHlHQUFvQjtBQUN2RCxRQUFRLDRDQUE0QyxFQUFFLG1CQUFPLENBQUMsbUZBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsK0dBQWtDO0FBQ3RDLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1CQUFPLENBQUMscUZBQVU7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFPLENBQUMscUZBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNDQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXRoLWxvbmRvbi0yMDI0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy93cml0YWJsZS5qcz9lZDdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHJlcGxhY2VtZW50IHN0YXJ0ICovXG5cbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzLycpXG5cbi8qIHJlcGxhY2VtZW50IGVuZCAqL1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuOygndXNlIHN0cmljdCcpXG5jb25zdCB7XG4gIEFycmF5UHJvdG90eXBlU2xpY2UsXG4gIEVycm9yLFxuICBGdW5jdGlvblByb3RvdHlwZVN5bWJvbEhhc0luc3RhbmNlLFxuICBPYmplY3REZWZpbmVQcm9wZXJ0eSxcbiAgT2JqZWN0RGVmaW5lUHJvcGVydGllcyxcbiAgT2JqZWN0U2V0UHJvdG90eXBlT2YsXG4gIFN0cmluZ1Byb3RvdHlwZVRvTG93ZXJDYXNlLFxuICBTeW1ib2wsXG4gIFN5bWJvbEhhc0luc3RhbmNlXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZVxuY29uc3QgeyBFdmVudEVtaXR0ZXI6IEVFIH0gPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnLi9sZWdhY3knKS5TdHJlYW1cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2Rlc3Ryb3knKVxuY29uc3QgeyBhZGRBYm9ydFNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hZGQtYWJvcnQtc2lnbmFsJylcbmNvbnN0IHsgZ2V0SGlnaFdhdGVyTWFyaywgZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsgfSA9IHJlcXVpcmUoJy4vc3RhdGUnKVxuY29uc3Qge1xuICBFUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gIEVSUl9TVFJFQU1fQUxSRUFEWV9GSU5JU0hFRCxcbiAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gIEVSUl9VTktOT1dOX0VOQ09ESU5HXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKS5jb2Rlc1xuY29uc3QgeyBlcnJvck9yRGVzdHJveSB9ID0gZGVzdHJveUltcGxcbk9iamVjdFNldFByb3RvdHlwZU9mKFdyaXRhYmxlLnByb3RvdHlwZSwgU3RyZWFtLnByb3RvdHlwZSlcbk9iamVjdFNldFByb3RvdHlwZU9mKFdyaXRhYmxlLCBTdHJlYW0pXG5mdW5jdGlvbiBub3AoKSB7fVxuY29uc3Qga09uRmluaXNoZWQgPSBTeW1ib2woJ2tPbkZpbmlzaGVkJylcbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIHJlcXVpcmUoJy4vZHVwbGV4JylcblxuICAvLyBPYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIShvcHRpb25zICYmIG9wdGlvbnMub2JqZWN0TW9kZSlcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISEob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSlcblxuICAvLyBUaGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKCkuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IG9wdGlvbnNcbiAgICA/IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KVxuICAgIDogZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsoZmFsc2UpXG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZC5cbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlXG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZVxuICAvLyBBdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlXG4gIC8vIFdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWQuXG4gIHRoaXMuZW5kZWQgPSBmYWxzZVxuICAvLyBXaGVuICdmaW5pc2gnIGlzIGVtaXR0ZWQuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZVxuXG4gIC8vIEhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgLy8gU2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICBjb25zdCBub0RlY29kZSA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZSlcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlXG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlZmF1bHRFbmNvZGluZykgfHwgJ3V0ZjgnXG5cbiAgLy8gTm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwXG5cbiAgLy8gQSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2VcblxuICAvLyBXaGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsLlxuICB0aGlzLmNvcmtlZCA9IDBcblxuICAvLyBBIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZVxuXG4gIC8vIEEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlXG5cbiAgLy8gVGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLCBjYikuXG4gIHRoaXMub253cml0ZSA9IG9ud3JpdGUuYmluZCh1bmRlZmluZWQsIHN0cmVhbSlcblxuICAvLyBUaGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKS5cbiAgdGhpcy53cml0ZWNiID0gbnVsbFxuXG4gIC8vIFRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDBcblxuICAvLyBTdG9yYWdlIGZvciBkYXRhIHBhc3NlZCB0byB0aGUgYWZ0ZXJXcml0ZSgpIGNhbGxiYWNrIGluIGNhc2Ugb2ZcbiAgLy8gc3luY2hyb25vdXMgX3dyaXRlKCkgY29tcGxldGlvbi5cbiAgdGhpcy5hZnRlcldyaXRlVGlja0luZm8gPSBudWxsXG4gIHJlc2V0QnVmZmVyKHRoaXMpXG5cbiAgLy8gTnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkLlxuICB0aGlzLnBlbmRpbmdjYiA9IDBcblxuICAvLyBTdHJlYW0gaXMgc3RpbGwgYmVpbmcgY29uc3RydWN0ZWQgYW5kIGNhbm5vdCBiZVxuICAvLyBkZXN0cm95ZWQgdW50aWwgY29uc3RydWN0aW9uIGZpbmlzaGVkIG9yIGZhaWxlZC5cbiAgLy8gQXN5bmMgY29uc3RydWN0aW9uIGlzIG9wdCBpbiwgdGhlcmVmb3JlIHdlIHN0YXJ0IGFzXG4gIC8vIGNvbnN0cnVjdGVkLlxuICB0aGlzLmNvbnN0cnVjdGVkID0gdHJ1ZVxuXG4gIC8vIEVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXMuXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZVxuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluLlxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlXG5cbiAgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgdGhpcy5lbWl0Q2xvc2UgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2VcblxuICAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJykuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmF1dG9EZXN0cm95ICE9PSBmYWxzZVxuXG4gIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdHJlYW0gaGFzIGVycm9yZWQuIFdoZW4gdHJ1ZSBhbGwgd3JpdGUoKSBjYWxsc1xuICAvLyBzaG91bGQgcmV0dXJuIGZhbHNlLiBUaGlzIGlzIG5lZWRlZCBzaW5jZSB3aGVuIGF1dG9EZXN0cm95XG4gIC8vIGlzIGRpc2FibGVkIHdlIG5lZWQgYSB3YXkgdG8gdGVsbCB3aGV0aGVyIHRoZSBzdHJlYW0gaGFzIGZhaWxlZC5cbiAgdGhpcy5lcnJvcmVkID0gbnVsbFxuXG4gIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdHJlYW0gaGFzIGZpbmlzaGVkIGRlc3Ryb3lpbmcuXG4gIHRoaXMuY2xvc2VkID0gZmFsc2VcblxuICAvLyBUcnVlIGlmIGNsb3NlIGhhcyBiZWVuIGVtaXR0ZWQgb3Igd291bGQgaGF2ZSBiZWVuIGVtaXR0ZWRcbiAgLy8gZGVwZW5kaW5nIG9uIGVtaXRDbG9zZS5cbiAgdGhpcy5jbG9zZUVtaXR0ZWQgPSBmYWxzZVxuICB0aGlzW2tPbkZpbmlzaGVkXSA9IFtdXG59XG5mdW5jdGlvbiByZXNldEJ1ZmZlcihzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJlZCA9IFtdXG4gIHN0YXRlLmJ1ZmZlcmVkSW5kZXggPSAwXG4gIHN0YXRlLmFsbEJ1ZmZlcnMgPSB0cnVlXG4gIHN0YXRlLmFsbE5vb3AgPSB0cnVlXG59XG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHJldHVybiBBcnJheVByb3RvdHlwZVNsaWNlKHRoaXMuYnVmZmVyZWQsIHRoaXMuYnVmZmVyZWRJbmRleClcbn1cbk9iamVjdERlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyZWRSZXF1ZXN0Q291bnQnLCB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkLmxlbmd0aCAtIHRoaXMuYnVmZmVyZWRJbmRleFxuICB9XG59KVxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cblxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNS5cbiAgY29uc3QgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgcmVxdWlyZSgnLi9kdXBsZXgnKVxuICBpZiAoIWlzRHVwbGV4ICYmICFGdW5jdGlvblByb3RvdHlwZVN5bWJvbEhhc0luc3RhbmNlKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKVxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGVcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldlxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29uc3RydWN0ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9jb25zdHJ1Y3QgPSBvcHRpb25zLmNvbnN0cnVjdFxuICAgIGlmIChvcHRpb25zLnNpZ25hbCkgYWRkQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsIHRoaXMpXG4gIH1cbiAgU3RyZWFtLmNhbGwodGhpcywgb3B0aW9ucylcbiAgZGVzdHJveUltcGwuY29uc3RydWN0KHRoaXMsICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGVcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKVxuICAgIH1cbiAgICBmaW5pc2hNYXliZSh0aGlzLCBzdGF0ZSlcbiAgfSlcbn1cbk9iamVjdERlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2xIYXNJbnN0YW5jZSwge1xuICBfX3Byb3RvX186IG51bGwsXG4gIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgaWYgKEZ1bmN0aW9uUHJvdG90eXBlU3ltYm9sSGFzSW5zdGFuY2UodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWVcbiAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZVxuICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZVxuICB9XG59KVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSlcbn1cbmZ1bmN0aW9uIF93cml0ZShzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZ1xuICB9IGVsc2Uge1xuICAgIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nXG4gICAgZWxzZSBpZiAoZW5jb2RpbmcgIT09ICdidWZmZXInICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZylcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcFxuICB9XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKClcbiAgfSBlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcidcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNodW5rIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInXG4gICAgfSBlbHNlIGlmIChTdHJlYW0uX2lzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgIGNodW5rID0gU3RyZWFtLl91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspXG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuaylcbiAgICB9XG4gIH1cbiAgbGV0IGVyclxuICBpZiAoc3RhdGUuZW5kaW5nKSB7XG4gICAgZXJyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKClcbiAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICBlcnIgPSBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJylcbiAgfVxuICBpZiAoZXJyKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXJyKVxuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyLCB0cnVlKVxuICAgIHJldHVybiBlcnJcbiAgfVxuICBzdGF0ZS5wZW5kaW5nY2IrK1xuICByZXR1cm4gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKVxufVxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgcmV0dXJuIF93cml0ZSh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGNiKSA9PT0gdHJ1ZVxufVxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKytcbn1cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS1cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKVxuICB9XG59XG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBTdHJpbmdQcm90b3R5cGVUb0xvd2VyQ2FzZShlbmNvZGluZylcbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZylcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZ1xuICByZXR1cm4gdGhpc1xufVxuXG4vLyBJZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoXG4gIHN0YXRlLmxlbmd0aCArPSBsZW5cblxuICAvLyBzdHJlYW0uX3dyaXRlIHJlc2V0cyBzdGF0ZS5sZW5ndGhcbiAgY29uc3QgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFya1xuICAvLyBXZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWVcbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkIHx8IHN0YXRlLmVycm9yZWQgfHwgIXN0YXRlLmNvbnN0cnVjdGVkKSB7XG4gICAgc3RhdGUuYnVmZmVyZWQucHVzaCh7XG4gICAgICBjaHVuayxcbiAgICAgIGVuY29kaW5nLFxuICAgICAgY2FsbGJhY2tcbiAgICB9KVxuICAgIGlmIChzdGF0ZS5hbGxCdWZmZXJzICYmIGVuY29kaW5nICE9PSAnYnVmZmVyJykge1xuICAgICAgc3RhdGUuYWxsQnVmZmVycyA9IGZhbHNlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5hbGxOb29wICYmIGNhbGxiYWNrICE9PSBub3ApIHtcbiAgICAgIHN0YXRlLmFsbE5vb3AgPSBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS53cml0ZWxlbiA9IGxlblxuICAgIHN0YXRlLndyaXRlY2IgPSBjYWxsYmFja1xuICAgIHN0YXRlLndyaXRpbmcgPSB0cnVlXG4gICAgc3RhdGUuc3luYyA9IHRydWVcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSlcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2VcbiAgfVxuXG4gIC8vIFJldHVybiBmYWxzZSBpZiBlcnJvcmVkIG9yIGRlc3Ryb3llZCBpbiBvcmRlciB0byBicmVha1xuICAvLyBhbnkgc3luY2hyb25vdXMgd2hpbGUoc3RyZWFtLndyaXRlKGRhdGEpKSBsb29wcy5cbiAgcmV0dXJuIHJldCAmJiAhc3RhdGUuZXJyb3JlZCAmJiAhc3RhdGUuZGVzdHJveWVkXG59XG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuXG4gIHN0YXRlLndyaXRlY2IgPSBjYlxuICBzdGF0ZS53cml0aW5nID0gdHJ1ZVxuICBzdGF0ZS5zeW5jID0gdHJ1ZVxuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSlcbiAgZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSlcbiAgZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSlcbiAgc3RhdGUuc3luYyA9IGZhbHNlXG59XG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiXG4gIGNiKGVyKVxuICAvLyBFbnN1cmUgY2FsbGJhY2tzIGFyZSBpbnZva2VkIGV2ZW4gd2hlbiBhdXRvRGVzdHJveSBpc1xuICAvLyBub3QgZW5hYmxlZC4gUGFzc2luZyBgZXJgIGhlcmUgZG9lc24ndCBtYWtlIHNlbnNlIHNpbmNlXG4gIC8vIGl0J3MgcmVsYXRlZCB0byBvbmUgc3BlY2lmaWMgd3JpdGUsIG5vdCB0byB0aGUgYnVmZmVyZWRcbiAgLy8gd3JpdGVzLlxuICBlcnJvckJ1ZmZlcihzdGF0ZSlcbiAgLy8gVGhpcyBjYW4gZW1pdCBlcnJvciwgYnV0IGVycm9yIG11c3QgYWx3YXlzIGZvbGxvdyBjYi5cbiAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcilcbn1cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBjb25zdCBzeW5jID0gc3RhdGUuc3luY1xuICBjb25zdCBjYiA9IHN0YXRlLndyaXRlY2JcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKVxuICAgIHJldHVyblxuICB9XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZVxuICBzdGF0ZS53cml0ZWNiID0gbnVsbFxuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW5cbiAgc3RhdGUud3JpdGVsZW4gPSAwXG4gIGlmIChlcikge1xuICAgIC8vIEF2b2lkIFY4IGxlYWssIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzM0MTAzI2lzc3VlY29tbWVudC02NTIwMDIzNjRcbiAgICBlci5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXG4gICAgaWYgKCFzdGF0ZS5lcnJvcmVkKSB7XG4gICAgICBzdGF0ZS5lcnJvcmVkID0gZXJcbiAgICB9XG5cbiAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgdG8gbm90aWZ5IHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZVxuICAgIC8vIGVycm9yLlxuICAgIGlmIChzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lcnJvcmVkKSB7XG4gICAgICBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZXJyb3JlZCA9IGVyXG4gICAgfVxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKG9ud3JpdGVFcnJvciwgc3RyZWFtLCBzdGF0ZSwgZXIsIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgZXIsIGNiKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhdGUuYnVmZmVyZWQubGVuZ3RoID4gc3RhdGUuYnVmZmVyZWRJbmRleCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSlcbiAgICB9XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0IGlzIGEgY29tbW9uIGNhc2UgdGhhdCB0aGUgY2FsbGJhY2sgcGFzc2VkIHRvIC53cml0ZSgpIGlzIGFsd2F5c1xuICAgICAgLy8gdGhlIHNhbWUuIEluIHRoYXQgY2FzZSwgd2UgZG8gbm90IHNjaGVkdWxlIGEgbmV3IG5leHRUaWNrKCksIGJ1dFxuICAgICAgLy8gcmF0aGVyIGp1c3QgaW5jcmVhc2UgYSBjb3VudGVyLCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIGFuZCBhdm9pZFxuICAgICAgLy8gbWVtb3J5IGFsbG9jYXRpb25zLlxuICAgICAgaWYgKHN0YXRlLmFmdGVyV3JpdGVUaWNrSW5mbyAhPT0gbnVsbCAmJiBzdGF0ZS5hZnRlcldyaXRlVGlja0luZm8uY2IgPT09IGNiKSB7XG4gICAgICAgIHN0YXRlLmFmdGVyV3JpdGVUaWNrSW5mby5jb3VudCsrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5hZnRlcldyaXRlVGlja0luZm8gPSB7XG4gICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgY2IsXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIHN0YXRlXG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlVGljaywgc3RhdGUuYWZ0ZXJXcml0ZVRpY2tJbmZvKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIDEsIGNiKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWZ0ZXJXcml0ZVRpY2soeyBzdHJlYW0sIHN0YXRlLCBjb3VudCwgY2IgfSkge1xuICBzdGF0ZS5hZnRlcldyaXRlVGlja0luZm8gPSBudWxsXG4gIHJldHVybiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGNvdW50LCBjYilcbn1cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgY291bnQsIGNiKSB7XG4gIGNvbnN0IG5lZWREcmFpbiA9ICFzdGF0ZS5lbmRpbmcgJiYgIXN0cmVhbS5kZXN0cm95ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpblxuICBpZiAobmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tXG4gICAgY2IoKVxuICB9XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICBlcnJvckJ1ZmZlcihzdGF0ZSlcbiAgfVxuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKVxufVxuXG4vLyBJZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gaW52b2tlIGNhbGxiYWNrcy5cbmZ1bmN0aW9uIGVycm9yQnVmZmVyKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZm9yIChsZXQgbiA9IHN0YXRlLmJ1ZmZlcmVkSW5kZXg7IG4gPCBzdGF0ZS5idWZmZXJlZC5sZW5ndGg7ICsrbikge1xuICAgIHZhciBfc3RhdGUkZXJyb3JlZFxuICAgIGNvbnN0IHsgY2h1bmssIGNhbGxiYWNrIH0gPSBzdGF0ZS5idWZmZXJlZFtuXVxuICAgIGNvbnN0IGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoXG4gICAgc3RhdGUubGVuZ3RoIC09IGxlblxuICAgIGNhbGxiYWNrKFxuICAgICAgKF9zdGF0ZSRlcnJvcmVkID0gc3RhdGUuZXJyb3JlZCkgIT09IG51bGwgJiYgX3N0YXRlJGVycm9yZWQgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IF9zdGF0ZSRlcnJvcmVkXG4gICAgICAgIDogbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpXG4gICAgKVxuICB9XG4gIGNvbnN0IG9uZmluaXNoQ2FsbGJhY2tzID0gc3RhdGVba09uRmluaXNoZWRdLnNwbGljZSgwKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZmluaXNoQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9zdGF0ZSRlcnJvcmVkMlxuICAgIG9uZmluaXNoQ2FsbGJhY2tzW2ldKFxuICAgICAgKF9zdGF0ZSRlcnJvcmVkMiA9IHN0YXRlLmVycm9yZWQpICE9PSBudWxsICYmIF9zdGF0ZSRlcnJvcmVkMiAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gX3N0YXRlJGVycm9yZWQyXG4gICAgICAgIDogbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdlbmQnKVxuICAgIClcbiAgfVxuICByZXNldEJ1ZmZlcihzdGF0ZSlcbn1cblxuLy8gSWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXQuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5jb3JrZWQgfHwgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyB8fCBzdGF0ZS5kZXN0cm95ZWQgfHwgIXN0YXRlLmNvbnN0cnVjdGVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgeyBidWZmZXJlZCwgYnVmZmVyZWRJbmRleCwgb2JqZWN0TW9kZSB9ID0gc3RhdGVcbiAgY29uc3QgYnVmZmVyZWRMZW5ndGggPSBidWZmZXJlZC5sZW5ndGggLSBidWZmZXJlZEluZGV4XG4gIGlmICghYnVmZmVyZWRMZW5ndGgpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQgaSA9IGJ1ZmZlcmVkSW5kZXhcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWVcbiAgaWYgKGJ1ZmZlcmVkTGVuZ3RoID4gMSAmJiBzdHJlYW0uX3dyaXRldikge1xuICAgIHN0YXRlLnBlbmRpbmdjYiAtPSBidWZmZXJlZExlbmd0aCAtIDFcbiAgICBjb25zdCBjYWxsYmFjayA9IHN0YXRlLmFsbE5vb3BcbiAgICAgID8gbm9wXG4gICAgICA6IChlcnIpID0+IHtcbiAgICAgICAgICBmb3IgKGxldCBuID0gaTsgbiA8IGJ1ZmZlcmVkLmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgICBidWZmZXJlZFtuXS5jYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gTWFrZSBhIGNvcHkgb2YgYGJ1ZmZlcmVkYCBpZiBpdCdzIGdvaW5nIHRvIGJlIHVzZWQgYnkgYGNhbGxiYWNrYCBhYm92ZSxcbiAgICAvLyBzaW5jZSBgZG9Xcml0ZWAgd2lsbCBtdXRhdGUgdGhlIGFycmF5LlxuICAgIGNvbnN0IGNodW5rcyA9IHN0YXRlLmFsbE5vb3AgJiYgaSA9PT0gMCA/IGJ1ZmZlcmVkIDogQXJyYXlQcm90b3R5cGVTbGljZShidWZmZXJlZCwgaSlcbiAgICBjaHVua3MuYWxsQnVmZmVycyA9IHN0YXRlLmFsbEJ1ZmZlcnNcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgY2h1bmtzLCAnJywgY2FsbGJhY2spXG4gICAgcmVzZXRCdWZmZXIoc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgZG8ge1xuICAgICAgY29uc3QgeyBjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrIH0gPSBidWZmZXJlZFtpXVxuICAgICAgYnVmZmVyZWRbaSsrXSA9IG51bGxcbiAgICAgIGNvbnN0IGxlbiA9IG9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spXG4gICAgfSB3aGlsZSAoaSA8IGJ1ZmZlcmVkLmxlbmd0aCAmJiAhc3RhdGUud3JpdGluZylcbiAgICBpZiAoaSA9PT0gYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICByZXNldEJ1ZmZlcihzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGkgPiAyNTYpIHtcbiAgICAgIGJ1ZmZlcmVkLnNwbGljZSgwLCBpKVxuICAgICAgc3RhdGUuYnVmZmVyZWRJbmRleCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRJbmRleCA9IGlcbiAgICB9XG4gIH1cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlXG59XG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKHRoaXMuX3dyaXRldikge1xuICAgIHRoaXMuX3dyaXRldihcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIGNodW5rLFxuICAgICAgICAgIGVuY29kaW5nXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBjYlxuICAgIClcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJylcbiAgfVxufVxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rXG4gICAgY2h1bmsgPSBudWxsXG4gICAgZW5jb2RpbmcgPSBudWxsXG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gbnVsbFxuICB9XG4gIGxldCBlcnJcbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCByZXQgPSBfd3JpdGUodGhpcywgY2h1bmssIGVuY29kaW5nKVxuICAgIGlmIChyZXQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgZXJyID0gcmV0XG4gICAgfVxuICB9XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3MuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxXG4gICAgdGhpcy51bmNvcmsoKVxuICB9XG4gIGlmIChlcnIpIHtcbiAgICAvLyBEbyBub3RoaW5nLi4uXG4gIH0gZWxzZSBpZiAoIXN0YXRlLmVycm9yZWQgJiYgIXN0YXRlLmVuZGluZykge1xuICAgIC8vIFRoaXMgaXMgZm9yZ2l2aW5nIGluIHRlcm1zIG9mIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGVuZCgpIGFuZCBjYW4gaGlkZVxuICAgIC8vIGxvZ2ljIGVycm9ycy4gSG93ZXZlciwgdXN1YWxseSBzdWNoIGVycm9ycyBhcmUgaGFybWxlc3MgYW5kIGNhdXNpbmcgYVxuICAgIC8vIGhhcmQgZXJyb3IgY2FuIGJlIGRpc3Byb3BvcnRpb25hdGVseSBkZXN0cnVjdGl2ZS4gSXQgaXMgbm90IGFsd2F5c1xuICAgIC8vIHRyaXZpYWwgZm9yIHRoZSB1c2VyIHRvIGRldGVybWluZSB3aGV0aGVyIGVuZCgpIG5lZWRzIHRvIGJlIGNhbGxlZFxuICAgIC8vIG9yIG5vdC5cblxuICAgIHN0YXRlLmVuZGluZyA9IHRydWVcbiAgICBmaW5pc2hNYXliZSh0aGlzLCBzdGF0ZSwgdHJ1ZSlcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWVcbiAgfSBlbHNlIGlmIChzdGF0ZS5maW5pc2hlZCkge1xuICAgIGVyciA9IG5ldyBFUlJfU1RSRUFNX0FMUkVBRFlfRklOSVNIRUQoJ2VuZCcpXG4gIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgZXJyID0gbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdlbmQnKVxuICB9XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZXJyIHx8IHN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlW2tPbkZpbmlzaGVkXS5wdXNoKGNiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpc1xufVxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHN0YXRlLmVuZGluZyAmJlxuICAgICFzdGF0ZS5kZXN0cm95ZWQgJiZcbiAgICBzdGF0ZS5jb25zdHJ1Y3RlZCAmJlxuICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICFzdGF0ZS5lcnJvcmVkICYmXG4gICAgc3RhdGUuYnVmZmVyZWQubGVuZ3RoID09PSAwICYmXG4gICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgIXN0YXRlLndyaXRpbmcgJiZcbiAgICAhc3RhdGUuZXJyb3JFbWl0dGVkICYmXG4gICAgIXN0YXRlLmNsb3NlRW1pdHRlZFxuICApXG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBsZXQgY2FsbGVkID0gZmFsc2VcbiAgZnVuY3Rpb24gb25GaW5pc2goZXJyKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIgIT09IG51bGwgJiYgZXJyICE9PSB1bmRlZmluZWQgPyBlcnIgOiBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgc3RhdGUucGVuZGluZ2NiLS1cbiAgICBpZiAoZXJyKSB7XG4gICAgICBjb25zdCBvbmZpbmlzaENhbGxiYWNrcyA9IHN0YXRlW2tPbkZpbmlzaGVkXS5zcGxpY2UoMClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25maW5pc2hDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb25maW5pc2hDYWxsYmFja3NbaV0oZXJyKVxuICAgICAgfVxuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIsIHN0YXRlLnN5bmMpXG4gICAgfSBlbHNlIGlmIChuZWVkRmluaXNoKHN0YXRlKSkge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlXG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJylcbiAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQuIERvbid0IGNoZWNrIHN0YXRlLnN5bmMgaGVyZS5cbiAgICAgIC8vIFNvbWUgc3RyZWFtcyBhc3N1bWUgJ2ZpbmlzaCcgd2lsbCBiZSBlbWl0dGVkXG4gICAgICAvLyBhc3luY2hyb25vdXNseSByZWxhdGl2ZSB0byBfZmluYWwgY2FsbGJhY2suXG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrK1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2gsIHN0cmVhbSwgc3RhdGUpXG4gICAgfVxuICB9XG4gIHN0YXRlLnN5bmMgPSB0cnVlXG4gIHN0YXRlLnBlbmRpbmdjYisrXG4gIHRyeSB7XG4gICAgc3RyZWFtLl9maW5hbChvbkZpbmlzaClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgb25GaW5pc2goZXJyKVxuICB9XG4gIHN0YXRlLnN5bmMgPSBmYWxzZVxufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlXG4gICAgICBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlXG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUsIHN5bmMpIHtcbiAgaWYgKG5lZWRGaW5pc2goc3RhdGUpKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiKytcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhcbiAgICAgICAgICAoc3RyZWFtLCBzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5lZWRGaW5pc2goc3RhdGUpKSB7XG4gICAgICAgICAgICAgIGZpbmlzaChzdHJlYW0sIHN0YXRlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhdGUucGVuZGluZ2NiLS1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKG5lZWRGaW5pc2goc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmdjYisrXG4gICAgICAgIGZpbmlzaChzdHJlYW0sIHN0YXRlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUucGVuZGluZ2NiLS1cbiAgc3RhdGUuZmluaXNoZWQgPSB0cnVlXG4gIGNvbnN0IG9uZmluaXNoQ2FsbGJhY2tzID0gc3RhdGVba09uRmluaXNoZWRdLnNwbGljZSgwKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZmluaXNoQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgb25maW5pc2hDYWxsYmFja3NbaV0oKVxuICB9XG4gIHN0cmVhbS5lbWl0KCdmaW5pc2gnKVxuICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGwuXG4gICAgY29uc3QgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gICAgY29uc3QgYXV0b0Rlc3Ryb3kgPVxuICAgICAgIXJTdGF0ZSB8fFxuICAgICAgKHJTdGF0ZS5hdXRvRGVzdHJveSAmJlxuICAgICAgICAvLyBXZSBkb24ndCBleHBlY3QgdGhlIHJlYWRhYmxlIHRvIGV2ZXIgJ2VuZCdcbiAgICAgICAgLy8gaWYgcmVhZGFibGUgaXMgZXhwbGljaXRseSBzZXQgdG8gZmFsc2UuXG4gICAgICAgIChyU3RhdGUuZW5kRW1pdHRlZCB8fCByU3RhdGUucmVhZGFibGUgPT09IGZhbHNlKSlcbiAgICBpZiAoYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgICB9XG4gIH1cbn1cbk9iamVjdERlZmluZVByb3BlcnRpZXMoV3JpdGFibGUucHJvdG90eXBlLCB7XG4gIGNsb3NlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSA/IHRoaXMuX3dyaXRhYmxlU3RhdGUuY2xvc2VkIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3llZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSA/IHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkIDogZmFsc2VcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseSBtYW5hZ2luZyBkZXN0cm95ZWQuXG4gICAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3cml0YWJsZToge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCB3ID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuICAgICAgLy8gdy53cml0YWJsZSA9PT0gZmFsc2UgbWVhbnMgdGhhdCB0aGlzIGlzIHBhcnQgb2YgYSBEdXBsZXggc3RyZWFtXG4gICAgICAvLyB3aGVyZSB0aGUgd3JpdGFibGUgc2lkZSB3YXMgZGlzYWJsZWQgdXBvbiBjb25zdHJ1Y3Rpb24uXG4gICAgICAvLyBDb21wYXQuIFRoZSB1c2VyIG1pZ2h0IG1hbnVhbGx5IGRpc2FibGUgd3JpdGFibGUgc2lkZSB0aHJvdWdoXG4gICAgICAvLyBkZXByZWNhdGVkIHNldHRlci5cbiAgICAgIHJldHVybiAhIXcgJiYgdy53cml0YWJsZSAhPT0gZmFsc2UgJiYgIXcuZGVzdHJveWVkICYmICF3LmVycm9yZWQgJiYgIXcuZW5kaW5nICYmICF3LmVuZGVkXG4gICAgfSxcbiAgICBzZXQodmFsKSB7XG4gICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJsZS5cbiAgICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUud3JpdGFibGUgPSAhIXZhbFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVGaW5pc2hlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSA/IHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVPYmplY3RNb2RlOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlID8gdGhpcy5fd3JpdGFibGVTdGF0ZS5vYmplY3RNb2RlIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlQnVmZmVyOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKClcbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlRW5kZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgPyB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA6IGZhbHNlXG4gICAgfVxuICB9LFxuICB3cml0YWJsZU5lZWREcmFpbjoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCB3U3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gICAgICBpZiAoIXdTdGF0ZSkgcmV0dXJuIGZhbHNlXG4gICAgICByZXR1cm4gIXdTdGF0ZS5kZXN0cm95ZWQgJiYgIXdTdGF0ZS5lbmRpbmcgJiYgd1N0YXRlLm5lZWREcmFpblxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya1xuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVDb3JrZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgPyB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCA6IDBcbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlTGVuZ3RoOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoXG4gICAgfVxuICB9LFxuICBlcnJvcmVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlID8gdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvcmVkIDogbnVsbFxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVBYm9ydGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhKFxuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLndyaXRhYmxlICE9PSBmYWxzZSAmJlxuICAgICAgICAodGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvcmVkKSAmJlxuICAgICAgICAhdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZFxuICAgICAgKVxuICAgIH1cbiAgfVxufSlcbmNvbnN0IGRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95XG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuXG4gIC8vIEludm9rZSBwZW5kaW5nIGNhbGxiYWNrcy5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmJ1ZmZlcmVkSW5kZXggPCBzdGF0ZS5idWZmZXJlZC5sZW5ndGggfHwgc3RhdGVba09uRmluaXNoZWRdLmxlbmd0aCkpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVycm9yQnVmZmVyLCBzdGF0ZSlcbiAgfVxuICBkZXN0cm95LmNhbGwodGhpcywgZXJyLCBjYilcbiAgcmV0dXJuIHRoaXNcbn1cbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpXG59XG5Xcml0YWJsZS5wcm90b3R5cGVbRUUuY2FwdHVyZVJlamVjdGlvblN5bWJvbF0gPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZGVzdHJveShlcnIpXG59XG5sZXQgd2ViU3RyZWFtc0FkYXB0ZXJzXG5cbi8vIExhenkgdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlc1xuZnVuY3Rpb24gbGF6eVdlYlN0cmVhbXMoKSB7XG4gIGlmICh3ZWJTdHJlYW1zQWRhcHRlcnMgPT09IHVuZGVmaW5lZCkgd2ViU3RyZWFtc0FkYXB0ZXJzID0ge31cbiAgcmV0dXJuIHdlYlN0cmVhbXNBZGFwdGVyc1xufVxuV3JpdGFibGUuZnJvbVdlYiA9IGZ1bmN0aW9uICh3cml0YWJsZVN0cmVhbSwgb3B0aW9ucykge1xuICByZXR1cm4gbGF6eVdlYlN0cmVhbXMoKS5uZXdTdHJlYW1Xcml0YWJsZUZyb21Xcml0YWJsZVN0cmVhbSh3cml0YWJsZVN0cmVhbSwgb3B0aW9ucylcbn1cbldyaXRhYmxlLnRvV2ViID0gZnVuY3Rpb24gKHN0cmVhbVdyaXRhYmxlKSB7XG4gIHJldHVybiBsYXp5V2ViU3RyZWFtcygpLm5ld1dyaXRhYmxlU3RyZWFtRnJvbVN0cmVhbVdyaXRhYmxlKHN0cmVhbVdyaXRhYmxlKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/streams/writable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/internal/validators.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/validators.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint jsdoc/require-jsdoc: \"error\" */\n\n\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  NumberParseInt,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeExec,\n  String,\n  StringPrototypeToUpperCase,\n  StringPrototypeTrim\n} = __webpack_require__(/*! ../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst {\n  hideStackFrames,\n  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }\n} = __webpack_require__(/*! ../ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\")\nconst { normalizeEncoding } = __webpack_require__(/*! ../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\")\nconst { isAsyncFunction, isArrayBufferView } = (__webpack_require__(/*! ../ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\").types)\nconst signals = {}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0)\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === value >>> 0\n}\nconst octalReg = /^[0-7]+$/\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string'\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified, will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value, name, def) {\n  if (typeof value === 'undefined') {\n    value = def\n  }\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg, value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc)\n    }\n    value = NumberParseInt(value, 8)\n  }\n  validateUint32(value, name)\n  return value\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n})\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n  // The defaults for min and max correspond to the limits of 32-bit integers.\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames((value, name, positive = false) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  const min = positive ? 1 : 0\n  // 2 ** 32 === 4294967296\n  const max = 4294967295\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value)\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value, name, min = undefined, max) {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (\n    (min != null && value < min) ||\n    (max != null && value > max) ||\n    ((min != null || max != null) && NumberIsNaN(value))\n  ) {\n    throw new ERR_OUT_OF_RANGE(\n      name,\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,\n      value\n    )\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf, (v) => (typeof v === 'string' ? `'${v}'` : String(v))),\n      ', '\n    )\n    const reason = 'must be one of: ' + allowed\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value)\n}\n\n/**\n * @param {any} options\n * @param {string} key\n * @param {boolean} defaultValue\n * @returns {boolean}\n */\nfunction getOwnPropertyValueOrDefault(options, key, defaultValue) {\n  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key]\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames((value, name, options = null) => {\n  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false)\n  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false)\n  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false)\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray(value)) ||\n    (typeof value !== 'object' && (!allowFunction || typeof value !== 'function'))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value)\n  }\n})\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of \"dictionary\" here, which means any value\n *                                whose Type is either Undefined, Null, or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames((value, name) => {\n  if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value)\n  }\n})\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value)\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateString(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateBoolean(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */\n\n/** @type {validateAbortSignalArray} */\nfunction validateAbortSignalArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    const signal = value[i]\n    const indexedName = `${name}[${i}]`\n    if (signal == null) {\n      throw new ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal)\n    }\n    validateAbortSignal(signal, indexedName)\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal, name = 'signal') {\n  validateString(signal, name)\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)')\n    }\n    throw new ERR_UNKNOWN_SIGNAL(signal)\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames((buffer, name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer)\n  }\n})\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data, encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding)\n  const length = data.length\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`)\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number,\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port, name = 'Port', allowZero = true) {\n  if (\n    (typeof port !== 'number' && typeof port !== 'string') ||\n    (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n    +port !== +port >>> 0 ||\n    port > 0xffff ||\n    (port === 0 && !allowZero)\n  ) {\n    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero)\n  }\n  return port | 0\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n})\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value, name) => {\n  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value)\n})\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value, name, union) {\n  if (!ArrayPrototypeIncludes(union, value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value)\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value, name) {\n  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {\n    throw new ERR_INVALID_ARG_VALUE(\n      name,\n      value,\n      'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n    )\n  }\n}\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints, 'hints')\n    return hints\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length\n    let result = ''\n    if (hintsLength === 0) {\n      return result\n    }\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i]\n      validateLinkHeaderFormat(link, 'hints')\n      result += link\n      if (i !== hintsLength - 1) {\n        result += ', '\n      }\n    }\n    return result\n  }\n  throw new ERR_INVALID_ARG_VALUE(\n    'hints',\n    hints,\n    'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n  )\n}\nmodule.exports = {\n  isInt32,\n  isUint32,\n  parseFileMode,\n  validateArray,\n  validateStringArray,\n  validateBooleanArray,\n  validateAbortSignalArray,\n  validateBoolean,\n  validateBuffer,\n  validateDictionary,\n  validateEncoding,\n  validateFunction,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateObject,\n  validateOneOf,\n  validatePlainFunction,\n  validatePort,\n  validateSignalName,\n  validateString,\n  validateUint32,\n  validateUndefined,\n  validateUnion,\n  validateAbortSignal,\n  validateLinkHeaderValue\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC92YWxpZGF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHlGQUFxQjtBQUNqQztBQUNBO0FBQ0EsV0FBVztBQUNYLEVBQUUsRUFBRSxtQkFBTyxDQUFDLCtFQUFnQjtBQUM1QixRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsMkVBQWM7QUFDcEQsUUFBUSxxQ0FBcUMsRUFBRSx3R0FBNkI7QUFDNUU7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsS0FBSyxRQUFRLElBQUk7QUFDMUYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSyxRQUFRLElBQUk7QUFDNUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYTtBQUNiOztBQUVBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSyxRQUFRLElBQUk7QUFDNUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CLElBQUksT0FBTyxFQUFFLHlDQUF5QyxFQUFFLG9CQUFvQixJQUFJLE9BQU87QUFDcEg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjs7QUFFQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLEVBQUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7O0FBRUEsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLGdDQUFnQyxLQUFLLEdBQUcsRUFBRTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLGlDQUFpQyxLQUFLLEdBQUcsRUFBRTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0EsMkJBQTJCLEtBQUssR0FBRyxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLE9BQU87QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25COztBQUVBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsK0JBQStCO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU0sZ0JBQWdCOztBQUVsRTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGFBQWE7QUFDekU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V0aC1sb25kb24tMjAyNC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3ZhbGlkYXRvcnMuanM/NzdkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQganNkb2MvcmVxdWlyZS1qc2RvYzogXCJlcnJvclwiICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIEFycmF5SXNBcnJheSxcbiAgQXJyYXlQcm90b3R5cGVJbmNsdWRlcyxcbiAgQXJyYXlQcm90b3R5cGVKb2luLFxuICBBcnJheVByb3RvdHlwZU1hcCxcbiAgTnVtYmVySXNJbnRlZ2VyLFxuICBOdW1iZXJJc05hTixcbiAgTnVtYmVyTUFYX1NBRkVfSU5URUdFUixcbiAgTnVtYmVyTUlOX1NBRkVfSU5URUdFUixcbiAgTnVtYmVyUGFyc2VJbnQsXG4gIE9iamVjdFByb3RvdHlwZUhhc093blByb3BlcnR5LFxuICBSZWdFeHBQcm90b3R5cGVFeGVjLFxuICBTdHJpbmcsXG4gIFN0cmluZ1Byb3RvdHlwZVRvVXBwZXJDYXNlLFxuICBTdHJpbmdQcm90b3R5cGVUcmltXG59ID0gcmVxdWlyZSgnLi4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7XG4gIGhpZGVTdGFja0ZyYW1lcyxcbiAgY29kZXM6IHsgRVJSX1NPQ0tFVF9CQURfUE9SVCwgRVJSX0lOVkFMSURfQVJHX1RZUEUsIEVSUl9JTlZBTElEX0FSR19WQUxVRSwgRVJSX09VVF9PRl9SQU5HRSwgRVJSX1VOS05PV05fU0lHTkFMIH1cbn0gPSByZXF1aXJlKCcuLi9vdXJzL2Vycm9ycycpXG5jb25zdCB7IG5vcm1hbGl6ZUVuY29kaW5nIH0gPSByZXF1aXJlKCcuLi9vdXJzL3V0aWwnKVxuY29uc3QgeyBpc0FzeW5jRnVuY3Rpb24sIGlzQXJyYXlCdWZmZXJWaWV3IH0gPSByZXF1aXJlKCcuLi9vdXJzL3V0aWwnKS50eXBlc1xuY29uc3Qgc2lnbmFscyA9IHt9XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzSW50MzIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSAodmFsdWUgfCAwKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1VpbnQzMih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID4+PiAwXG59XG5jb25zdCBvY3RhbFJlZyA9IC9eWzAtN10rJC9cbmNvbnN0IG1vZGVEZXNjID0gJ211c3QgYmUgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciBvciBhbiBvY3RhbCBzdHJpbmcnXG5cbi8qKlxuICogUGFyc2UgYW5kIHZhbGlkYXRlIHZhbHVlcyB0aGF0IHdpbGwgYmUgY29udmVydGVkIGludG8gbW9kZV90ICh0aGUgU18qXG4gKiBjb25zdGFudHMpLiBPbmx5IHZhbGlkIG51bWJlcnMgYW5kIG9jdGFsIHN0cmluZ3MgYXJlIGFsbG93ZWQuIFRoZXkgY291bGQgYmVcbiAqIGNvbnZlcnRlZCB0byAzMi1iaXQgdW5zaWduZWQgaW50ZWdlcnMgb3Igbm9uLW5lZ2F0aXZlIHNpZ25lZCBpbnRlZ2VycyBpbiB0aGVcbiAqIEMrKyBsYW5kLCBidXQgYW55IHZhbHVlIGhpZ2hlciB0aGFuIDBvNzc3IHdpbGwgcmVzdWx0IGluIHBsYXRmb3JtLXNwZWNpZmljXG4gKiBiZWhhdmlvcnMuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlcyB0byBiZSB2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gW2RlZl0gSWYgc3BlY2lmaWVkLCB3aWxsIGJlIHJldHVybmVkIGZvciBpbnZhbGlkIHZhbHVlc1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcGFyc2VGaWxlTW9kZSh2YWx1ZSwgbmFtZSwgZGVmKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFsdWUgPSBkZWZcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChSZWdFeHBQcm90b3R5cGVFeGVjKG9jdGFsUmVnLCB2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUobmFtZSwgdmFsdWUsIG1vZGVEZXNjKVxuICAgIH1cbiAgICB2YWx1ZSA9IE51bWJlclBhcnNlSW50KHZhbHVlLCA4KVxuICB9XG4gIHZhbGlkYXRlVWludDMyKHZhbHVlLCBuYW1lKVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVJbnRlZ2VyXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IFttaW5dXG4gKiBAcGFyYW0ge251bWJlcn0gW21heF1cbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIG51bWJlcn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlSW50ZWdlcn0gKi9cbmNvbnN0IHZhbGlkYXRlSW50ZWdlciA9IGhpZGVTdGFja0ZyYW1lcygodmFsdWUsIG5hbWUsIG1pbiA9IE51bWJlck1JTl9TQUZFX0lOVEVHRVIsIG1heCA9IE51bWJlck1BWF9TQUZFX0lOVEVHRVIpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIGlmICghTnVtYmVySXNJbnRlZ2VyKHZhbHVlKSkgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UobmFtZSwgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRShuYW1lLCBgPj0gJHttaW59ICYmIDw9ICR7bWF4fWAsIHZhbHVlKVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVJbnQzMlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluXVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhdXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBudW1iZXJ9XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZUludDMyfSAqL1xuY29uc3QgdmFsaWRhdGVJbnQzMiA9IGhpZGVTdGFja0ZyYW1lcygodmFsdWUsIG5hbWUsIG1pbiA9IC0yMTQ3NDgzNjQ4LCBtYXggPSAyMTQ3NDgzNjQ3KSA9PiB7XG4gIC8vIFRoZSBkZWZhdWx0cyBmb3IgbWluIGFuZCBtYXggY29ycmVzcG9uZCB0byB0aGUgbGltaXRzIG9mIDMyLWJpdCBpbnRlZ2Vycy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG4gIGlmICghTnVtYmVySXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKG5hbWUsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cbiAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UobmFtZSwgYD49ICR7bWlufSAmJiA8PSAke21heH1gLCB2YWx1ZSlcbiAgfVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVVaW50MzJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcnxib29sZWFufSBbcG9zaXRpdmU9ZmFsc2VdXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBudW1iZXJ9XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZVVpbnQzMn0gKi9cbmNvbnN0IHZhbGlkYXRlVWludDMyID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSwgcG9zaXRpdmUgPSBmYWxzZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbiAgaWYgKCFOdW1iZXJJc0ludGVnZXIodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UobmFtZSwgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuICBjb25zdCBtaW4gPSBwb3NpdGl2ZSA/IDEgOiAwXG4gIC8vIDIgKiogMzIgPT09IDQyOTQ5NjcyOTZcbiAgY29uc3QgbWF4ID0gNDI5NDk2NzI5NVxuICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRShuYW1lLCBgPj0gJHttaW59ICYmIDw9ICR7bWF4fWAsIHZhbHVlKVxuICB9XG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZVN0cmluZ1xuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIHN0cmluZ31cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlU3RyaW5nfSAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnc3RyaW5nJywgdmFsdWUpXG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlTnVtYmVyXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IFttaW5dXG4gKiBAcGFyYW0ge251bWJlcn0gW21heF1cbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIG51bWJlcn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlTnVtYmVyfSAqL1xuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIodmFsdWUsIG5hbWUsIG1pbiA9IHVuZGVmaW5lZCwgbWF4KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICBpZiAoXG4gICAgKG1pbiAhPSBudWxsICYmIHZhbHVlIDwgbWluKSB8fFxuICAgIChtYXggIT0gbnVsbCAmJiB2YWx1ZSA+IG1heCkgfHxcbiAgICAoKG1pbiAhPSBudWxsIHx8IG1heCAhPSBudWxsKSAmJiBOdW1iZXJJc05hTih2YWx1ZSkpXG4gICkge1xuICAgIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKFxuICAgICAgbmFtZSxcbiAgICAgIGAke21pbiAhPSBudWxsID8gYD49ICR7bWlufWAgOiAnJ30ke21pbiAhPSBudWxsICYmIG1heCAhPSBudWxsID8gJyAmJiAnIDogJyd9JHttYXggIT0gbnVsbCA/IGA8PSAke21heH1gIDogJyd9YCxcbiAgICAgIHZhbHVlXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlT25lT2ZcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtUW119IG9uZU9mXG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZU9uZU9mfSAqL1xuY29uc3QgdmFsaWRhdGVPbmVPZiA9IGhpZGVTdGFja0ZyYW1lcygodmFsdWUsIG5hbWUsIG9uZU9mKSA9PiB7XG4gIGlmICghQXJyYXlQcm90b3R5cGVJbmNsdWRlcyhvbmVPZiwgdmFsdWUpKSB7XG4gICAgY29uc3QgYWxsb3dlZCA9IEFycmF5UHJvdG90eXBlSm9pbihcbiAgICAgIEFycmF5UHJvdG90eXBlTWFwKG9uZU9mLCAodikgPT4gKHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IGAnJHt2fSdgIDogU3RyaW5nKHYpKSksXG4gICAgICAnLCAnXG4gICAgKVxuICAgIGNvbnN0IHJlYXNvbiA9ICdtdXN0IGJlIG9uZSBvZjogJyArIGFsbG93ZWRcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKG5hbWUsIHZhbHVlLCByZWFzb24pXG4gIH1cbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlQm9vbGVhblxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIGJvb2xlYW59XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZUJvb2xlYW59ICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJvb2xlYW4odmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ2Jvb2xlYW4nLCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtib29sZWFufSBkZWZhdWx0VmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVZhbHVlT3JEZWZhdWx0KG9wdGlvbnMsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBvcHRpb25zID09IG51bGwgfHwgIU9iamVjdFByb3RvdHlwZUhhc093blByb3BlcnR5KG9wdGlvbnMsIGtleSkgPyBkZWZhdWx0VmFsdWUgOiBvcHRpb25zW2tleV1cbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVPYmplY3RcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3tcbiAqICAgYWxsb3dBcnJheT86IGJvb2xlYW4sXG4gKiAgIGFsbG93RnVuY3Rpb24/OiBib29sZWFuLFxuICogICBudWxsYWJsZT86IGJvb2xlYW5cbiAqIH19IFtvcHRpb25zXVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVPYmplY3R9ICovXG5jb25zdCB2YWxpZGF0ZU9iamVjdCA9IGhpZGVTdGFja0ZyYW1lcygodmFsdWUsIG5hbWUsIG9wdGlvbnMgPSBudWxsKSA9PiB7XG4gIGNvbnN0IGFsbG93QXJyYXkgPSBnZXRPd25Qcm9wZXJ0eVZhbHVlT3JEZWZhdWx0KG9wdGlvbnMsICdhbGxvd0FycmF5JywgZmFsc2UpXG4gIGNvbnN0IGFsbG93RnVuY3Rpb24gPSBnZXRPd25Qcm9wZXJ0eVZhbHVlT3JEZWZhdWx0KG9wdGlvbnMsICdhbGxvd0Z1bmN0aW9uJywgZmFsc2UpXG4gIGNvbnN0IG51bGxhYmxlID0gZ2V0T3duUHJvcGVydHlWYWx1ZU9yRGVmYXVsdChvcHRpb25zLCAnbnVsbGFibGUnLCBmYWxzZSlcbiAgaWYgKFxuICAgICghbnVsbGFibGUgJiYgdmFsdWUgPT09IG51bGwpIHx8XG4gICAgKCFhbGxvd0FycmF5ICYmIEFycmF5SXNBcnJheSh2YWx1ZSkpIHx8XG4gICAgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgKCFhbGxvd0Z1bmN0aW9uIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykpXG4gICkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnT2JqZWN0JywgdmFsdWUpXG4gIH1cbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlRGljdGlvbmFyeSAtIFdlIGFyZSB1c2luZyB0aGUgV2ViIElETCBTdGFuZGFyZCBkZWZpbml0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgXCJkaWN0aW9uYXJ5XCIgaGVyZSwgd2hpY2ggbWVhbnMgYW55IHZhbHVlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hvc2UgVHlwZSBpcyBlaXRoZXIgVW5kZWZpbmVkLCBOdWxsLCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdCAod2hpY2ggaW5jbHVkZXMgZnVuY3Rpb25zKS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAc2VlIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtZGljdGlvbmFyeVxuICogQHNlZSBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jdGFibGUtdHlwZW9mLW9wZXJhdG9yLXJlc3VsdHNcbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlRGljdGlvbmFyeX0gKi9cbmNvbnN0IHZhbGlkYXRlRGljdGlvbmFyeSA9IGhpZGVTdGFja0ZyYW1lcygodmFsdWUsIG5hbWUpID0+IHtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ2EgZGljdGlvbmFyeScsIHZhbHVlKVxuICB9XG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUFycmF5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IFttaW5MZW5ndGhdXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBhbnlbXX1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlQXJyYXl9ICovXG5jb25zdCB2YWxpZGF0ZUFycmF5ID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSwgbWluTGVuZ3RoID0gMCkgPT4ge1xuICBpZiAoIUFycmF5SXNBcnJheSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ0FycmF5JywgdmFsdWUpXG4gIH1cbiAgaWYgKHZhbHVlLmxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgIGNvbnN0IHJlYXNvbiA9IGBtdXN0IGJlIGxvbmdlciB0aGFuICR7bWluTGVuZ3RofWBcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKG5hbWUsIHZhbHVlLCByZWFzb24pXG4gIH1cbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlU3RyaW5nQXJyYXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBzdHJpbmdbXX1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlU3RyaW5nQXJyYXl9ICovXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZ0FycmF5KHZhbHVlLCBuYW1lKSB7XG4gIHZhbGlkYXRlQXJyYXkodmFsdWUsIG5hbWUpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZVN0cmluZyh2YWx1ZVtpXSwgYCR7bmFtZX1bJHtpfV1gKVxuICB9XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlQm9vbGVhbkFycmF5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgYm9vbGVhbltdfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVCb29sZWFuQXJyYXl9ICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJvb2xlYW5BcnJheSh2YWx1ZSwgbmFtZSkge1xuICB2YWxpZGF0ZUFycmF5KHZhbHVlLCBuYW1lKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVCb29sZWFuKHZhbHVlW2ldLCBgJHtuYW1lfVske2l9XWApXG4gIH1cbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVBYm9ydFNpZ25hbEFycmF5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgQWJvcnRTaWduYWxbXX1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlQWJvcnRTaWduYWxBcnJheX0gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQWJvcnRTaWduYWxBcnJheSh2YWx1ZSwgbmFtZSkge1xuICB2YWxpZGF0ZUFycmF5KHZhbHVlLCBuYW1lKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2lnbmFsID0gdmFsdWVbaV1cbiAgICBjb25zdCBpbmRleGVkTmFtZSA9IGAke25hbWV9WyR7aX1dYFxuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKGluZGV4ZWROYW1lLCAnQWJvcnRTaWduYWwnLCBzaWduYWwpXG4gICAgfVxuICAgIHZhbGlkYXRlQWJvcnRTaWduYWwoc2lnbmFsLCBpbmRleGVkTmFtZSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gc2lnbmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWU9J3NpZ25hbCddXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyBzaWduYWwgaXMga2V5b2Ygc2lnbmFsc31cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTaWduYWxOYW1lKHNpZ25hbCwgbmFtZSA9ICdzaWduYWwnKSB7XG4gIHZhbGlkYXRlU3RyaW5nKHNpZ25hbCwgbmFtZSlcbiAgaWYgKHNpZ25hbHNbc2lnbmFsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHNpZ25hbHNbU3RyaW5nUHJvdG90eXBlVG9VcHBlckNhc2Uoc2lnbmFsKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9VTktOT1dOX1NJR05BTChzaWduYWwgKyAnIChzaWduYWxzIG11c3QgdXNlIGFsbCBjYXBpdGFsIGxldHRlcnMpJylcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVSUl9VTktOT1dOX1NJR05BTChzaWduYWwpXG4gIH1cbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVCdWZmZXJcbiAqIEBwYXJhbSB7Kn0gYnVmZmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWU9J2J1ZmZlciddXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyBidWZmZXIgaXMgQXJyYXlCdWZmZXJWaWV3fVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVCdWZmZXJ9ICovXG5jb25zdCB2YWxpZGF0ZUJ1ZmZlciA9IGhpZGVTdGFja0ZyYW1lcygoYnVmZmVyLCBuYW1lID0gJ2J1ZmZlcicpID0+IHtcbiAgaWYgKCFpc0FycmF5QnVmZmVyVmlldyhidWZmZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsIFsnQnVmZmVyJywgJ1R5cGVkQXJyYXknLCAnRGF0YVZpZXcnXSwgYnVmZmVyKVxuICB9XG59KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFbmNvZGluZyhkYXRhLCBlbmNvZGluZykge1xuICBjb25zdCBub3JtYWxpemVkRW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZylcbiAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGhcbiAgaWYgKG5vcm1hbGl6ZWRFbmNvZGluZyA9PT0gJ2hleCcgJiYgbGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoJ2VuY29kaW5nJywgZW5jb2RpbmcsIGBpcyBpbnZhbGlkIGZvciBkYXRhIG9mIGxlbmd0aCAke2xlbmd0aH1gKVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgdGhhdCB0aGUgcG9ydCBudW1iZXIgaXMgbm90IE5hTiB3aGVuIGNvZXJjZWQgdG8gYSBudW1iZXIsXG4gKiBpcyBhbiBpbnRlZ2VyIGFuZCB0aGF0IGl0IGZhbGxzIHdpdGhpbiB0aGUgbGVnYWwgcmFuZ2Ugb2YgcG9ydCBudW1iZXJzLlxuICogQHBhcmFtIHsqfSBwb3J0XG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWU9J1BvcnQnXVxuICogQHBhcmFtIHtib29sZWFufSBbYWxsb3daZXJvPXRydWVdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVBvcnQocG9ydCwgbmFtZSA9ICdQb3J0JywgYWxsb3daZXJvID0gdHJ1ZSkge1xuICBpZiAoXG4gICAgKHR5cGVvZiBwb3J0ICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgcG9ydCAhPT0gJ3N0cmluZycpIHx8XG4gICAgKHR5cGVvZiBwb3J0ID09PSAnc3RyaW5nJyAmJiBTdHJpbmdQcm90b3R5cGVUcmltKHBvcnQpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICArcG9ydCAhPT0gK3BvcnQgPj4+IDAgfHxcbiAgICBwb3J0ID4gMHhmZmZmIHx8XG4gICAgKHBvcnQgPT09IDAgJiYgIWFsbG93WmVybylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9TT0NLRVRfQkFEX1BPUlQobmFtZSwgcG9ydCwgYWxsb3daZXJvKVxuICB9XG4gIHJldHVybiBwb3J0IHwgMFxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUFib3J0U2lnbmFsXG4gKiBAcGFyYW0geyp9IHNpZ25hbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlQWJvcnRTaWduYWx9ICovXG5jb25zdCB2YWxpZGF0ZUFib3J0U2lnbmFsID0gaGlkZVN0YWNrRnJhbWVzKChzaWduYWwsIG5hbWUpID0+IHtcbiAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkICYmIChzaWduYWwgPT09IG51bGwgfHwgdHlwZW9mIHNpZ25hbCAhPT0gJ29iamVjdCcgfHwgISgnYWJvcnRlZCcgaW4gc2lnbmFsKSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ0Fib3J0U2lnbmFsJywgc2lnbmFsKVxuICB9XG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgRnVuY3Rpb259XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZUZ1bmN0aW9ufSAqL1xuY29uc3QgdmFsaWRhdGVGdW5jdGlvbiA9IGhpZGVTdGFja0ZyYW1lcygodmFsdWUsIG5hbWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdGdW5jdGlvbicsIHZhbHVlKVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVQbGFpbkZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgRnVuY3Rpb259XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZVBsYWluRnVuY3Rpb259ICovXG5jb25zdCB2YWxpZGF0ZVBsYWluRnVuY3Rpb24gPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgfHwgaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSkgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdGdW5jdGlvbicsIHZhbHVlKVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVVbmRlZmluZWRcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyB1bmRlZmluZWR9XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZVVuZGVmaW5lZH0gKi9cbmNvbnN0IHZhbGlkYXRlVW5kZWZpbmVkID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICd1bmRlZmluZWQnLCB2YWx1ZSlcbn0pXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1RbXX0gdW5pb25cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVVbmlvbih2YWx1ZSwgbmFtZSwgdW5pb24pIHtcbiAgaWYgKCFBcnJheVByb3RvdHlwZUluY2x1ZGVzKHVuaW9uLCB2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgYCgnJHtBcnJheVByb3RvdHlwZUpvaW4odW5pb24sICd8Jyl9JylgLCB2YWx1ZSlcbiAgfVxufVxuXG4vKlxuICBUaGUgcnVsZXMgZm9yIHRoZSBMaW5rIGhlYWRlciBmaWVsZCBhcmUgZGVzY3JpYmVkIGhlcmU6XG4gIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM4Mjg4Lmh0bWwjc2VjdGlvbi0zXG5cbiAgVGhpcyByZWdleCB2YWxpZGF0ZXMgYW55IHN0cmluZyBzdXJyb3VuZGVkIGJ5IGFuZ2xlIGJyYWNrZXRzXG4gIChub3QgbmVjZXNzYXJpbHkgYSB2YWxpZCBVUkkgcmVmZXJlbmNlKSBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmVcbiAgbGluay1wYXJhbXMgc2VwYXJhdGVkIGJ5IHNlbWljb2xvbnMuXG4qL1xuY29uc3QgbGlua1ZhbHVlUmVnRXhwID0gL14oPzo8W14+XSo+KSg/Olxccyo7XFxzKlteO1wiXFxzXSsoPzo9KFwiKT9bXjtcIlxcc10qXFwxKT8pKiQvXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUxpbmtIZWFkZXJGb3JtYXQodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgIVJlZ0V4cFByb3RvdHlwZUV4ZWMobGlua1ZhbHVlUmVnRXhwLCB2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKFxuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgJ211c3QgYmUgYW4gYXJyYXkgb3Igc3RyaW5nIG9mIGZvcm1hdCBcIjwvc3R5bGVzLmNzcz47IHJlbD1wcmVsb2FkOyBhcz1zdHlsZVwiJ1xuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBoaW50c1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUxpbmtIZWFkZXJWYWx1ZShoaW50cykge1xuICBpZiAodHlwZW9mIGhpbnRzID09PSAnc3RyaW5nJykge1xuICAgIHZhbGlkYXRlTGlua0hlYWRlckZvcm1hdChoaW50cywgJ2hpbnRzJylcbiAgICByZXR1cm4gaGludHNcbiAgfSBlbHNlIGlmIChBcnJheUlzQXJyYXkoaGludHMpKSB7XG4gICAgY29uc3QgaGludHNMZW5ndGggPSBoaW50cy5sZW5ndGhcbiAgICBsZXQgcmVzdWx0ID0gJydcbiAgICBpZiAoaGludHNMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoaW50c0xlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5rID0gaGludHNbaV1cbiAgICAgIHZhbGlkYXRlTGlua0hlYWRlckZvcm1hdChsaW5rLCAnaGludHMnKVxuICAgICAgcmVzdWx0ICs9IGxpbmtcbiAgICAgIGlmIChpICE9PSBoaW50c0xlbmd0aCAtIDEpIHtcbiAgICAgICAgcmVzdWx0ICs9ICcsICdcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG4gIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoXG4gICAgJ2hpbnRzJyxcbiAgICBoaW50cyxcbiAgICAnbXVzdCBiZSBhbiBhcnJheSBvciBzdHJpbmcgb2YgZm9ybWF0IFwiPC9zdHlsZXMuY3NzPjsgcmVsPXByZWxvYWQ7IGFzPXN0eWxlXCInXG4gIClcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0ludDMyLFxuICBpc1VpbnQzMixcbiAgcGFyc2VGaWxlTW9kZSxcbiAgdmFsaWRhdGVBcnJheSxcbiAgdmFsaWRhdGVTdHJpbmdBcnJheSxcbiAgdmFsaWRhdGVCb29sZWFuQXJyYXksXG4gIHZhbGlkYXRlQWJvcnRTaWduYWxBcnJheSxcbiAgdmFsaWRhdGVCb29sZWFuLFxuICB2YWxpZGF0ZUJ1ZmZlcixcbiAgdmFsaWRhdGVEaWN0aW9uYXJ5LFxuICB2YWxpZGF0ZUVuY29kaW5nLFxuICB2YWxpZGF0ZUZ1bmN0aW9uLFxuICB2YWxpZGF0ZUludDMyLFxuICB2YWxpZGF0ZUludGVnZXIsXG4gIHZhbGlkYXRlTnVtYmVyLFxuICB2YWxpZGF0ZU9iamVjdCxcbiAgdmFsaWRhdGVPbmVPZixcbiAgdmFsaWRhdGVQbGFpbkZ1bmN0aW9uLFxuICB2YWxpZGF0ZVBvcnQsXG4gIHZhbGlkYXRlU2lnbmFsTmFtZSxcbiAgdmFsaWRhdGVTdHJpbmcsXG4gIHZhbGlkYXRlVWludDMyLFxuICB2YWxpZGF0ZVVuZGVmaW5lZCxcbiAgdmFsaWRhdGVVbmlvbixcbiAgdmFsaWRhdGVBYm9ydFNpZ25hbCxcbiAgdmFsaWRhdGVMaW5rSGVhZGVyVmFsdWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/internal/validators.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/ours/errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/readable-stream/lib/ours/errors.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { format, inspect, AggregateError: CustomAggregateError } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\")\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at\n\n  https://github.com/nodejs/node/blob/master/lib/internal/errors.js\n\n  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)\n  with the upstream file.\n*/\n\nconst AggregateError = globalThis.AggregateError || CustomAggregateError\nconst kIsNodeError = Symbol('kIsNodeError')\nconst kTypes = [\n  'string',\n  'function',\n  'number',\n  'object',\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function',\n  'Object',\n  'boolean',\n  'bigint',\n  'symbol'\n]\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/\nconst nodeInternalPrefix = '__node_internal_'\nconst codes = {}\nfunction assert(value, message) {\n  if (!value) {\n    throw new codes.ERR_INTERNAL_ASSERTION(message)\n  }\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\nfunction getMessage(key, msg, args) {\n  if (typeof msg === 'function') {\n    assert(\n      msg.length <= args.length,\n      // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`\n    )\n    return msg(...args)\n  }\n  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length\n  assert(\n    expectedLength === args.length,\n    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`\n  )\n  if (args.length === 0) {\n    return msg\n  }\n  return format(msg, ...args)\n}\nfunction E(code, message, Base) {\n  if (!Base) {\n    Base = Error\n  }\n  class NodeError extends Base {\n    constructor(...args) {\n      super(getMessage(code, message, args))\n    }\n    toString() {\n      return `${this.name} [${code}]: ${this.message}`\n    }\n  }\n  Object.defineProperties(NodeError.prototype, {\n    name: {\n      value: Base.name,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    },\n    toString: {\n      value() {\n        return `${this.name} [${code}]: ${this.message}`\n      },\n      writable: true,\n      enumerable: false,\n      configurable: true\n    }\n  })\n  NodeError.prototype.code = code\n  NodeError.prototype[kIsNodeError] = true\n  codes[code] = NodeError\n}\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name\n  Object.defineProperty(fn, 'name', {\n    value: hidden\n  })\n  return fn\n}\nfunction aggregateTwoErrors(innerError, outerError) {\n  if (innerError && outerError && innerError !== outerError) {\n    if (Array.isArray(outerError.errors)) {\n      // If `outerError` is already an `AggregateError`.\n      outerError.errors.push(innerError)\n      return outerError\n    }\n    const err = new AggregateError([outerError, innerError], outerError.message)\n    err.code = outerError.code\n    return err\n  }\n  return innerError || outerError\n}\nclass AbortError extends Error {\n  constructor(message = 'The operation was aborted', options = undefined) {\n    if (options !== undefined && typeof options !== 'object') {\n      throw new codes.ERR_INVALID_ARG_TYPE('options', 'Object', options)\n    }\n    super(message, options)\n    this.code = 'ABORT_ERR'\n    this.name = 'AbortError'\n  }\n}\nE('ERR_ASSERTION', '%s', Error)\nE(\n  'ERR_INVALID_ARG_TYPE',\n  (name, expected, actual) => {\n    assert(typeof name === 'string', \"'name' must be a string\")\n    if (!Array.isArray(expected)) {\n      expected = [expected]\n    }\n    let msg = 'The '\n    if (name.endsWith(' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `\n    } else {\n      msg += `\"${name}\" ${name.includes('.') ? 'property' : 'argument'} `\n    }\n    msg += 'must be '\n    const types = []\n    const instances = []\n    const other = []\n    for (const value of expected) {\n      assert(typeof value === 'string', 'All expected entries have to be of type string')\n      if (kTypes.includes(value)) {\n        types.push(value.toLowerCase())\n      } else if (classRegExp.test(value)) {\n        instances.push(value)\n      } else {\n        assert(value !== 'object', 'The value \"object\" should be written as \"Object\"')\n        other.push(value)\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = types.indexOf('object')\n      if (pos !== -1) {\n        types.splice(types, pos, 1)\n        instances.push('Object')\n      }\n    }\n    if (types.length > 0) {\n      switch (types.length) {\n        case 1:\n          msg += `of type ${types[0]}`\n          break\n        case 2:\n          msg += `one of type ${types[0]} or ${types[1]}`\n          break\n        default: {\n          const last = types.pop()\n          msg += `one of type ${types.join(', ')}, or ${last}`\n        }\n      }\n      if (instances.length > 0 || other.length > 0) {\n        msg += ' or '\n      }\n    }\n    if (instances.length > 0) {\n      switch (instances.length) {\n        case 1:\n          msg += `an instance of ${instances[0]}`\n          break\n        case 2:\n          msg += `an instance of ${instances[0]} or ${instances[1]}`\n          break\n        default: {\n          const last = instances.pop()\n          msg += `an instance of ${instances.join(', ')}, or ${last}`\n        }\n      }\n      if (other.length > 0) {\n        msg += ' or '\n      }\n    }\n    switch (other.length) {\n      case 0:\n        break\n      case 1:\n        if (other[0].toLowerCase() !== other[0]) {\n          msg += 'an '\n        }\n        msg += `${other[0]}`\n        break\n      case 2:\n        msg += `one of ${other[0]} or ${other[1]}`\n        break\n      default: {\n        const last = other.pop()\n        msg += `one of ${other.join(', ')}, or ${last}`\n      }\n    }\n    if (actual == null) {\n      msg += `. Received ${actual}`\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`\n    } else if (typeof actual === 'object') {\n      var _actual$constructor\n      if (\n        (_actual$constructor = actual.constructor) !== null &&\n        _actual$constructor !== undefined &&\n        _actual$constructor.name\n      ) {\n        msg += `. Received an instance of ${actual.constructor.name}`\n      } else {\n        const inspected = inspect(actual, {\n          depth: -1\n        })\n        msg += `. Received ${inspected}`\n      }\n    } else {\n      let inspected = inspect(actual, {\n        colors: false\n      })\n      if (inspected.length > 25) {\n        inspected = `${inspected.slice(0, 25)}...`\n      }\n      msg += `. Received type ${typeof actual} (${inspected})`\n    }\n    return msg\n  },\n  TypeError\n)\nE(\n  'ERR_INVALID_ARG_VALUE',\n  (name, value, reason = 'is invalid') => {\n    let inspected = inspect(value)\n    if (inspected.length > 128) {\n      inspected = inspected.slice(0, 128) + '...'\n    }\n    const type = name.includes('.') ? 'property' : 'argument'\n    return `The ${type} '${name}' ${reason}. Received ${inspected}`\n  },\n  TypeError\n)\nE(\n  'ERR_INVALID_RETURN_VALUE',\n  (input, name, value) => {\n    var _value$constructor\n    const type =\n      value !== null &&\n      value !== undefined &&\n      (_value$constructor = value.constructor) !== null &&\n      _value$constructor !== undefined &&\n      _value$constructor.name\n        ? `instance of ${value.constructor.name}`\n        : `type ${typeof value}`\n    return `Expected ${input} to be returned from the \"${name}\"` + ` function but got ${type}.`\n  },\n  TypeError\n)\nE(\n  'ERR_MISSING_ARGS',\n  (...args) => {\n    assert(args.length > 0, 'At least one arg needs to be specified')\n    let msg\n    const len = args.length\n    args = (Array.isArray(args) ? args : [args]).map((a) => `\"${a}\"`).join(' or ')\n    switch (len) {\n      case 1:\n        msg += `The ${args[0]} argument`\n        break\n      case 2:\n        msg += `The ${args[0]} and ${args[1]} arguments`\n        break\n      default:\n        {\n          const last = args.pop()\n          msg += `The ${args.join(', ')}, and ${last} arguments`\n        }\n        break\n    }\n    return `${msg} must be specified`\n  },\n  TypeError\n)\nE(\n  'ERR_OUT_OF_RANGE',\n  (str, range, input) => {\n    assert(range, 'Missing \"range\" argument')\n    let received\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    } else {\n      received = inspect(input)\n    }\n    return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`\n  },\n  RangeError\n)\nE('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error)\nE('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error)\nE('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error)\nE('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error)\nE('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error)\nE('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError)\nE('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error)\nE('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error)\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error)\nE('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error)\nE('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError)\nmodule.exports = {\n  AbortError,\n  aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n  hideStackFrames,\n  codes\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9vdXJzL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHdEQUF3RCxFQUFFLG1CQUFPLENBQUMscUVBQVE7O0FBRWxGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QixjQUFjLG9CQUFvQixFQUFFLElBQUk7QUFDeEM7QUFDQSxZQUFZLGdCQUFnQixFQUFFLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNLGlDQUFpQyxZQUFZLHNDQUFzQyxXQUFXO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTSxpQ0FBaUMsWUFBWSxzQ0FBc0MsZUFBZTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVyxHQUFHLEtBQUssS0FBSyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQixXQUFXLEdBQUcsS0FBSyxLQUFLLGFBQWE7QUFDdkQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLE1BQU07QUFDTixpQkFBaUIsS0FBSyxJQUFJLDhDQUE4QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEtBQUssU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCLE9BQU8sS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0EsbUNBQW1DLGNBQWMsS0FBSyxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUIsT0FBTyxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBLHlCQUF5QixVQUFVLEtBQUssU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCLE9BQU8sS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQyxNQUFNO0FBQ04sb0NBQW9DLFlBQVk7QUFDaEQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEUsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQSxnQ0FBZ0MsZUFBZSxHQUFHLFVBQVU7QUFDNUQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNLEdBQUcsS0FBSyxJQUFJLE9BQU8sYUFBYSxVQUFVO0FBQ2xFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hELGtCQUFrQixhQUFhO0FBQy9CLHVCQUF1QixPQUFPLDJCQUEyQixLQUFLLDBCQUEwQixLQUFLO0FBQzdGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLEVBQUU7QUFDbEU7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUyxNQUFNLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCLFFBQVEsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxnQ0FBZ0MsTUFBTSxhQUFhLFNBQVM7QUFDNUYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXRoLWxvbmRvbi0yMDI0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy9lcnJvcnMuanM/MDc1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBmb3JtYXQsIGluc3BlY3QsIEFnZ3JlZ2F0ZUVycm9yOiBDdXN0b21BZ2dyZWdhdGVFcnJvciB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLypcbiAgVGhpcyBmaWxlIGlzIGEgcmVkdWNlZCBhbmQgYWRhcHRlZCB2ZXJzaW9uIG9mIHRoZSBtYWluIGxpYi9pbnRlcm5hbC9lcnJvcnMuanMgZmlsZSBkZWZpbmVkIGF0XG5cbiAgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuICBEb24ndCB0cnkgdG8gcmVwbGFjZSB3aXRoIHRoZSBvcmlnaW5hbCBmaWxlIGFuZCBrZWVwIGl0IHVwIHRvIGRhdGUgKHN0YXJ0aW5nIGZyb20gRSguLi4pIGRlZmluaXRpb25zKVxuICB3aXRoIHRoZSB1cHN0cmVhbSBmaWxlLlxuKi9cblxuY29uc3QgQWdncmVnYXRlRXJyb3IgPSBnbG9iYWxUaGlzLkFnZ3JlZ2F0ZUVycm9yIHx8IEN1c3RvbUFnZ3JlZ2F0ZUVycm9yXG5jb25zdCBrSXNOb2RlRXJyb3IgPSBTeW1ib2woJ2tJc05vZGVFcnJvcicpXG5jb25zdCBrVHlwZXMgPSBbXG4gICdzdHJpbmcnLFxuICAnZnVuY3Rpb24nLFxuICAnbnVtYmVyJyxcbiAgJ29iamVjdCcsXG4gIC8vIEFjY2VwdCAnRnVuY3Rpb24nIGFuZCAnT2JqZWN0JyBhcyBhbHRlcm5hdGl2ZSB0byB0aGUgbG93ZXIgY2FzZWQgdmVyc2lvbi5cbiAgJ0Z1bmN0aW9uJyxcbiAgJ09iamVjdCcsXG4gICdib29sZWFuJyxcbiAgJ2JpZ2ludCcsXG4gICdzeW1ib2wnXG5dXG5jb25zdCBjbGFzc1JlZ0V4cCA9IC9eKFtBLVpdW2EtejAtOV0qKSskL1xuY29uc3Qgbm9kZUludGVybmFsUHJlZml4ID0gJ19fbm9kZV9pbnRlcm5hbF8nXG5jb25zdCBjb2RlcyA9IHt9XG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBjb2Rlcy5FUlJfSU5URVJOQUxfQVNTRVJUSU9OKG1lc3NhZ2UpXG4gIH1cbn1cblxuLy8gT25seSB1c2UgdGhpcyBmb3IgaW50ZWdlcnMhIERlY2ltYWwgbnVtYmVycyBkbyBub3Qgd29yayB3aXRoIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShrZXksIG1zZywgYXJncykge1xuICBpZiAodHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2VydChcbiAgICAgIG1zZy5sZW5ndGggPD0gYXJncy5sZW5ndGgsXG4gICAgICAvLyBEZWZhdWx0IG9wdGlvbnMgZG8gbm90IGNvdW50LlxuICAgICAgYENvZGU6ICR7a2V5fTsgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBsZW5ndGggKCR7YXJncy5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZWQgb25lcyAoJHttc2cubGVuZ3RofSkuYFxuICAgIClcbiAgICByZXR1cm4gbXNnKC4uLmFyZ3MpXG4gIH1cbiAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSAobXNnLm1hdGNoKC8lW2RmaWpvT3NdL2cpIHx8IFtdKS5sZW5ndGhcbiAgYXNzZXJ0KFxuICAgIGV4cGVjdGVkTGVuZ3RoID09PSBhcmdzLmxlbmd0aCxcbiAgICBgQ29kZTogJHtrZXl9OyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzIGxlbmd0aCAoJHthcmdzLmxlbmd0aH0pIGRvZXMgbm90IG1hdGNoIHRoZSByZXF1aXJlZCBvbmVzICgke2V4cGVjdGVkTGVuZ3RofSkuYFxuICApXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBtc2dcbiAgfVxuICByZXR1cm4gZm9ybWF0KG1zZywgLi4uYXJncylcbn1cbmZ1bmN0aW9uIEUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3JcbiAgfVxuICBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlcihnZXRNZXNzYWdlKGNvZGUsIG1lc3NhZ2UsIGFyZ3MpKVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske2NvZGV9XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhOb2RlRXJyb3IucHJvdG90eXBlLCB7XG4gICAgbmFtZToge1xuICAgICAgdmFsdWU6IEJhc2UubmFtZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9LFxuICAgIHRvU3RyaW5nOiB7XG4gICAgICB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7Y29kZX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSlcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5jb2RlID0gY29kZVxuICBOb2RlRXJyb3IucHJvdG90eXBlW2tJc05vZGVFcnJvcl0gPSB0cnVlXG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yXG59XG5mdW5jdGlvbiBoaWRlU3RhY2tGcmFtZXMoZm4pIHtcbiAgLy8gV2UgcmVuYW1lIHRoZSBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGhpZGRlbiB0byBjdXQgb2ZmIHRoZSBzdGFja3RyYWNlXG4gIC8vIGF0IHRoZSBvdXRlcm1vc3Qgb25lXG4gIGNvbnN0IGhpZGRlbiA9IG5vZGVJbnRlcm5hbFByZWZpeCArIGZuLm5hbWVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHtcbiAgICB2YWx1ZTogaGlkZGVuXG4gIH0pXG4gIHJldHVybiBmblxufVxuZnVuY3Rpb24gYWdncmVnYXRlVHdvRXJyb3JzKGlubmVyRXJyb3IsIG91dGVyRXJyb3IpIHtcbiAgaWYgKGlubmVyRXJyb3IgJiYgb3V0ZXJFcnJvciAmJiBpbm5lckVycm9yICE9PSBvdXRlckVycm9yKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3V0ZXJFcnJvci5lcnJvcnMpKSB7XG4gICAgICAvLyBJZiBgb3V0ZXJFcnJvcmAgaXMgYWxyZWFkeSBhbiBgQWdncmVnYXRlRXJyb3JgLlxuICAgICAgb3V0ZXJFcnJvci5lcnJvcnMucHVzaChpbm5lckVycm9yKVxuICAgICAgcmV0dXJuIG91dGVyRXJyb3JcbiAgICB9XG4gICAgY29uc3QgZXJyID0gbmV3IEFnZ3JlZ2F0ZUVycm9yKFtvdXRlckVycm9yLCBpbm5lckVycm9yXSwgb3V0ZXJFcnJvci5tZXNzYWdlKVxuICAgIGVyci5jb2RlID0gb3V0ZXJFcnJvci5jb2RlXG4gICAgcmV0dXJuIGVyclxuICB9XG4gIHJldHVybiBpbm5lckVycm9yIHx8IG91dGVyRXJyb3Jcbn1cbmNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSAnVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCcsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFKCdvcHRpb25zJywgJ09iamVjdCcsIG9wdGlvbnMpXG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpXG4gICAgdGhpcy5jb2RlID0gJ0FCT1JUX0VSUidcbiAgICB0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcidcbiAgfVxufVxuRSgnRVJSX0FTU0VSVElPTicsICclcycsIEVycm9yKVxuRShcbiAgJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpID0+IHtcbiAgICBhc3NlcnQodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCBcIiduYW1lJyBtdXN0IGJlIGEgc3RyaW5nXCIpXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgICAgZXhwZWN0ZWQgPSBbZXhwZWN0ZWRdXG4gICAgfVxuICAgIGxldCBtc2cgPSAnVGhlICdcbiAgICBpZiAobmFtZS5lbmRzV2l0aCgnIGFyZ3VtZW50JykpIHtcbiAgICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICAgIG1zZyArPSBgJHtuYW1lfSBgXG4gICAgfSBlbHNlIHtcbiAgICAgIG1zZyArPSBgXCIke25hbWV9XCIgJHtuYW1lLmluY2x1ZGVzKCcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50J30gYFxuICAgIH1cbiAgICBtc2cgKz0gJ211c3QgYmUgJ1xuICAgIGNvbnN0IHR5cGVzID0gW11cbiAgICBjb25zdCBpbnN0YW5jZXMgPSBbXVxuICAgIGNvbnN0IG90aGVyID0gW11cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGV4cGVjdGVkKSB7XG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ0FsbCBleHBlY3RlZCBlbnRyaWVzIGhhdmUgdG8gYmUgb2YgdHlwZSBzdHJpbmcnKVxuICAgICAgaWYgKGtUeXBlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgdHlwZXMucHVzaCh2YWx1ZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgfSBlbHNlIGlmIChjbGFzc1JlZ0V4cC50ZXN0KHZhbHVlKSkge1xuICAgICAgICBpbnN0YW5jZXMucHVzaCh2YWx1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSAhPT0gJ29iamVjdCcsICdUaGUgdmFsdWUgXCJvYmplY3RcIiBzaG91bGQgYmUgd3JpdHRlbiBhcyBcIk9iamVjdFwiJylcbiAgICAgICAgb3RoZXIucHVzaCh2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGhhbmRsZSBgb2JqZWN0YCBpbiBjYXNlIG90aGVyIGluc3RhbmNlcyBhcmUgYWxsb3dlZCB0byBvdXRsaW5lXG4gICAgLy8gdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gZWFjaCBvdGhlci5cbiAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHBvcyA9IHR5cGVzLmluZGV4T2YoJ29iamVjdCcpXG4gICAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICB0eXBlcy5zcGxpY2UodHlwZXMsIHBvcywgMSlcbiAgICAgICAgaW5zdGFuY2VzLnB1c2goJ09iamVjdCcpXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlcy5sZW5ndGggPiAwKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbXNnICs9IGBvZiB0eXBlICR7dHlwZXNbMF19YFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtc2cgKz0gYG9uZSBvZiB0eXBlICR7dHlwZXNbMF19IG9yICR7dHlwZXNbMV19YFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBsYXN0ID0gdHlwZXMucG9wKClcbiAgICAgICAgICBtc2cgKz0gYG9uZSBvZiB0eXBlICR7dHlwZXMuam9pbignLCAnKX0sIG9yICR7bGFzdH1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnN0YW5jZXMubGVuZ3RoID4gMCB8fCBvdGhlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1zZyArPSAnIG9yICdcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBzd2l0Y2ggKGluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1zZyArPSBgYW4gaW5zdGFuY2Ugb2YgJHtpbnN0YW5jZXNbMF19YFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtc2cgKz0gYGFuIGluc3RhbmNlIG9mICR7aW5zdGFuY2VzWzBdfSBvciAke2luc3RhbmNlc1sxXX1gXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSBpbnN0YW5jZXMucG9wKClcbiAgICAgICAgICBtc2cgKz0gYGFuIGluc3RhbmNlIG9mICR7aW5zdGFuY2VzLmpvaW4oJywgJyl9LCBvciAke2xhc3R9YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3RoZXIubGVuZ3RoID4gMCkge1xuICAgICAgICBtc2cgKz0gJyBvciAnXG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAob3RoZXIubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChvdGhlclswXS50b0xvd2VyQ2FzZSgpICE9PSBvdGhlclswXSkge1xuICAgICAgICAgIG1zZyArPSAnYW4gJ1xuICAgICAgICB9XG4gICAgICAgIG1zZyArPSBgJHtvdGhlclswXX1gXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI6XG4gICAgICAgIG1zZyArPSBgb25lIG9mICR7b3RoZXJbMF19IG9yICR7b3RoZXJbMV19YFxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBsYXN0ID0gb3RoZXIucG9wKClcbiAgICAgICAgbXNnICs9IGBvbmUgb2YgJHtvdGhlci5qb2luKCcsICcpfSwgb3IgJHtsYXN0fWBcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFjdHVhbCA9PSBudWxsKSB7XG4gICAgICBtc2cgKz0gYC4gUmVjZWl2ZWQgJHthY3R1YWx9YFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdHVhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhY3R1YWwubmFtZSkge1xuICAgICAgbXNnICs9IGAuIFJlY2VpdmVkIGZ1bmN0aW9uICR7YWN0dWFsLm5hbWV9YFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdHVhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBfYWN0dWFsJGNvbnN0cnVjdG9yXG4gICAgICBpZiAoXG4gICAgICAgIChfYWN0dWFsJGNvbnN0cnVjdG9yID0gYWN0dWFsLmNvbnN0cnVjdG9yKSAhPT0gbnVsbCAmJlxuICAgICAgICBfYWN0dWFsJGNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgX2FjdHVhbCRjb25zdHJ1Y3Rvci5uYW1lXG4gICAgICApIHtcbiAgICAgICAgbXNnICs9IGAuIFJlY2VpdmVkIGFuIGluc3RhbmNlIG9mICR7YWN0dWFsLmNvbnN0cnVjdG9yLm5hbWV9YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5zcGVjdGVkID0gaW5zcGVjdChhY3R1YWwsIHtcbiAgICAgICAgICBkZXB0aDogLTFcbiAgICAgICAgfSlcbiAgICAgICAgbXNnICs9IGAuIFJlY2VpdmVkICR7aW5zcGVjdGVkfWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGluc3BlY3RlZCA9IGluc3BlY3QoYWN0dWFsLCB7XG4gICAgICAgIGNvbG9yczogZmFsc2VcbiAgICAgIH0pXG4gICAgICBpZiAoaW5zcGVjdGVkLmxlbmd0aCA+IDI1KSB7XG4gICAgICAgIGluc3BlY3RlZCA9IGAke2luc3BlY3RlZC5zbGljZSgwLCAyNSl9Li4uYFxuICAgICAgfVxuICAgICAgbXNnICs9IGAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfSAoJHtpbnNwZWN0ZWR9KWBcbiAgICB9XG4gICAgcmV0dXJuIG1zZ1xuICB9LFxuICBUeXBlRXJyb3JcbilcbkUoXG4gICdFUlJfSU5WQUxJRF9BUkdfVkFMVUUnLFxuICAobmFtZSwgdmFsdWUsIHJlYXNvbiA9ICdpcyBpbnZhbGlkJykgPT4ge1xuICAgIGxldCBpbnNwZWN0ZWQgPSBpbnNwZWN0KHZhbHVlKVxuICAgIGlmIChpbnNwZWN0ZWQubGVuZ3RoID4gMTI4KSB7XG4gICAgICBpbnNwZWN0ZWQgPSBpbnNwZWN0ZWQuc2xpY2UoMCwgMTI4KSArICcuLi4nXG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBuYW1lLmluY2x1ZGVzKCcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50J1xuICAgIHJldHVybiBgVGhlICR7dHlwZX0gJyR7bmFtZX0nICR7cmVhc29ufS4gUmVjZWl2ZWQgJHtpbnNwZWN0ZWR9YFxuICB9LFxuICBUeXBlRXJyb3JcbilcbkUoXG4gICdFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnLFxuICAoaW5wdXQsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgdmFyIF92YWx1ZSRjb25zdHJ1Y3RvclxuICAgIGNvbnN0IHR5cGUgPVxuICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChfdmFsdWUkY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcikgIT09IG51bGwgJiZcbiAgICAgIF92YWx1ZSRjb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBfdmFsdWUkY29uc3RydWN0b3IubmFtZVxuICAgICAgICA/IGBpbnN0YW5jZSBvZiAke3ZhbHVlLmNvbnN0cnVjdG9yLm5hbWV9YFxuICAgICAgICA6IGB0eXBlICR7dHlwZW9mIHZhbHVlfWBcbiAgICByZXR1cm4gYEV4cGVjdGVkICR7aW5wdXR9IHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFwiJHtuYW1lfVwiYCArIGAgZnVuY3Rpb24gYnV0IGdvdCAke3R5cGV9LmBcbiAgfSxcbiAgVHlwZUVycm9yXG4pXG5FKFxuICAnRVJSX01JU1NJTkdfQVJHUycsXG4gICguLi5hcmdzKSA9PiB7XG4gICAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJylcbiAgICBsZXQgbXNnXG4gICAgY29uc3QgbGVuID0gYXJncy5sZW5ndGhcbiAgICBhcmdzID0gKEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzIDogW2FyZ3NdKS5tYXAoKGEpID0+IGBcIiR7YX1cImApLmpvaW4oJyBvciAnKVxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG1zZyArPSBgVGhlICR7YXJnc1swXX0gYXJndW1lbnRgXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI6XG4gICAgICAgIG1zZyArPSBgVGhlICR7YXJnc1swXX0gYW5kICR7YXJnc1sxXX0gYXJndW1lbnRzYFxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSBhcmdzLnBvcCgpXG4gICAgICAgICAgbXNnICs9IGBUaGUgJHthcmdzLmpvaW4oJywgJyl9LCBhbmQgJHtsYXN0fSBhcmd1bWVudHNgXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgcmV0dXJuIGAke21zZ30gbXVzdCBiZSBzcGVjaWZpZWRgXG4gIH0sXG4gIFR5cGVFcnJvclxuKVxuRShcbiAgJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICAoc3RyLCByYW5nZSwgaW5wdXQpID0+IHtcbiAgICBhc3NlcnQocmFuZ2UsICdNaXNzaW5nIFwicmFuZ2VcIiBhcmd1bWVudCcpXG4gICAgbGV0IHJlY2VpdmVkXG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IDJuICoqIDMybiB8fCBpbnB1dCA8IC0oMm4gKiogMzJuKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNlaXZlZCA9IGluc3BlY3QoaW5wdXQpXG4gICAgfVxuICAgIHJldHVybiBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgfSxcbiAgUmFuZ2VFcnJvclxuKVxuRSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycsIEVycm9yKVxuRSgnRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQnLCAnVGhlICVzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnLCBFcnJvcilcbkUoJ0VSUl9TVFJFQU1fQUxSRUFEWV9GSU5JU0hFRCcsICdDYW5ub3QgY2FsbCAlcyBhZnRlciBhIHN0cmVhbSB3YXMgZmluaXNoZWQnLCBFcnJvcilcbkUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCAnQ2Fubm90IGNhbGwgJXMgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCcsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcilcbkUoJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJywgJ1ByZW1hdHVyZSBjbG9zZScsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCcsICdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJywgRXJyb3IpXG5FKCdFUlJfVU5LTk9XTl9FTkNPRElORycsICdVbmtub3duIGVuY29kaW5nOiAlcycsIFR5cGVFcnJvcilcbm1vZHVsZS5leHBvcnRzID0ge1xuICBBYm9ydEVycm9yLFxuICBhZ2dyZWdhdGVUd29FcnJvcnM6IGhpZGVTdGFja0ZyYW1lcyhhZ2dyZWdhdGVUd29FcnJvcnMpLFxuICBoaWRlU3RhY2tGcmFtZXMsXG4gIGNvZGVzXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/ours/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/ours/index.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/lib/ours/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Stream = __webpack_require__(/*! stream */ \"stream\")\nif (Stream && process.env.READABLE_STREAM === 'disable') {\n  const promises = Stream.promises\n\n  // Explicit export naming is needed for ESM\n  module.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer\n  module.exports._isUint8Array = Stream._isUint8Array\n  module.exports.isDisturbed = Stream.isDisturbed\n  module.exports.isErrored = Stream.isErrored\n  module.exports.isReadable = Stream.isReadable\n  module.exports.Readable = Stream.Readable\n  module.exports.Writable = Stream.Writable\n  module.exports.Duplex = Stream.Duplex\n  module.exports.Transform = Stream.Transform\n  module.exports.PassThrough = Stream.PassThrough\n  module.exports.addAbortSignal = Stream.addAbortSignal\n  module.exports.finished = Stream.finished\n  module.exports.destroy = Stream.destroy\n  module.exports.pipeline = Stream.pipeline\n  module.exports.compose = Stream.compose\n  Object.defineProperty(Stream, 'promises', {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return promises\n    }\n  })\n  module.exports.Stream = Stream.Stream\n} else {\n  const CustomStream = __webpack_require__(/*! ../stream */ \"(ssr)/./node_modules/readable-stream/lib/stream.js\")\n  const promises = __webpack_require__(/*! ../stream/promises */ \"(ssr)/./node_modules/readable-stream/lib/stream/promises.js\")\n  const originalDestroy = CustomStream.Readable.destroy\n  module.exports = CustomStream.Readable\n\n  // Explicit export naming is needed for ESM\n  module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer\n  module.exports._isUint8Array = CustomStream._isUint8Array\n  module.exports.isDisturbed = CustomStream.isDisturbed\n  module.exports.isErrored = CustomStream.isErrored\n  module.exports.isReadable = CustomStream.isReadable\n  module.exports.Readable = CustomStream.Readable\n  module.exports.Writable = CustomStream.Writable\n  module.exports.Duplex = CustomStream.Duplex\n  module.exports.Transform = CustomStream.Transform\n  module.exports.PassThrough = CustomStream.PassThrough\n  module.exports.addAbortSignal = CustomStream.addAbortSignal\n  module.exports.finished = CustomStream.finished\n  module.exports.destroy = CustomStream.destroy\n  module.exports.destroy = originalDestroy\n  module.exports.pipeline = CustomStream.pipeline\n  module.exports.compose = CustomStream.compose\n  Object.defineProperty(CustomStream, 'promises', {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return promises\n    }\n  })\n  module.exports.Stream = CustomStream.Stream\n}\n\n// Allow default importing\nmodule.exports[\"default\"] = module.exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9vdXJzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQjtBQUNBOztBQUVBO0FBQ0EsRUFBRSxrQ0FBa0M7QUFDcEMsRUFBRSw0QkFBNEI7QUFDOUIsRUFBRSwwQkFBMEI7QUFDNUIsRUFBRSx3QkFBd0I7QUFDMUIsRUFBRSx5QkFBeUI7QUFDM0IsRUFBRSx1QkFBdUI7QUFDekIsRUFBRSx1QkFBdUI7QUFDekIsRUFBRSxxQkFBcUI7QUFDdkIsRUFBRSx3QkFBd0I7QUFDMUIsRUFBRSwwQkFBMEI7QUFDNUIsRUFBRSw2QkFBNkI7QUFDL0IsRUFBRSx1QkFBdUI7QUFDekIsRUFBRSxzQkFBc0I7QUFDeEIsRUFBRSx1QkFBdUI7QUFDekIsRUFBRSxzQkFBc0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUscUJBQXFCO0FBQ3ZCLEVBQUU7QUFDRix1QkFBdUIsbUJBQU8sQ0FBQyxxRUFBVztBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBLEVBQUUsa0NBQWtDO0FBQ3BDLEVBQUUsNEJBQTRCO0FBQzlCLEVBQUUsMEJBQTBCO0FBQzVCLEVBQUUsd0JBQXdCO0FBQzFCLEVBQUUseUJBQXlCO0FBQzNCLEVBQUUsdUJBQXVCO0FBQ3pCLEVBQUUsdUJBQXVCO0FBQ3pCLEVBQUUscUJBQXFCO0FBQ3ZCLEVBQUUsd0JBQXdCO0FBQzFCLEVBQUUsMEJBQTBCO0FBQzVCLEVBQUUsNkJBQTZCO0FBQy9CLEVBQUUsdUJBQXVCO0FBQ3pCLEVBQUUsc0JBQXNCO0FBQ3hCLEVBQUUsc0JBQXNCO0FBQ3hCLEVBQUUsdUJBQXVCO0FBQ3pCLEVBQUUsc0JBQXNCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLHFCQUFxQjtBQUN2Qjs7QUFFQTtBQUNBLHlCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2V0aC1sb25kb24tMjAyNC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL291cnMvaW5kZXguanM/ZmY1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbmlmIChTdHJlYW0gJiYgcHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScpIHtcbiAgY29uc3QgcHJvbWlzZXMgPSBTdHJlYW0ucHJvbWlzZXNcblxuICAvLyBFeHBsaWNpdCBleHBvcnQgbmFtaW5nIGlzIG5lZWRlZCBmb3IgRVNNXG4gIG1vZHVsZS5leHBvcnRzLl91aW50OEFycmF5VG9CdWZmZXIgPSBTdHJlYW0uX3VpbnQ4QXJyYXlUb0J1ZmZlclxuICBtb2R1bGUuZXhwb3J0cy5faXNVaW50OEFycmF5ID0gU3RyZWFtLl9pc1VpbnQ4QXJyYXlcbiAgbW9kdWxlLmV4cG9ydHMuaXNEaXN0dXJiZWQgPSBTdHJlYW0uaXNEaXN0dXJiZWRcbiAgbW9kdWxlLmV4cG9ydHMuaXNFcnJvcmVkID0gU3RyZWFtLmlzRXJyb3JlZFxuICBtb2R1bGUuZXhwb3J0cy5pc1JlYWRhYmxlID0gU3RyZWFtLmlzUmVhZGFibGVcbiAgbW9kdWxlLmV4cG9ydHMuUmVhZGFibGUgPSBTdHJlYW0uUmVhZGFibGVcbiAgbW9kdWxlLmV4cG9ydHMuV3JpdGFibGUgPSBTdHJlYW0uV3JpdGFibGVcbiAgbW9kdWxlLmV4cG9ydHMuRHVwbGV4ID0gU3RyZWFtLkR1cGxleFxuICBtb2R1bGUuZXhwb3J0cy5UcmFuc2Zvcm0gPSBTdHJlYW0uVHJhbnNmb3JtXG4gIG1vZHVsZS5leHBvcnRzLlBhc3NUaHJvdWdoID0gU3RyZWFtLlBhc3NUaHJvdWdoXG4gIG1vZHVsZS5leHBvcnRzLmFkZEFib3J0U2lnbmFsID0gU3RyZWFtLmFkZEFib3J0U2lnbmFsXG4gIG1vZHVsZS5leHBvcnRzLmZpbmlzaGVkID0gU3RyZWFtLmZpbmlzaGVkXG4gIG1vZHVsZS5leHBvcnRzLmRlc3Ryb3kgPSBTdHJlYW0uZGVzdHJveVxuICBtb2R1bGUuZXhwb3J0cy5waXBlbGluZSA9IFN0cmVhbS5waXBlbGluZVxuICBtb2R1bGUuZXhwb3J0cy5jb21wb3NlID0gU3RyZWFtLmNvbXBvc2VcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmVhbSwgJ3Byb21pc2VzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlc1xuICAgIH1cbiAgfSlcbiAgbW9kdWxlLmV4cG9ydHMuU3RyZWFtID0gU3RyZWFtLlN0cmVhbVxufSBlbHNlIHtcbiAgY29uc3QgQ3VzdG9tU3RyZWFtID0gcmVxdWlyZSgnLi4vc3RyZWFtJylcbiAgY29uc3QgcHJvbWlzZXMgPSByZXF1aXJlKCcuLi9zdHJlYW0vcHJvbWlzZXMnKVxuICBjb25zdCBvcmlnaW5hbERlc3Ryb3kgPSBDdXN0b21TdHJlYW0uUmVhZGFibGUuZGVzdHJveVxuICBtb2R1bGUuZXhwb3J0cyA9IEN1c3RvbVN0cmVhbS5SZWFkYWJsZVxuXG4gIC8vIEV4cGxpY2l0IGV4cG9ydCBuYW1pbmcgaXMgbmVlZGVkIGZvciBFU01cbiAgbW9kdWxlLmV4cG9ydHMuX3VpbnQ4QXJyYXlUb0J1ZmZlciA9IEN1c3RvbVN0cmVhbS5fdWludDhBcnJheVRvQnVmZmVyXG4gIG1vZHVsZS5leHBvcnRzLl9pc1VpbnQ4QXJyYXkgPSBDdXN0b21TdHJlYW0uX2lzVWludDhBcnJheVxuICBtb2R1bGUuZXhwb3J0cy5pc0Rpc3R1cmJlZCA9IEN1c3RvbVN0cmVhbS5pc0Rpc3R1cmJlZFxuICBtb2R1bGUuZXhwb3J0cy5pc0Vycm9yZWQgPSBDdXN0b21TdHJlYW0uaXNFcnJvcmVkXG4gIG1vZHVsZS5leHBvcnRzLmlzUmVhZGFibGUgPSBDdXN0b21TdHJlYW0uaXNSZWFkYWJsZVxuICBtb2R1bGUuZXhwb3J0cy5SZWFkYWJsZSA9IEN1c3RvbVN0cmVhbS5SZWFkYWJsZVxuICBtb2R1bGUuZXhwb3J0cy5Xcml0YWJsZSA9IEN1c3RvbVN0cmVhbS5Xcml0YWJsZVxuICBtb2R1bGUuZXhwb3J0cy5EdXBsZXggPSBDdXN0b21TdHJlYW0uRHVwbGV4XG4gIG1vZHVsZS5leHBvcnRzLlRyYW5zZm9ybSA9IEN1c3RvbVN0cmVhbS5UcmFuc2Zvcm1cbiAgbW9kdWxlLmV4cG9ydHMuUGFzc1Rocm91Z2ggPSBDdXN0b21TdHJlYW0uUGFzc1Rocm91Z2hcbiAgbW9kdWxlLmV4cG9ydHMuYWRkQWJvcnRTaWduYWwgPSBDdXN0b21TdHJlYW0uYWRkQWJvcnRTaWduYWxcbiAgbW9kdWxlLmV4cG9ydHMuZmluaXNoZWQgPSBDdXN0b21TdHJlYW0uZmluaXNoZWRcbiAgbW9kdWxlLmV4cG9ydHMuZGVzdHJveSA9IEN1c3RvbVN0cmVhbS5kZXN0cm95XG4gIG1vZHVsZS5leHBvcnRzLmRlc3Ryb3kgPSBvcmlnaW5hbERlc3Ryb3lcbiAgbW9kdWxlLmV4cG9ydHMucGlwZWxpbmUgPSBDdXN0b21TdHJlYW0ucGlwZWxpbmVcbiAgbW9kdWxlLmV4cG9ydHMuY29tcG9zZSA9IEN1c3RvbVN0cmVhbS5jb21wb3NlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21TdHJlYW0sICdwcm9taXNlcycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZXNcbiAgICB9XG4gIH0pXG4gIG1vZHVsZS5leHBvcnRzLlN0cmVhbSA9IEN1c3RvbVN0cmVhbS5TdHJlYW1cbn1cblxuLy8gQWxsb3cgZGVmYXVsdCBpbXBvcnRpbmdcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0c1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/ours/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/ours/primordials.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/ours/primordials.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at\n\n  https://github.com/nodejs/node/blob/master/lib/internal/per_context/primordials.js\n\n  Don't try to replace with the original file and keep it up to date with the upstream file.\n*/\nmodule.exports = {\n  ArrayIsArray(self) {\n    return Array.isArray(self)\n  },\n  ArrayPrototypeIncludes(self, el) {\n    return self.includes(el)\n  },\n  ArrayPrototypeIndexOf(self, el) {\n    return self.indexOf(el)\n  },\n  ArrayPrototypeJoin(self, sep) {\n    return self.join(sep)\n  },\n  ArrayPrototypeMap(self, fn) {\n    return self.map(fn)\n  },\n  ArrayPrototypePop(self, el) {\n    return self.pop(el)\n  },\n  ArrayPrototypePush(self, el) {\n    return self.push(el)\n  },\n  ArrayPrototypeSlice(self, start, end) {\n    return self.slice(start, end)\n  },\n  Error,\n  FunctionPrototypeCall(fn, thisArgs, ...args) {\n    return fn.call(thisArgs, ...args)\n  },\n  FunctionPrototypeSymbolHasInstance(self, instance) {\n    return Function.prototype[Symbol.hasInstance].call(self, instance)\n  },\n  MathFloor: Math.floor,\n  Number,\n  NumberIsInteger: Number.isInteger,\n  NumberIsNaN: Number.isNaN,\n  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n  NumberParseInt: Number.parseInt,\n  ObjectDefineProperties(self, props) {\n    return Object.defineProperties(self, props)\n  },\n  ObjectDefineProperty(self, name, prop) {\n    return Object.defineProperty(self, name, prop)\n  },\n  ObjectGetOwnPropertyDescriptor(self, name) {\n    return Object.getOwnPropertyDescriptor(self, name)\n  },\n  ObjectKeys(obj) {\n    return Object.keys(obj)\n  },\n  ObjectSetPrototypeOf(target, proto) {\n    return Object.setPrototypeOf(target, proto)\n  },\n  Promise,\n  PromisePrototypeCatch(self, fn) {\n    return self.catch(fn)\n  },\n  PromisePrototypeThen(self, thenFn, catchFn) {\n    return self.then(thenFn, catchFn)\n  },\n  PromiseReject(err) {\n    return Promise.reject(err)\n  },\n  PromiseResolve(val) {\n    return Promise.resolve(val)\n  },\n  ReflectApply: Reflect.apply,\n  RegExpPrototypeTest(self, value) {\n    return self.test(value)\n  },\n  SafeSet: Set,\n  String,\n  StringPrototypeSlice(self, start, end) {\n    return self.slice(start, end)\n  },\n  StringPrototypeToLowerCase(self) {\n    return self.toLowerCase()\n  },\n  StringPrototypeToUpperCase(self) {\n    return self.toUpperCase()\n  },\n  StringPrototypeTrim(self) {\n    return self.trim()\n  },\n  Symbol,\n  SymbolFor: Symbol.for,\n  SymbolAsyncIterator: Symbol.asyncIterator,\n  SymbolHasInstance: Symbol.hasInstance,\n  SymbolIterator: Symbol.iterator,\n  SymbolDispose: Symbol.dispose || Symbol('Symbol.dispose'),\n  SymbolAsyncDispose: Symbol.asyncDispose || Symbol('Symbol.asyncDispose'),\n  TypedArrayPrototypeSet(self, buf, len) {\n    return self.set(buf, len)\n  },\n  Boolean: Boolean,\n  Uint8Array\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9vdXJzL3ByaW1vcmRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V0aC1sb25kb24tMjAyNC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL291cnMvcHJpbW9yZGlhbHMuanM/ODZkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLypcbiAgVGhpcyBmaWxlIGlzIGEgcmVkdWNlZCBhbmQgYWRhcHRlZCB2ZXJzaW9uIG9mIHRoZSBtYWluIGxpYi9pbnRlcm5hbC9wZXJfY29udGV4dC9wcmltb3JkaWFscy5qcyBmaWxlIGRlZmluZWQgYXRcblxuICBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL2ludGVybmFsL3Blcl9jb250ZXh0L3ByaW1vcmRpYWxzLmpzXG5cbiAgRG9uJ3QgdHJ5IHRvIHJlcGxhY2Ugd2l0aCB0aGUgb3JpZ2luYWwgZmlsZSBhbmQga2VlcCBpdCB1cCB0byBkYXRlIHdpdGggdGhlIHVwc3RyZWFtIGZpbGUuXG4qL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFycmF5SXNBcnJheShzZWxmKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc2VsZilcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVJbmNsdWRlcyhzZWxmLCBlbCkge1xuICAgIHJldHVybiBzZWxmLmluY2x1ZGVzKGVsKVxuICB9LFxuICBBcnJheVByb3RvdHlwZUluZGV4T2Yoc2VsZiwgZWwpIHtcbiAgICByZXR1cm4gc2VsZi5pbmRleE9mKGVsKVxuICB9LFxuICBBcnJheVByb3RvdHlwZUpvaW4oc2VsZiwgc2VwKSB7XG4gICAgcmV0dXJuIHNlbGYuam9pbihzZXApXG4gIH0sXG4gIEFycmF5UHJvdG90eXBlTWFwKHNlbGYsIGZuKSB7XG4gICAgcmV0dXJuIHNlbGYubWFwKGZuKVxuICB9LFxuICBBcnJheVByb3RvdHlwZVBvcChzZWxmLCBlbCkge1xuICAgIHJldHVybiBzZWxmLnBvcChlbClcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVQdXNoKHNlbGYsIGVsKSB7XG4gICAgcmV0dXJuIHNlbGYucHVzaChlbClcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVTbGljZShzZWxmLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHNlbGYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgfSxcbiAgRXJyb3IsXG4gIEZ1bmN0aW9uUHJvdG90eXBlQ2FsbChmbiwgdGhpc0FyZ3MsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzQXJncywgLi4uYXJncylcbiAgfSxcbiAgRnVuY3Rpb25Qcm90b3R5cGVTeW1ib2xIYXNJbnN0YW5jZShzZWxmLCBpbnN0YW5jZSkge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXS5jYWxsKHNlbGYsIGluc3RhbmNlKVxuICB9LFxuICBNYXRoRmxvb3I6IE1hdGguZmxvb3IsXG4gIE51bWJlcixcbiAgTnVtYmVySXNJbnRlZ2VyOiBOdW1iZXIuaXNJbnRlZ2VyLFxuICBOdW1iZXJJc05hTjogTnVtYmVyLmlzTmFOLFxuICBOdW1iZXJNQVhfU0FGRV9JTlRFR0VSOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgTnVtYmVyTUlOX1NBRkVfSU5URUdFUjogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gIE51bWJlclBhcnNlSW50OiBOdW1iZXIucGFyc2VJbnQsXG4gIE9iamVjdERlZmluZVByb3BlcnRpZXMoc2VsZiwgcHJvcHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2VsZiwgcHJvcHMpXG4gIH0sXG4gIE9iamVjdERlZmluZVByb3BlcnR5KHNlbGYsIG5hbWUsIHByb3ApIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIG5hbWUsIHByb3ApXG4gIH0sXG4gIE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihzZWxmLCBuYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2VsZiwgbmFtZSlcbiAgfSxcbiAgT2JqZWN0S2V5cyhvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICB9LFxuICBPYmplY3RTZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxuICB9LFxuICBQcm9taXNlLFxuICBQcm9taXNlUHJvdG90eXBlQ2F0Y2goc2VsZiwgZm4pIHtcbiAgICByZXR1cm4gc2VsZi5jYXRjaChmbilcbiAgfSxcbiAgUHJvbWlzZVByb3RvdHlwZVRoZW4oc2VsZiwgdGhlbkZuLCBjYXRjaEZuKSB7XG4gICAgcmV0dXJuIHNlbGYudGhlbih0aGVuRm4sIGNhdGNoRm4pXG4gIH0sXG4gIFByb21pc2VSZWplY3QoZXJyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycilcbiAgfSxcbiAgUHJvbWlzZVJlc29sdmUodmFsKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWwpXG4gIH0sXG4gIFJlZmxlY3RBcHBseTogUmVmbGVjdC5hcHBseSxcbiAgUmVnRXhwUHJvdG90eXBlVGVzdChzZWxmLCB2YWx1ZSkge1xuICAgIHJldHVybiBzZWxmLnRlc3QodmFsdWUpXG4gIH0sXG4gIFNhZmVTZXQ6IFNldCxcbiAgU3RyaW5nLFxuICBTdHJpbmdQcm90b3R5cGVTbGljZShzZWxmLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHNlbGYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgfSxcbiAgU3RyaW5nUHJvdG90eXBlVG9Mb3dlckNhc2Uoc2VsZikge1xuICAgIHJldHVybiBzZWxmLnRvTG93ZXJDYXNlKClcbiAgfSxcbiAgU3RyaW5nUHJvdG90eXBlVG9VcHBlckNhc2Uoc2VsZikge1xuICAgIHJldHVybiBzZWxmLnRvVXBwZXJDYXNlKClcbiAgfSxcbiAgU3RyaW5nUHJvdG90eXBlVHJpbShzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGYudHJpbSgpXG4gIH0sXG4gIFN5bWJvbCxcbiAgU3ltYm9sRm9yOiBTeW1ib2wuZm9yLFxuICBTeW1ib2xBc3luY0l0ZXJhdG9yOiBTeW1ib2wuYXN5bmNJdGVyYXRvcixcbiAgU3ltYm9sSGFzSW5zdGFuY2U6IFN5bWJvbC5oYXNJbnN0YW5jZSxcbiAgU3ltYm9sSXRlcmF0b3I6IFN5bWJvbC5pdGVyYXRvcixcbiAgU3ltYm9sRGlzcG9zZTogU3ltYm9sLmRpc3Bvc2UgfHwgU3ltYm9sKCdTeW1ib2wuZGlzcG9zZScpLFxuICBTeW1ib2xBc3luY0Rpc3Bvc2U6IFN5bWJvbC5hc3luY0Rpc3Bvc2UgfHwgU3ltYm9sKCdTeW1ib2wuYXN5bmNEaXNwb3NlJyksXG4gIFR5cGVkQXJyYXlQcm90b3R5cGVTZXQoc2VsZiwgYnVmLCBsZW4pIHtcbiAgICByZXR1cm4gc2VsZi5zZXQoYnVmLCBsZW4pXG4gIH0sXG4gIEJvb2xlYW46IEJvb2xlYW4sXG4gIFVpbnQ4QXJyYXlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/ours/util.js":
/*!*******************************************************!*\
  !*** ./node_modules/readable-stream/lib/ours/util.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst bufferModule = __webpack_require__(/*! buffer */ \"buffer\")\nconst { kResistStopPropagation, SymbolDispose } = __webpack_require__(/*! ./primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst AbortSignal = globalThis.AbortSignal || (__webpack_require__(/*! abort-controller */ \"(ssr)/./node_modules/abort-controller/dist/abort-controller.js\").AbortSignal)\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(ssr)/./node_modules/abort-controller/dist/abort-controller.js\").AbortController)\nconst AsyncFunction = Object.getPrototypeOf(async function () {}).constructor\nconst Blob = globalThis.Blob || bufferModule.Blob\n/* eslint-disable indent */\nconst isBlob =\n  typeof Blob !== 'undefined'\n    ? function isBlob(b) {\n        // eslint-disable-next-line indent\n        return b instanceof Blob\n      }\n    : function isBlob(b) {\n        return false\n      }\n/* eslint-enable indent */\n\nconst validateAbortSignal = (signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n}\nconst validateFunction = (value, name) => {\n  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n}\n\n// This is a simplified version of AggregateError\nclass AggregateError extends Error {\n  constructor(errors) {\n    if (!Array.isArray(errors)) {\n      throw new TypeError(`Expected input to be an Array, got ${typeof errors}`)\n    }\n    let message = ''\n    for (let i = 0; i < errors.length; i++) {\n      message += `    ${errors[i].stack}\\n`\n    }\n    super(message)\n    this.name = 'AggregateError'\n    this.errors = errors\n  }\n}\nmodule.exports = {\n  AggregateError,\n  kEmptyObject: Object.freeze({}),\n  once(callback) {\n    let called = false\n    return function (...args) {\n      if (called) {\n        return\n      }\n      called = true\n      callback.apply(this, args)\n    }\n  },\n  createDeferredPromise: function () {\n    let resolve\n    let reject\n\n    // eslint-disable-next-line promise/param-names\n    const promise = new Promise((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n    return {\n      promise,\n      resolve,\n      reject\n    }\n  },\n  promisify(fn) {\n    return new Promise((resolve, reject) => {\n      fn((err, ...args) => {\n        if (err) {\n          return reject(err)\n        }\n        return resolve(...args)\n      })\n    })\n  },\n  debuglog() {\n    return function () {}\n  },\n  format(format, ...args) {\n    // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args\n    return format.replace(/%([sdifj])/g, function (...[_unused, type]) {\n      const replacement = args.shift()\n      if (type === 'f') {\n        return replacement.toFixed(6)\n      } else if (type === 'j') {\n        return JSON.stringify(replacement)\n      } else if (type === 's' && typeof replacement === 'object') {\n        const ctor = replacement.constructor !== Object ? replacement.constructor.name : ''\n        return `${ctor} {}`.trim()\n      } else {\n        return replacement.toString()\n      }\n    })\n  },\n  inspect(value) {\n    // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options\n    switch (typeof value) {\n      case 'string':\n        if (value.includes(\"'\")) {\n          if (!value.includes('\"')) {\n            return `\"${value}\"`\n          } else if (!value.includes('`') && !value.includes('${')) {\n            return `\\`${value}\\``\n          }\n        }\n        return `'${value}'`\n      case 'number':\n        if (isNaN(value)) {\n          return 'NaN'\n        } else if (Object.is(value, -0)) {\n          return String(value)\n        }\n        return value\n      case 'bigint':\n        return `${String(value)}n`\n      case 'boolean':\n      case 'undefined':\n        return String(value)\n      case 'object':\n        return '{}'\n    }\n  },\n  types: {\n    isAsyncFunction(fn) {\n      return fn instanceof AsyncFunction\n    },\n    isArrayBufferView(arr) {\n      return ArrayBuffer.isView(arr)\n    }\n  },\n  isBlob,\n  deprecate(fn, message) {\n    return fn\n  },\n  addAbortListener:\n    (__webpack_require__(/*! events */ \"events\").addAbortListener) ||\n    function addAbortListener(signal, listener) {\n      if (signal === undefined) {\n        throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal)\n      }\n      validateAbortSignal(signal, 'signal')\n      validateFunction(listener, 'listener')\n      let removeEventListener\n      if (signal.aborted) {\n        queueMicrotask(() => listener())\n      } else {\n        signal.addEventListener('abort', listener, {\n          __proto__: null,\n          once: true,\n          [kResistStopPropagation]: true\n        })\n        removeEventListener = () => {\n          signal.removeEventListener('abort', listener)\n        }\n      }\n      return {\n        __proto__: null,\n        [SymbolDispose]() {\n          var _removeEventListener\n          ;(_removeEventListener = removeEventListener) === null || _removeEventListener === undefined\n            ? undefined\n            : _removeEventListener()\n        }\n      }\n    },\n  AbortSignalAny:\n    AbortSignal.any ||\n    function AbortSignalAny(signals) {\n      // Fast path if there is only one signal.\n      if (signals.length === 1) {\n        return signals[0]\n      }\n      const ac = new AbortController()\n      const abort = () => ac.abort()\n      signals.forEach((signal) => {\n        validateAbortSignal(signal, 'signals')\n        signal.addEventListener('abort', abort, {\n          once: true\n        })\n      })\n      ac.signal.addEventListener(\n        'abort',\n        () => {\n          signals.forEach((signal) => signal.removeEventListener('abort', abort))\n        },\n        {\n          once: true\n        }\n      )\n      return ac.signal\n    }\n}\nmodule.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9vdXJzL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVoscUJBQXFCLG1CQUFPLENBQUMsc0JBQVE7QUFDckMsUUFBUSx3Q0FBd0MsRUFBRSxtQkFBTyxDQUFDLG1GQUFlO0FBQ3pFLDhDQUE4QywySEFBdUM7QUFDckYsc0RBQXNELCtIQUEyQztBQUNqRyxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsY0FBYztBQUM5RTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2Qyx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0IsWUFBWSxvREFBb0Q7QUFDaEUsd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSw4REFBa0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXRoLWxvbmRvbi0yMDI0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy91dGlsLmpzP2EzMGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJ1ZmZlck1vZHVsZSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCB7IGtSZXNpc3RTdG9wUHJvcGFnYXRpb24sIFN5bWJvbERpc3Bvc2UgfSA9IHJlcXVpcmUoJy4vcHJpbW9yZGlhbHMnKVxuY29uc3QgQWJvcnRTaWduYWwgPSBnbG9iYWxUaGlzLkFib3J0U2lnbmFsIHx8IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKS5BYm9ydFNpZ25hbFxuY29uc3QgQWJvcnRDb250cm9sbGVyID0gZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIgfHwgcmVxdWlyZSgnYWJvcnQtY29udHJvbGxlcicpLkFib3J0Q29udHJvbGxlclxuY29uc3QgQXN5bmNGdW5jdGlvbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbiAoKSB7fSkuY29uc3RydWN0b3JcbmNvbnN0IEJsb2IgPSBnbG9iYWxUaGlzLkJsb2IgfHwgYnVmZmVyTW9kdWxlLkJsb2Jcbi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuY29uc3QgaXNCbG9iID1cbiAgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnXG4gICAgPyBmdW5jdGlvbiBpc0Jsb2IoYikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW5kZW50XG4gICAgICAgIHJldHVybiBiIGluc3RhbmNlb2YgQmxvYlxuICAgICAgfVxuICAgIDogZnVuY3Rpb24gaXNCbG9iKGIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4vKiBlc2xpbnQtZW5hYmxlIGluZGVudCAqL1xuXG5jb25zdCB2YWxpZGF0ZUFib3J0U2lnbmFsID0gKHNpZ25hbCwgbmFtZSkgPT4ge1xuICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQgJiYgKHNpZ25hbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc2lnbmFsICE9PSAnb2JqZWN0JyB8fCAhKCdhYm9ydGVkJyBpbiBzaWduYWwpKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnQWJvcnRTaWduYWwnLCBzaWduYWwpXG4gIH1cbn1cbmNvbnN0IHZhbGlkYXRlRnVuY3Rpb24gPSAodmFsdWUsIG5hbWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdGdW5jdGlvbicsIHZhbHVlKVxufVxuXG4vLyBUaGlzIGlzIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIEFnZ3JlZ2F0ZUVycm9yXG5jbGFzcyBBZ2dyZWdhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGVycm9ycykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGlucHV0IHRvIGJlIGFuIEFycmF5LCBnb3QgJHt0eXBlb2YgZXJyb3JzfWApXG4gICAgfVxuICAgIGxldCBtZXNzYWdlID0gJydcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgbWVzc2FnZSArPSBgICAgICR7ZXJyb3JzW2ldLnN0YWNrfVxcbmBcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQWdncmVnYXRlRXJyb3InXG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnNcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFnZ3JlZ2F0ZUVycm9yLFxuICBrRW1wdHlPYmplY3Q6IE9iamVjdC5mcmVlemUoe30pLFxuICBvbmNlKGNhbGxiYWNrKSB7XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBpZiAoY2FsbGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FsbGVkID0gdHJ1ZVxuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncylcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZURlZmVycmVkUHJvbWlzZTogZnVuY3Rpb24gKCkge1xuICAgIGxldCByZXNvbHZlXG4gICAgbGV0IHJlamVjdFxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2UvcGFyYW0tbmFtZXNcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICByZXNvbHZlID0gcmVzXG4gICAgICByZWplY3QgPSByZWpcbiAgICB9KVxuICAgIHJldHVybiB7XG4gICAgICBwcm9taXNlLFxuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdFxuICAgIH1cbiAgfSxcbiAgcHJvbWlzaWZ5KGZuKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZuKChlcnIsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKC4uLmFyZ3MpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG4gIGRlYnVnbG9nKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fVxuICB9LFxuICBmb3JtYXQoZm9ybWF0LCAuLi5hcmdzKSB7XG4gICAgLy8gU2ltcGxpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdXRpbC5odG1sI3V0aWxmb3JtYXRmb3JtYXQtYXJnc1xuICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgvJShbc2RpZmpdKS9nLCBmdW5jdGlvbiAoLi4uW191bnVzZWQsIHR5cGVdKSB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IGFyZ3Muc2hpZnQoKVxuICAgICAgaWYgKHR5cGUgPT09ICdmJykge1xuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQudG9GaXhlZCg2KVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaicpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlcGxhY2VtZW50KVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncycgJiYgdHlwZW9mIHJlcGxhY2VtZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBjdG9yID0gcmVwbGFjZW1lbnQuY29uc3RydWN0b3IgIT09IE9iamVjdCA/IHJlcGxhY2VtZW50LmNvbnN0cnVjdG9yLm5hbWUgOiAnJ1xuICAgICAgICByZXR1cm4gYCR7Y3Rvcn0ge31gLnRyaW0oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50LnRvU3RyaW5nKClcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBpbnNwZWN0KHZhbHVlKSB7XG4gICAgLy8gVmFzdGx5IHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL25vZGVqcy5vcmcvYXBpL3V0aWwuaHRtbCN1dGlsaW5zcGVjdG9iamVjdC1vcHRpb25zXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIidcIikpIHtcbiAgICAgICAgICBpZiAoIXZhbHVlLmluY2x1ZGVzKCdcIicpKSB7XG4gICAgICAgICAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImBcbiAgICAgICAgICB9IGVsc2UgaWYgKCF2YWx1ZS5pbmNsdWRlcygnYCcpICYmICF2YWx1ZS5pbmNsdWRlcygnJHsnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGBcXGAke3ZhbHVlfVxcYGBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAnJHt2YWx1ZX0nYFxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiAnTmFOJ1xuICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5pcyh2YWx1ZSwgLTApKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgIHJldHVybiBgJHtTdHJpbmcodmFsdWUpfW5gXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ3t9J1xuICAgIH1cbiAgfSxcbiAgdHlwZXM6IHtcbiAgICBpc0FzeW5jRnVuY3Rpb24oZm4pIHtcbiAgICAgIHJldHVybiBmbiBpbnN0YW5jZW9mIEFzeW5jRnVuY3Rpb25cbiAgICB9LFxuICAgIGlzQXJyYXlCdWZmZXJWaWV3KGFycikge1xuICAgICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnIpXG4gICAgfVxuICB9LFxuICBpc0Jsb2IsXG4gIGRlcHJlY2F0ZShmbiwgbWVzc2FnZSkge1xuICAgIHJldHVybiBmblxuICB9LFxuICBhZGRBYm9ydExpc3RlbmVyOlxuICAgIHJlcXVpcmUoJ2V2ZW50cycpLmFkZEFib3J0TGlzdGVuZXIgfHxcbiAgICBmdW5jdGlvbiBhZGRBYm9ydExpc3RlbmVyKHNpZ25hbCwgbGlzdGVuZXIpIHtcbiAgICAgIGlmIChzaWduYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3NpZ25hbCcsICdBYm9ydFNpZ25hbCcsIHNpZ25hbClcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlQWJvcnRTaWduYWwoc2lnbmFsLCAnc2lnbmFsJylcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb24obGlzdGVuZXIsICdsaXN0ZW5lcicpXG4gICAgICBsZXQgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGxpc3RlbmVyKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lciwge1xuICAgICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgIFtrUmVzaXN0U3RvcFByb3BhZ2F0aW9uXTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIFtTeW1ib2xEaXNwb3NlXSgpIHtcbiAgICAgICAgICB2YXIgX3JlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICAgICAgICA7KF9yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcikgPT09IG51bGwgfHwgX3JlbW92ZUV2ZW50TGlzdGVuZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogX3JlbW92ZUV2ZW50TGlzdGVuZXIoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgQWJvcnRTaWduYWxBbnk6XG4gICAgQWJvcnRTaWduYWwuYW55IHx8XG4gICAgZnVuY3Rpb24gQWJvcnRTaWduYWxBbnkoc2lnbmFscykge1xuICAgICAgLy8gRmFzdCBwYXRoIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNpZ25hbC5cbiAgICAgIGlmIChzaWduYWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2lnbmFsc1swXVxuICAgICAgfVxuICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgIGNvbnN0IGFib3J0ID0gKCkgPT4gYWMuYWJvcnQoKVxuICAgICAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHtcbiAgICAgICAgdmFsaWRhdGVBYm9ydFNpZ25hbChzaWduYWwsICdzaWduYWxzJylcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnQsIHtcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgYWMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdhYm9ydCcsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzaWduYWxzLmZvckVhY2goKHNpZ25hbCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnQpKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICApXG4gICAgICByZXR1cm4gYWMuc2lnbmFsXG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLnByb21pc2lmeS5jdXN0b20nKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/ours/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/stream.js":
/*!****************************************************!*\
  !*** ./node_modules/readable-stream/lib/stream.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n;('use strict')\nconst { ObjectDefineProperty, ObjectKeys, ReflectApply } = __webpack_require__(/*! ./ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst {\n  promisify: { custom: customPromisify }\n} = __webpack_require__(/*! ./ours/util */ \"(ssr)/./node_modules/readable-stream/lib/ours/util.js\")\nconst { streamReturningOperators, promiseReturningOperators } = __webpack_require__(/*! ./internal/streams/operators */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/operators.js\")\nconst {\n  codes: { ERR_ILLEGAL_CONSTRUCTOR }\n} = __webpack_require__(/*! ./ours/errors */ \"(ssr)/./node_modules/readable-stream/lib/ours/errors.js\")\nconst compose = __webpack_require__(/*! ./internal/streams/compose */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/compose.js\")\nconst { setDefaultHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./internal/streams/state */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/state.js\")\nconst { pipeline } = __webpack_require__(/*! ./internal/streams/pipeline */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/pipeline.js\")\nconst { destroyer } = __webpack_require__(/*! ./internal/streams/destroy */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst eos = __webpack_require__(/*! ./internal/streams/end-of-stream */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nconst internalBuffer = {}\nconst promises = __webpack_require__(/*! ./stream/promises */ \"(ssr)/./node_modules/readable-stream/lib/stream/promises.js\")\nconst utils = __webpack_require__(/*! ./internal/streams/utils */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst Stream = (module.exports = __webpack_require__(/*! ./internal/streams/legacy */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/legacy.js\").Stream)\nStream.isDestroyed = utils.isDestroyed\nStream.isDisturbed = utils.isDisturbed\nStream.isErrored = utils.isErrored\nStream.isReadable = utils.isReadable\nStream.isWritable = utils.isWritable\nStream.Readable = __webpack_require__(/*! ./internal/streams/readable */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/readable.js\")\nfor (const key of ObjectKeys(streamReturningOperators)) {\n  const op = streamReturningOperators[key]\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR()\n    }\n    return Stream.Readable.from(ReflectApply(op, this, args))\n  }\n  ObjectDefineProperty(fn, 'name', {\n    __proto__: null,\n    value: op.name\n  })\n  ObjectDefineProperty(fn, 'length', {\n    __proto__: null,\n    value: op.length\n  })\n  ObjectDefineProperty(Stream.Readable.prototype, key, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    configurable: true,\n    writable: true\n  })\n}\nfor (const key of ObjectKeys(promiseReturningOperators)) {\n  const op = promiseReturningOperators[key]\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR()\n    }\n    return ReflectApply(op, this, args)\n  }\n  ObjectDefineProperty(fn, 'name', {\n    __proto__: null,\n    value: op.name\n  })\n  ObjectDefineProperty(fn, 'length', {\n    __proto__: null,\n    value: op.length\n  })\n  ObjectDefineProperty(Stream.Readable.prototype, key, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    configurable: true,\n    writable: true\n  })\n}\nStream.Writable = __webpack_require__(/*! ./internal/streams/writable */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/writable.js\")\nStream.Duplex = __webpack_require__(/*! ./internal/streams/duplex */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/duplex.js\")\nStream.Transform = __webpack_require__(/*! ./internal/streams/transform */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/transform.js\")\nStream.PassThrough = __webpack_require__(/*! ./internal/streams/passthrough */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/passthrough.js\")\nStream.pipeline = pipeline\nconst { addAbortSignal } = __webpack_require__(/*! ./internal/streams/add-abort-signal */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\")\nStream.addAbortSignal = addAbortSignal\nStream.finished = eos\nStream.destroy = destroyer\nStream.compose = compose\nStream.setDefaultHighWaterMark = setDefaultHighWaterMark\nStream.getDefaultHighWaterMark = getDefaultHighWaterMark\nObjectDefineProperty(Stream, 'promises', {\n  __proto__: null,\n  configurable: true,\n  enumerable: true,\n  get() {\n    return promises\n  }\n})\nObjectDefineProperty(pipeline, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    return promises.pipeline\n  }\n})\nObjectDefineProperty(eos, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    return promises.finished\n  }\n})\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream\nStream._isUint8Array = function isUint8Array(value) {\n  return value instanceof Uint8Array\n}\nStream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUFRLGlEQUFpRCxFQUFFLG1CQUFPLENBQUMsd0ZBQW9CO0FBQ3ZGO0FBQ0EsZUFBZTtBQUNmLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDBFQUFhO0FBQ3pCLFFBQVEsc0RBQXNELEVBQUUsbUJBQU8sQ0FBQyw0R0FBOEI7QUFDdEc7QUFDQSxXQUFXO0FBQ1gsRUFBRSxFQUFFLG1CQUFPLENBQUMsOEVBQWU7QUFDM0IsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQTRCO0FBQ3BELFFBQVEsbURBQW1ELEVBQUUsbUJBQU8sQ0FBQyxvR0FBMEI7QUFDL0YsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQywwR0FBNkI7QUFDMUQsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyx3R0FBNEI7QUFDMUQsWUFBWSxtQkFBTyxDQUFDLG9IQUFrQztBQUN0RDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFtQjtBQUM1QyxjQUFjLG1CQUFPLENBQUMsb0dBQTBCO0FBQ2hELGdCQUFnQixtSkFBNEQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDBHQUE2QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQywwR0FBNkI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsc0dBQTJCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLDRHQUE4QjtBQUN6RCxxQkFBcUIsbUJBQU8sQ0FBQyxnSEFBZ0M7QUFDN0Q7QUFDQSxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsMEhBQXFDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldGgtbG9uZG9uLTIwMjQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9zdHJlYW0uanM/NmQ3MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuLyogcmVwbGFjZW1lbnQgZW5kICovXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuOygndXNlIHN0cmljdCcpXG5jb25zdCB7IE9iamVjdERlZmluZVByb3BlcnR5LCBPYmplY3RLZXlzLCBSZWZsZWN0QXBwbHkgfSA9IHJlcXVpcmUoJy4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7XG4gIHByb21pc2lmeTogeyBjdXN0b206IGN1c3RvbVByb21pc2lmeSB9XG59ID0gcmVxdWlyZSgnLi9vdXJzL3V0aWwnKVxuY29uc3QgeyBzdHJlYW1SZXR1cm5pbmdPcGVyYXRvcnMsIHByb21pc2VSZXR1cm5pbmdPcGVyYXRvcnMgfSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9vcGVyYXRvcnMnKVxuY29uc3Qge1xuICBjb2RlczogeyBFUlJfSUxMRUdBTF9DT05TVFJVQ1RPUiB9XG59ID0gcmVxdWlyZSgnLi9vdXJzL2Vycm9ycycpXG5jb25zdCBjb21wb3NlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2NvbXBvc2UnKVxuY29uc3QgeyBzZXREZWZhdWx0SGlnaFdhdGVyTWFyaywgZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsgfSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpXG5jb25zdCB7IHBpcGVsaW5lIH0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUnKVxuY29uc3QgeyBkZXN0cm95ZXIgfSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95JylcbmNvbnN0IGVvcyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtJylcbmNvbnN0IGludGVybmFsQnVmZmVyID0ge31cbmNvbnN0IHByb21pc2VzID0gcmVxdWlyZSgnLi9zdHJlYW0vcHJvbWlzZXMnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvdXRpbHMnKVxuY29uc3QgU3RyZWFtID0gKG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2xlZ2FjeScpLlN0cmVhbSlcblN0cmVhbS5pc0Rlc3Ryb3llZCA9IHV0aWxzLmlzRGVzdHJveWVkXG5TdHJlYW0uaXNEaXN0dXJiZWQgPSB1dGlscy5pc0Rpc3R1cmJlZFxuU3RyZWFtLmlzRXJyb3JlZCA9IHV0aWxzLmlzRXJyb3JlZFxuU3RyZWFtLmlzUmVhZGFibGUgPSB1dGlscy5pc1JlYWRhYmxlXG5TdHJlYW0uaXNXcml0YWJsZSA9IHV0aWxzLmlzV3JpdGFibGVcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9yZWFkYWJsZScpXG5mb3IgKGNvbnN0IGtleSBvZiBPYmplY3RLZXlzKHN0cmVhbVJldHVybmluZ09wZXJhdG9ycykpIHtcbiAgY29uc3Qgb3AgPSBzdHJlYW1SZXR1cm5pbmdPcGVyYXRvcnNba2V5XVxuICBmdW5jdGlvbiBmbiguLi5hcmdzKSB7XG4gICAgaWYgKG5ldy50YXJnZXQpIHtcbiAgICAgIHRocm93IEVSUl9JTExFR0FMX0NPTlNUUlVDVE9SKClcbiAgICB9XG4gICAgcmV0dXJuIFN0cmVhbS5SZWFkYWJsZS5mcm9tKFJlZmxlY3RBcHBseShvcCwgdGhpcywgYXJncykpXG4gIH1cbiAgT2JqZWN0RGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB2YWx1ZTogb3AubmFtZVxuICB9KVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShmbiwgJ2xlbmd0aCcsIHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdmFsdWU6IG9wLmxlbmd0aFxuICB9KVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShTdHJlYW0uUmVhZGFibGUucHJvdG90eXBlLCBrZXksIHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdmFsdWU6IGZuLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KVxufVxuZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0S2V5cyhwcm9taXNlUmV0dXJuaW5nT3BlcmF0b3JzKSkge1xuICBjb25zdCBvcCA9IHByb21pc2VSZXR1cm5pbmdPcGVyYXRvcnNba2V5XVxuICBmdW5jdGlvbiBmbiguLi5hcmdzKSB7XG4gICAgaWYgKG5ldy50YXJnZXQpIHtcbiAgICAgIHRocm93IEVSUl9JTExFR0FMX0NPTlNUUlVDVE9SKClcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3RBcHBseShvcCwgdGhpcywgYXJncylcbiAgfVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHZhbHVlOiBvcC5uYW1lXG4gIH0pXG4gIE9iamVjdERlZmluZVByb3BlcnR5KGZuLCAnbGVuZ3RoJywge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB2YWx1ZTogb3AubGVuZ3RoXG4gIH0pXG4gIE9iamVjdERlZmluZVByb3BlcnR5KFN0cmVhbS5SZWFkYWJsZS5wcm90b3R5cGUsIGtleSwge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB2YWx1ZTogZm4sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pXG59XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvd3JpdGFibGUnKVxuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kdXBsZXgnKVxuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy90cmFuc2Zvcm0nKVxuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3Bhc3N0aHJvdWdoJylcblN0cmVhbS5waXBlbGluZSA9IHBpcGVsaW5lXG5jb25zdCB7IGFkZEFib3J0U2lnbmFsIH0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYWRkLWFib3J0LXNpZ25hbCcpXG5TdHJlYW0uYWRkQWJvcnRTaWduYWwgPSBhZGRBYm9ydFNpZ25hbFxuU3RyZWFtLmZpbmlzaGVkID0gZW9zXG5TdHJlYW0uZGVzdHJveSA9IGRlc3Ryb3llclxuU3RyZWFtLmNvbXBvc2UgPSBjb21wb3NlXG5TdHJlYW0uc2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsgPSBzZXREZWZhdWx0SGlnaFdhdGVyTWFya1xuU3RyZWFtLmdldERlZmF1bHRIaWdoV2F0ZXJNYXJrID0gZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmtcbk9iamVjdERlZmluZVByb3BlcnR5KFN0cmVhbSwgJ3Byb21pc2VzJywge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIHJldHVybiBwcm9taXNlc1xuICB9XG59KVxuT2JqZWN0RGVmaW5lUHJvcGVydHkocGlwZWxpbmUsIGN1c3RvbVByb21pc2lmeSwge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICByZXR1cm4gcHJvbWlzZXMucGlwZWxpbmVcbiAgfVxufSlcbk9iamVjdERlZmluZVByb3BlcnR5KGVvcywgY3VzdG9tUHJvbWlzaWZ5LCB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIHJldHVybiBwcm9taXNlcy5maW5pc2hlZFxuICB9XG59KVxuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbVxuU3RyZWFtLl9pc1VpbnQ4QXJyYXkgPSBmdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheVxufVxuU3RyZWFtLl91aW50OEFycmF5VG9CdWZmZXIgPSBmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuay5idWZmZXIsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/stream/promises.js":
/*!*************************************************************!*\
  !*** ./node_modules/readable-stream/lib/stream/promises.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { ArrayPrototypePop, Promise } = __webpack_require__(/*! ../ours/primordials */ \"(ssr)/./node_modules/readable-stream/lib/ours/primordials.js\")\nconst { isIterable, isNodeStream, isWebStream } = __webpack_require__(/*! ../internal/streams/utils */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst { pipelineImpl: pl } = __webpack_require__(/*! ../internal/streams/pipeline */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/pipeline.js\")\nconst { finished } = __webpack_require__(/*! ../internal/streams/end-of-stream */ \"(ssr)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\n__webpack_require__(/*! ../../lib/stream.js */ \"(ssr)/./node_modules/readable-stream/lib/stream.js\")\nfunction pipeline(...streams) {\n  return new Promise((resolve, reject) => {\n    let signal\n    let end\n    const lastArg = streams[streams.length - 1]\n    if (\n      lastArg &&\n      typeof lastArg === 'object' &&\n      !isNodeStream(lastArg) &&\n      !isIterable(lastArg) &&\n      !isWebStream(lastArg)\n    ) {\n      const options = ArrayPrototypePop(streams)\n      signal = options.signal\n      end = options.end\n    }\n    pl(\n      streams,\n      (err, value) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(value)\n        }\n      },\n      {\n        signal,\n        end\n      }\n    )\n  })\n}\nmodule.exports = {\n  finished,\n  pipeline\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9zdHJlYW0vcHJvbWlzZXMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSw2QkFBNkIsRUFBRSxtQkFBTyxDQUFDLHlGQUFxQjtBQUNwRSxRQUFRLHdDQUF3QyxFQUFFLG1CQUFPLENBQUMscUdBQTJCO0FBQ3JGLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQywyR0FBOEI7QUFDbkUsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxxSEFBbUM7QUFDaEUsbUJBQU8sQ0FBQywrRUFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXRoLWxvbmRvbi0yMDI0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvc3RyZWFtL3Byb21pc2VzLmpzPzQ2MWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQXJyYXlQcm90b3R5cGVQb3AsIFByb21pc2UgfSA9IHJlcXVpcmUoJy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgeyBpc0l0ZXJhYmxlLCBpc05vZGVTdHJlYW0sIGlzV2ViU3RyZWFtIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9zdHJlYW1zL3V0aWxzJylcbmNvbnN0IHsgcGlwZWxpbmVJbXBsOiBwbCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZScpXG5jb25zdCB7IGZpbmlzaGVkIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0nKVxucmVxdWlyZSgnLi4vLi4vbGliL3N0cmVhbS5qcycpXG5mdW5jdGlvbiBwaXBlbGluZSguLi5zdHJlYW1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IHNpZ25hbFxuICAgIGxldCBlbmRcbiAgICBjb25zdCBsYXN0QXJnID0gc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdXG4gICAgaWYgKFxuICAgICAgbGFzdEFyZyAmJlxuICAgICAgdHlwZW9mIGxhc3RBcmcgPT09ICdvYmplY3QnICYmXG4gICAgICAhaXNOb2RlU3RyZWFtKGxhc3RBcmcpICYmXG4gICAgICAhaXNJdGVyYWJsZShsYXN0QXJnKSAmJlxuICAgICAgIWlzV2ViU3RyZWFtKGxhc3RBcmcpXG4gICAgKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gQXJyYXlQcm90b3R5cGVQb3Aoc3RyZWFtcylcbiAgICAgIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsXG4gICAgICBlbmQgPSBvcHRpb25zLmVuZFxuICAgIH1cbiAgICBwbChcbiAgICAgIHN0cmVhbXMsXG4gICAgICAoZXJyLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGVuZFxuICAgICAgfVxuICAgIClcbiAgfSlcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmaW5pc2hlZCxcbiAgcGlwZWxpbmVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/stream/promises.js\n");

/***/ })

};
;